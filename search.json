[{"title":"CentOS 7 升级 Linux 内核","url":"/2022/01/08/CentOS-7-%E5%8D%87%E7%BA%A7-Linux-%E5%86%85%E6%A0%B8/","content":"关于 Linux 内核Linux 内核分两种：官方内核（通常是内核开发人员用）和各大 Linux 发行版内核（一般用户常用）。\n\n\n官方内核在使用 Docker 时，发现其对 Linux 内核版本的最低要求是 3.10（这也刚好是 CentOS 7.2 的内核版本），但是在这个版本上有部分功能无法实现。目前 Linux 内核已经发布到 4.X（可以随时在 Linux内核官网 查看当前版本），为了使用最新版本的内核，只好在安装 CentOS 7 后对内核进行升级。\n当然，内核也不能选最新的，防止有尚未发现的 BUG。而且为了减少以后停止维护带来的麻烦，最好安装长期支持版本。各个版本的支持时间在 Linux内核档案 查看。每个版本可能有四种类型，概述如下：\n\nPrepatch：Prepatch 或 “RC” 内核是主要的内核预发行版本，主要针对内核开发人员和 Linux 爱好者。必须从源代码进行编译，并且通常包含必须在可以放入稳定版本之前进行测试的新功能。Prepatch 内核由 Linus Torvalds 维护和发布。\nMainline：Mainline 主线树由 Linus Torvalds 维护。这个版本的内核会引入所有新功能。新的 Mainline 内核每 2-3 个月发布一次。\nStable：每个主线内核被发布后，即被认为是“stable”。任何对 stable 内核的 BUG 修复都会从 Mainline 主线树中回溯并由指定的 stable 内核维护人员使用。 在下一个主线内核可用之前，通常只有几个 BUG 修复内核版本 - 除非它被指定为“longterm maintenance kernel（长期维护内核）”。stable 内核更新按需发布，通常每月 2-3 次。\nLongterm：通常会提供几个“longterm maintenance”内核版本，用于修复旧版内核的 BUG。这些内核只会修复重大 BUG，并且不会频繁发布版本。\n\nLongterm release 的内核\n\n\n版本\n维护人\n发布日期\n项目生命周期\n\n\n\n4.14\nGreg Kroah-Hartman\n2017-11-12\nJan, 2020\n\n\n4.9\nGreg Kroah-Hartman\n2016-12-11\nJan, 2019\n\n\n4.4\nGreg Kroah-Hartman\n2016-01-10\nFeb, 2022\n\n\n4.1\nSasha Levin\n2015-06-21\nMay, 2018\n\n\n3.16\nBen Hutchings\n2014-08-03\nApr, 2020\n\n\n3.2\nBen Hutchings\n2012-01-04\nMay, 2018\n\n\n各大 Linux 发行版内核一般来说，只有从 kernel.org 下载并编译安装的内核才是官方内核。大多数 Linux 发行版提供自行维护的内核，可以通过 yum 或 rpm 等包管理系统升级。这些内核可能不再和 Linux 内核官方开发维护人员有关系了。通过这个由各大 Linux 发行版支持的仓库升级内核，通常来说更简单可靠，但是可选择的内核版本也更少。\n使用 uname -r 区分你用的是官方内核还是 Linux 发行版内核，横线后面有任何东西都表示这不是官方内核：\n# uname -r3.10.0-514.26.2.el7.x86_64\n\n查看当前的内核版本概述Linux 只表示内核。各大 Linux 发行版（RedHat、Ubuntu、CentOS 等）在内核基础上集成了其他的一系列软件，按照各自的版本规则发布。例如 CentOS 7.2 中，通过 uname -r 查看内核版本时，会看到 3.10.0-514.26.2.el7.x86_64，表示对应的 Linux 内核版本是 3.10。\n常用的查看内核信息的命令uname打印指定的系统信息。不带参数时，默认使用 -s 参数。\n参数：-a, –all：按照下面的顺序打印所有信息，如果 -p 和 -i 未知时排除掉。-s, –kernel-name：打印内核名字，一般就是 Linux。-n, –nodename：打印网络节点的主机名。-r, –kernel-release：打印内核发行版的版本。常用。3.10.0-514.26.2.el7.x86_64-v, –kernel-version：打印内核的版本。#1 SMP Tue Jul 4 15:04:05 UTC 2017-m, –machine：打印机器硬件名。-p, –processor：打印处理器名字或“unknown”。-i, –hardware-platform：打印硬件平台或“unknown”。-o, –operating-system：打印操作系统。–help：显示这个帮助并退出。–version：显示这版本信息并退出。\n示例：\n# uname -r3.10.0-514.26.2.el7.x86_64# uname -aLinux VM_139_74_centos 3.10.0-514.26.2.el7.x86_64 #1 SMP Tue Jul 4 15:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) \n\n&#x2F;proc 虚拟文件系统内核空间和用户空间通过 /proc 虚拟文件系统可以通信。\n/proc 目录中包含一些目录和虚拟文件，这些虚拟文件可以向用户呈现内核信息或者从用户空间向内核发送信息。\n常用文件：\n\ncpuinfo：标识了处理器的类型和速度\npci：显示在 PCI 总线上找到的设备\nmodules：当前加载到内核中的模块\nversion：系统版本及内核版本\n\n示例：\n# cat /proc/version Linux version 3.10.0-514.26.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) ) #1 SMP Tue Jul 4 15:04:05 UTC 2017\n\n升级内核记得首先更新仓库：\nyum -y update\n\n-y 选项可以在每次需要确认时，自动使用 yes，节省时间。\n启用 ELRepo 仓库ELRepo 仓库是基于社区的用于企业级 Linux 仓库，提供对 RedHat Enterprise (RHEL) 和 其他基于 RHEL的 Linux 发行版（CentOS、Scientific、Fedora 等）的支持。ELRepo 聚焦于和硬件相关的软件包，包括文件系统驱动、显卡驱动、网络驱动、声卡驱动和摄像头驱动等。\n启用 ELRepo 仓库：\n# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org# rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm\n\n查看可用的系统内核包可以看到，只有 4.4 和 4.15 两个版本可以使用：\n# yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; list availableLoaded plugins: fastestmirror, langpackselrepo-kernel                                                   | 2.9 kB  00:00:00     elrepo-kernel/primary_db                                        | 1.7 MB  00:00:02     Determining fastest mirrors* elrepo-kernel: elrepo.orgAvailable Packageskernel-lt.x86_64                           4.4.118-1.el7.elrepo            elrepo-kernelkernel-lt-devel.x86_64                     4.4.118-1.el7.elrepo            elrepo-kernelkernel-lt-doc.noarch                       4.4.118-1.el7.elrepo            elrepo-kernelkernel-lt-headers.x86_64                   4.4.118-1.el7.elrepo            elrepo-kernelkernel-lt-tools.x86_64                     4.4.118-1.el7.elrepo            elrepo-kernelkernel-lt-tools-libs.x86_64                4.4.118-1.el7.elrepo            elrepo-kernelkernel-lt-tools-libs-devel.x86_64          4.4.118-1.el7.elrepo            elrepo-kernelkernel-ml.x86_64                           4.15.6-1.el7.elrepo             elrepo-kernelkernel-ml-devel.x86_64                     4.15.6-1.el7.elrepo             elrepo-kernelkernel-ml-doc.noarch                       4.15.6-1.el7.elrepo             elrepo-kernelkernel-ml-headers.x86_64                   4.15.6-1.el7.elrepo             elrepo-kernelkernel-ml-tools.x86_64                     4.15.6-1.el7.elrepo             elrepo-kernelkernel-ml-tools-libs.x86_64                4.15.6-1.el7.elrepo             elrepo-kernelkernel-ml-tools-libs-devel.x86_64          4.15.6-1.el7.elrepo             elrepo-kernelperf.x86_64                                4.15.6-1.el7.elrepo             elrepo-kernelpython-perf.x86_64\n\n安装最新内核# yum --enablerepo=elrepo-kernel install kernel-ml\n\n--enablerepo 选项开启 CentOS 系统上的指定仓库。默认开启的是 elrepo，这里用 elrepo-kernel 替换。\n设置 grub2内核安装好后，需要设置为默认启动选项并重启后才会生效\n查看系统上的所有可以内核# sudo awk -F\\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27; /etc/grub2.cfg0 : CentOS Linux (4.15.6-1.el7.elrepo.x86_64) 7 (Core)1 : CentOS Linux (3.10.0-514.26.2.el7.x86_64) 7 (Core)2 : CentOS Linux (3.10.0-327.el7.x86_64) 7 (Core)3 : CentOS Linux (0-rescue-f9d400c5e1e8c3a8209e990d887d4ac1) 7 (Core)\n\n设置 grub2机器上存在 4 个内核，我们要使用 4.15 这个版本，可以通过 grub2-set-default 0 命令或编辑 &#x2F;etc&#x2F;default&#x2F;grub 文件来设置。\n通过 grub2-set-default 0 命令设置其中 0 来自上一步的 awk 命令\nsudo grub2-set-default 0\n\n编辑 /etc/default/grub 文件设置 GRUB_DEFAULT&#x3D;0，表示使用上一步的 awk 命令显示的编号为 0 的内核作为默认内核\n# vi /etc/default/grub&gt; GRUB_TIMEOUT=5&gt; GRUB_DISTRIBUTOR=&quot;$(sed &#x27;s, release .*$,,g&#x27; /etc/system-release)&quot;&gt; GRUB_DEFAULT=0&gt; GRUB_DISABLE_SUBMENU=true&gt; GRUB_TERMINAL_OUTPUT=&quot;console&quot;&gt; GRUB_CMDLINE_LINUX=&quot;crashkernel=auto console=ttyS0 console=tty0 panic=5&quot;&gt; GRUB_DISABLE_RECOVERY=&quot;true&quot;&gt; GRUB_TERMINAL=&quot;serial console&quot;&gt; GRUB_TERMINAL_OUTPUT=&quot;serial console&quot;&gt; GRUB_SERIAL_COMMAND=&quot;serial --speed=9600 --unit=0 --word=8 --parity=no --stop=1&quot;\n\n生成 grub 配置文件并重启下一步，通过 gurb2-mkconfig 命令创建 grub2 的配置文件，然后重启\nsudo grub2-mkconfig -o /boot/grub2/grub.cfgsudo reboot\n\n验证通过 uname -r 查看，可以发现已经生效了。\n# uname -r4.15.6-1.el7.elrepo.x86_64\n\n删除旧内核 (可选)内核有两种删除方式：通过 yum remove 命令或通过 yum-utils 工具。\n通过 yum remove 命令查看系统中全部的内核：\n# rpm -qa | grep kernelkernel-tools-libs-3.10.0-514.26.2.el7.x86_64kernel-ml-4.15.6-1.el7.elrepo.x86_64kernel-3.10.0-327.el7.x86_64kernel-tools-3.10.0-514.26.2.el7.x86_64kernel-headers-3.10.0-514.26.2.el7.x86_64kernel-3.10.0-514.26.2.el7.x86_64\n\n删除旧内核的 RPM 包\nyum remove kernel-tools-libs-3.10.0-514.26.2.el7.x86_64 kernel-3.10.0-327.el7.x86_64 kernel-tools-3.10.0-514.26.2.el7.x86_64 kernel-headers-3.10.0-514.26.2.el7.x86_64 kernel-3.10.0-514.26.2.el7.x86_64\n\n通过 yum-utils 工具如果安装的内核不多于 3 个，yum-utils 工具不会删除任何一个。只有在安装的内核大于 3 个时，才会自动删除旧内核。\n安装yum install yum-utils\n\n删除package-cleanup --oldkernels\n","categories":["linux","centOS"],"tags":["linux","centOS"]},{"title":"Docker安装RabbitMQ","url":"/2021/11/22/Docker%E5%AE%89%E8%A3%85RabbitMQ/","content":"Docker Hub 仓库地址拉取镜像docker pull rabbitmq:3.8.12-management-alpine\n\n\n\n运行镜像docker run -d --hostname rabbit_host --name rabbitMQ -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 -p 5672:5672 rabbitmq:3.8.12-management-alpine\n\n持久化部署docker run -d --hostname rabbit_host --name rabbitMQ -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 --privileged=true -v /usr/local/rabbitmq/1/lib:/var/lib/rabbitmq -v /usr/local/rabbitmq/1/log:/var/log/rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3.8.12-management-alpine\n\n介绍\n-d 以守护进程方式在后台运行\n-p 15672:15672 management 界面管理访问端口\n-p 5672:5672 amqp 访问端口\n--name ${指定容器名}\n--hostname ${设定容器的主机名} （它会被写到容器内的 &#x2F;etc&#x2F;hostname 和 &#x2F;etc&#x2F;hosts 作为容器主机IP的别名，并且将显示在容器的bash中）\n-e 参数\nRABBITMQ_DEFAULT_USER ${用户名}\nRABBITMQ_DEFAULT_PASS ${密码}\n\n\n\n主要端口介绍\n4369 erlang 发现口\n5672 client 端通信口\n15672 管理界面 ui 端口\n25672 server 间内部通信口\n\n","tags":["linux","centOS","docker","rabbitMQ"]},{"title":"Hibernate 主键 ID 生成方式","url":"/2017/09/28/Hibernate-%E4%B8%BB%E9%94%AE-ID-%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/","content":"ID生成方式序列sequence 只适用于Oracle&lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;    &lt;generator class=&quot;sequence&quot;&gt;        &lt;param name=&quot;sequence&quot;&gt;person_seq&lt;/param&gt;&lt;!--指定sequence名--&gt;    &lt;/generator&gt;&lt;/id&gt;\n\n\n\n自增列，适用于SQLServer、MySql&lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;    &lt;generator class=&quot;identity&quot;/&gt;&lt;/id&gt;\n\n取最大值加一 max()+1&lt;id name=&quot;id&quot; column=&quot;id&quot; type=&quot;integer&quot;&gt;    &lt;generator class=&quot;increment&quot;/&gt;&lt;/id&gt;\n\n根据底层数据库指定生成方法&lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;    &lt;generator class=&quot;native&quot;/&gt;&lt;/id&gt;\n\n使用缺省策略针对Oracle数据库的生成方式还是sequence，只不过需要一个特定名字的sequence，”hibernate_sequence”。\n高低位算法&lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;    &lt;generator class=&quot;hilo&quot;&gt;        &lt;param name=&quot;table&quot;&gt;high_value&lt;/param&gt;        &lt;!--设置高位值取值的表--&gt;        &lt;param name=&quot;column&quot;&gt;next_value&lt;/param&gt;        &lt;!--设置高位值取值的字段--&gt;        &lt;param name=&quot;max_lo&quot;&gt;50&lt;/param&gt;        &lt;!--指定低位最大值，当取道最大值是会再取一个高位值再运算--&gt;    &lt;/generator&gt;&lt;/id&gt;\n\nOracle数据库注解 sequence 数据库序列定义@SequenceGenerator(name = &quot;sequenceInfo&quot;, sequenceName = &quot;SEQ_name&quot;)@GeneratedValue(generator = &quot;sequenceInfo&quot;)@Id@Columnprivate Integer id;\n\nSEQ_name 为Oracle数据库序列名\nOracle数据库XML sequence 数据库序列定义&lt;!--package为命名空间 子节点有多个类的全在com.entity包里--&gt;&lt;!--(如果不写,下面 &lt;class name=&quot;Emp&quot; name值&quot;Emp&quot;需要改成全限定类名(绝对路径)&quot;com.entity.Emp&quot;)--&gt;&lt;hibernate-mapping package=&quot;com.entity&quot;&gt;    &lt;class name=&quot;Emp&quot; table=&quot;emp&quot;&gt;        &lt;!--主键--&gt;        &lt;id name=&quot;id&quot;&gt;            &lt;!--自增方式--&gt;            &lt;generator class=&quot;sequence&quot;&gt;                &lt;param name=&quot;sequence&quot;&gt;SEQ_name&lt;/param&gt;            &lt;/generator&gt;        &lt;/id&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;\n","categories":["hibernate","xml","主键"],"tags":["hibernate","主键"]},{"title":"Docker将镜像推送到阿里云DockerRegistry","url":"/2021/12/09/Docker%E5%B0%86%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91DockerRegistry/","content":"登录阿里云Docker Registry[仓库地址] 以广州仓库为例\n\n公网地址 registry.cn-guangzhou.aliyuncs.com 仓库公网地址\n专有网络 registry-vpc.cn-guangzhou.aliyuncs.com 专有网络机器请使用仓库专有网络地址\n经典网络 registry-internal.cn-guangzhou.aliyuncs.com 通过访问镜像仓库内网地址来加快镜像下载速度并减少公网流量开销\n\ndocker login --username=[阿里云账号全名] [仓库地址] --password=[开通服务时设置的密码]\n\n\n\n异常解决Error: Cannot perform an interactive login from a non TTY devicewinpty docker login --username=[阿里云账号全名] [仓库地址] --password=[开通服务时设置的密码]\n\n从Registry中拉取镜像docker pull [仓库地址]/[命名空间]/[仓库名称]:[镜像版本号]\n\n将镜像推送到Registrydocker login --username=[阿里云账号全名] [仓库地址] --password=[开通服务时设置的密码]\n\ndocker tag [ImageId] [仓库地址]/[命名空间]/[仓库名称]:[镜像版本号]\n\ndocker push [仓库地址]/[命名空间]/[仓库名称]:[镜像版本号]\n\n[ImageId] 获取docker images\n\n选择合适的镜像仓库地址从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。\n如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-guangzhou.aliyuncs.com 作为Registry的域名登录。\n示例使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。\n$ docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com/acs/agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB$ docker tag 37bb9c63c8b2 registry-vpc.cn-guangzhou.aliyuncs.com/acs/agent:0.7-dfb6816\n\n使用 “docker push” 命令将该镜像推送至远程。\n$ docker push registry-vpc.cn-guangzhou.aliyuncs.com/acs/agent:0.7-dfb6816\n","categories":["docker","aliyun","registry"],"tags":["docker","aliyun","registry"]},{"title":"Hexo搭建个人博客","url":"/2017/03/17/Hexo-build-blog/","content":"准备工作了解HexoHexo 是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。\n\n\n搭建Node.js环境我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。\n点击下载 Node.js\n测试安装：命令行使用 node -v 和 npm -v 查看显示版本号即成功。\n安装Hexo博客框架工具Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下使用如下命令：\nnpm install hexo-cli -g\n\n安装Git版本工具Git是目前世界上最流行的分布式版本控制系统，是的，没有之一。使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。\n点击下载 Git\nWindows系统需下载，Mac系统因为自带Git无需操作。测试安装：命令行使用 git --version 查看显示版本号即成功。\n注册Github账号Github是一个面向开源及私有软件项目的托管平台，因为只支持 git 作为唯一的版本库格式进行托管，故名Github。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用Github同步我们个人博客的相关文件。\n注册地址： Github 官网注册流程： 百度一下,你就知道\n开始搭建博客搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库\n勾选 Initialize this repository with a README 避免后面不必要的麻烦\n其中的 %username% 替换成Github用户名\n这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是 %username% +“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https:&#x2F;&#x2F;%username%.github.io的形式。注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。\n点击Create Repository之后，随后选择Setting进入设置，找到Github Pages\n这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件\n此时若再查看Setting，我们会看到开启GitHub Pages之后得到的域名\n现在，我们就可以使用 https:&#x2F;&#x2F;%username%.github.io 访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式\n创建本地博客站点上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到Github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下：\n安装Hexo，在自己认为合适的地方创个文件夹，我是在E盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面\n输入 npm install hexo -g 开始安装Hexo\n输入 hexo -v 检查Hexo是否安装成功\n输入 hexo init 初始化该文件夹\n看到后面的 Start blogging with Hexo！ 表示成功\n输入 npm install 安装所需要的组件\n输入 hexo g g是generetor的缩写，生成博客\n输入 hexo s s是server的缩写，启动服务，访问该网址，正式体验Hexo\n问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入 hexo server -p 端口号 来改变端口号\n同步Github,允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址：\n修改本地博客根目录下的_config.yml文件，修改deploy下的配置如下：\n修改repository值为上面拷贝的仓库地址\ndeploy:  type: git  repository: git@github.com:%username%/%username%.github.io.git  branch: master\n\nGit安装后，右键有 Git Base Here 在本地博客文件夹打开\n将Hexo与Github page联系起来，设置Git的username和email\ngit config --global user.name &quot;Github用户名&quot;git config --global user.email &quot;Github绑定的邮箱&quot;\n\n输入 cd ~/.ssh 检查是否由.ssh的文件夹\n输入 ls 列出该文件下的内容\n输入 ssh-keygen -t rsa -C &quot;Github绑定的邮箱&quot; 连续三个回车，生成密钥\n最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator\\.ssh）\n输入 eval &quot;$(ssh-agent -s)&quot; 添加密钥到ssh-agent\n输入 ssh-add ~/.ssh/id_rsa 添加生成的SSH key到ssh-agent\n登录Github，点击头像下的Settings进入SSH and GPG keys选项，添加SSH keys\n新建一个New SSH key，将id_rsa.pub文件里的内容复制上去\n输入 ssh -T git@github.com 测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了\n新建一篇博客，用控制台定位到本地博客文件夹执行命令 hexo new &quot;My New Post&quot;\n这时候在文件夹_posts目录下将会看到已经创建的文件\n在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save\n使用编辑器编好文章，那么就可以使用命令： hexo d -g 生成以及部署了\n部署成功后访问你的地址将看到生成的文章\n","categories":["hexo"],"tags":["hexo","搭建博客"]},{"title":"Hibernate 多对多 一对多 多对一  配置解析案例","url":"/2017/10/28/Hibernate-%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E4%B8%80%E5%AF%B9%E5%A4%9A-%E5%A4%9A%E5%AF%B9%E4%B8%80-%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E6%A1%88%E4%BE%8B/","content":"什么是HibernateHibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet&#x2F;JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。\n\n\n此案例用于理解脏检查,以及Hibernate关系映射的配置pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com&lt;/groupId&gt;    &lt;artifactId&gt;HibernateCase&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;            &lt;version&gt;5.2.12.Final&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/com.hynnet/oracle-driver-ojdbc --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.oracle&lt;/groupId&gt;            &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;            &lt;version&gt;12.1.0.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n数据库的关系--部门CREATE TABLE depa(    ID NUMBER NOT NULL,    NAME NVARCHAR2 (50) NOT NULL);--职员CREATE TABLE emp(    ID NUMBER NOT NULL,    NAME NVARCHAR2 (50) NOT NULL,    depa_id NUMBER NOT NULL);--职位CREATE TABLE post(    ID NUMBER NOT NULL,    NAME NVARCHAR2 (50) NOT NULL);--职员职位CREATE TABLE emp_post(    emp_id NUMBER NOT NULL,    post_id NUMBER NOT NULL);\n\nemp_post 职员职位表为中间表,实体类可以不存在\n实体类Depapackage com.entity;import java.util.HashSet;import java.util.Set;public class Depa &#123;    private Integer id;    private String name;    private Set&lt;Emp&gt; emps = new HashSet&lt;Emp&gt;();    @Override    public String toString() &#123;        return &quot;Depa&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public Set&lt;Emp&gt; getEmps() &#123;        return emps;    &#125;    public void setEmps(Set&lt;Emp&gt; emps) &#123;        this.emps = emps;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\nEmppackage com.entity;import java.util.HashSet;import java.util.Set;public class Emp &#123;    private Integer id;    private String name;    private Depa depaid;    private Set&lt;Post&gt; posts = new HashSet&lt;Post&gt;();    @Override    public String toString() &#123;        return &quot;Emp&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public Set&lt;Post&gt; getPosts() &#123;        return posts;    &#125;    public void setPosts(Set&lt;Post&gt; posts) &#123;        this.posts = posts;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Depa getDepaid() &#123;        return depaid;    &#125;    public void setDepaid(Depa depaid) &#123;        this.depaid = depaid;    &#125;&#125;\n\nPostpackage com.entity;import java.util.HashSet;import java.util.Set;public class Post &#123;    private Integer id;    private String name;    private Set&lt;Emp&gt; emps = new HashSet&lt;Emp&gt;();    @Override    public String toString() &#123;        return &quot;Post&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public Set&lt;Emp&gt; getEmps() &#123;        return emps;    &#125;    public void setEmps(Set&lt;Emp&gt; emps) &#123;        this.emps = emps;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\nEmp 实体类 和 Post 实体类 都有对方的 Set&lt;?&gt; 集合,这也是操作中间表 emp_post 的关键属性\n对实体类关系映射配置depa.hbm.xml&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.entity&quot;&gt;    &lt;class name=&quot;Depa&quot; table=&quot;depa&quot;&gt;        &lt;id name=&quot;id&quot;&gt;            &lt;generator class=&quot;increment&quot;/&gt;        &lt;/id&gt;        &lt;property name=&quot;name&quot;/&gt;        &lt;!--一对多 name为实体类属性名 class为对应外键对应实体类--&gt;        &lt;!--table 实体类对象数据来源数据库表名 cascade维护方式--&gt;        &lt;!--inverse 指定由哪一方来维护之间的关联关系 当一方中指定了&quot;inverse=false&quot;(默认),那么那一方就有责任负责之间的关联关系--&gt;        &lt;set name=&quot;emps&quot; table=&quot;emp&quot; cascade=&quot;all&quot; inverse=&quot;true&quot;&gt;            &lt;!--column 为emp数据库关联depa的外键名--&gt;            &lt;key column=&quot;depa_id&quot;&gt;&lt;/key&gt;            &lt;!--class emps的单个实体数据为哪个实体类--&gt;            &lt;one-to-many class=&quot;Emp&quot;/&gt;        &lt;/set&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;\n\nemp.hbm.xml&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;!--package为命名空间 子节点有多个类的全在com.entity包里--&gt;&lt;!--(如果不写,下面 &lt;class name=&quot;Emp&quot; name值&quot;Emp&quot;需要改成&quot;com.entity.Emp&quot;)--&gt;&lt;hibernate-mapping package=&quot;com.entity&quot;&gt;    &lt;class name=&quot;Emp&quot; table=&quot;emp&quot;&gt;        &lt;!--主键--&gt;        &lt;id name=&quot;id&quot;&gt;            &lt;!--自增方式--&gt;            &lt;generator class=&quot;increment&quot;/&gt;        &lt;/id&gt;        &lt;!--普通数据列--&gt;        &lt;property name=&quot;name&quot;/&gt;        &lt;!--多对一 name为实体类属性名 class为对应外键对应实体类 column为数据库外键名(如果与name值一样可以忽略)--&gt;        &lt;many-to-one name=&quot;depaid&quot; class=&quot;Depa&quot; column=&quot;depa_id&quot;/&gt;        &lt;!--多对多 name为实体类属性名 table 关联的中间表 cascade 维护方式 save-update 为维护方式是新增或修改--&gt;        &lt;set name=&quot;posts&quot; table=&quot;emp_post&quot; cascade=&quot;save-update&quot;&gt;            &lt;!--中间表emp_post 对应emp的外键--&gt;            &lt;key column=&quot;emp_id&quot;&gt;&lt;/key&gt;            &lt;!--class 多对多的实体类 column 中间表emp_post 对应Post的外键--&gt;            &lt;many-to-many class=&quot;Post&quot; column=&quot;post_id&quot;/&gt;        &lt;/set&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;\n\npost.hbm.xml&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.entity&quot;&gt;    &lt;class name=&quot;Post&quot; table=&quot;post&quot;&gt;        &lt;id name=&quot;id&quot;&gt;            &lt;generator class=&quot;increment&quot;/&gt;        &lt;/id&gt;        &lt;property name=&quot;name&quot;/&gt;        &lt;!--多对多 name为实体类属性名 table 关联的中间表 cascade 维护方式 save-update 为维护方式是新增或修改--&gt;        &lt;set name=&quot;emps&quot; table=&quot;emp_post&quot; cascade=&quot;save-update&quot;&gt;            &lt;!--中间表emp_post 对应post的外键--&gt;            &lt;key column=&quot;post_id&quot;&gt;&lt;/key&gt;            &lt;!--class 多对多的实体类 column 中间表emp_post 对应Emp的外键--&gt;            &lt;many-to-many class=&quot;Emp&quot; column=&quot;emp_id&quot;/&gt;        &lt;/set&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;\n\n将实体类的 XML 映射到 hibernate.cfg.xml 配置\nhibernate.cfg.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;        &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;property name=&quot;connection.url&quot;&gt;jdbc:oracle:thin:@localhost:1521:orcl&lt;/property&gt;        &lt;property name=&quot;connection.username&quot;&gt;system&lt;/property&gt;        &lt;property name=&quot;connection.password&quot;&gt;simon&lt;/property&gt;        &lt;property name=&quot;connection.driver_class&quot;&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;        &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;        &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt;        &lt;mapping resource=&quot;com/entity/depa.hbm.xml&quot;/&gt;        &lt;mapping resource=&quot;com/entity/emp.hbm.xml&quot;/&gt;        &lt;mapping resource=&quot;com/entity/post.hbm.xml&quot;/&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;\n\nHibernate工具类 HibernateUtilpackage com.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123;    private static Configuration configuration;    private static final SessionFactory factory;    static &#123;        configuration = new Configuration().configure(&quot;hibernate.cfg.xml&quot;);        factory = configuration.buildSessionFactory();    &#125;    public static Session getSession() &#123;        return factory.getCurrentSession();    &#125;&#125;\n\n测试类 Testpackage com.test;import com.entity.Depa;import com.entity.Emp;import com.entity.Post;import com.util.HibernateUtil;import org.hibernate.Session;import org.hibernate.Transaction;public class Test &#123;    public static void main(String[] args) &#123;        Session session = HibernateUtil.getSession();        Transaction transaction = session.beginTransaction();        System.out.println(&quot;查询ID为1的职员数据&quot;);        Emp emp = session.get(Emp.class, 1);        System.out.println(emp);        System.out.println(&quot;通过职员得到中间表emp_post数据&quot;);        for (Post post : emp.getPosts()) &#123;            System.out.println(post);        &#125;        System.out.println(&quot;清除职员中间表emp_post的数据&quot;);        emp.getPosts().clear();        System.out.println(&quot;查询ID为2的职位数据&quot;);        Post post = session.get(Post.class, 2);        System.out.println(post);        System.out.println(&quot;将查到的职位给职员新增中间表emp_post数据&quot;);        emp.getPosts().add(post);        System.out.println(&quot;查询ID为1的职员数据&quot;);        emp = session.get(Emp.class, 1);        System.out.println(emp);        System.out.println(&quot;通过职员得到中间表emp_post数据&quot;);        for (Post temp : emp.getPosts()) &#123;            System.out.println(temp);        &#125;        System.out.println(&quot;通过职员得到部门表depa数据&quot;);        System.out.println(emp.getDepaid());        System.out.println(&quot;查询ID为1的部门数据&quot;);        Depa depa = session.get(Depa.class, 1);        System.out.println(depa);        System.out.println(&quot;将查到的部门depa给职员emp利用脏检查修改&quot;);        emp.setDepaid(depa);        System.out.println(&quot;查询ID为1的职员数据&quot;);        emp = session.get(Emp.class, 1);        System.out.println(emp);        System.out.println(&quot;通过职员得到部门表depa数据&quot;);        System.out.println(emp.getDepaid());        System.out.println(&quot;查询ID为2的部门数据&quot;);        depa = session.get(Depa.class, 2);        System.out.println(depa);        System.out.println(&quot;得到部门对象所属职员&quot;);        for (Emp e : depa.getEmps()) &#123;            System.out.println(e);        &#125;        System.out.println(&quot;利用脏检查删除部门对象所属的ID为1的职员&quot;);        depa.getEmps().remove(emp);        System.out.println(&quot;查询ID为2的部门数据&quot;);        depa = session.get(Depa.class, 2);        System.out.println(depa);        System.out.println(&quot;得到部门对象所属职员&quot;);        for (Emp e : depa.getEmps()) &#123;            System.out.println(e);        &#125;        //不提交,则上面的结果不会对数据库执行操作//        transaction.commit();    &#125;&#125;\n\n控制台输出看看测试类代码对数据库的数据进行了哪些操作\n查询ID为1的职员数据Hibernate:    select        emp0_.id as id1_1_0_,        emp0_.name as name2_1_0_,        emp0_.depa_id as depa_id3_1_0_    from        emp emp0_    where        emp0_.id=?Emp&#123;id=1, name=&#x27;张三&#x27;&#125;通过职员得到中间表emp_post数据Hibernate:    select        posts0_.emp_id as emp_id1_2_0_,        posts0_.post_id as post_id2_2_0_,        post1_.id as id1_3_1_,        post1_.name as name2_3_1_    from        emp_post posts0_    inner join        post post1_            on posts0_.post_id=post1_.id    where        posts0_.emp_id=?Post&#123;id=1, name=&#x27;职员&#x27;&#125;清除职员中间表emp_post的数据查询ID为2的职位数据Hibernate:    select        post0_.id as id1_3_0_,        post0_.name as name2_3_0_    from        post post0_    where        post0_.id=?Post&#123;id=2, name=&#x27;主管&#x27;&#125;将查到的职位给职员新增中间表emp_post数据查询ID为1的职员数据Emp&#123;id=1, name=&#x27;张三&#x27;&#125;通过职员得到中间表emp_post数据Post&#123;id=2, name=&#x27;主管&#x27;&#125;通过职员得到部门表depa数据Hibernate:    select        depa0_.id as id1_0_0_,        depa0_.name as name2_0_0_    from        depa depa0_    where        depa0_.id=?Depa&#123;id=2, name=&#x27;美工部&#x27;&#125;查询ID为1的部门数据Hibernate:    select        depa0_.id as id1_0_0_,        depa0_.name as name2_0_0_    from        depa depa0_    where        depa0_.id=?Depa&#123;id=1, name=&#x27;销售部&#x27;&#125;将查到的部门depa给职员emp利用脏检查修改查询ID为1的职员数据Emp&#123;id=1, name=&#x27;张三&#x27;&#125;通过职员得到部门表depa数据Depa&#123;id=1, name=&#x27;销售部&#x27;&#125;查询ID为2的部门数据Depa&#123;id=2, name=&#x27;美工部&#x27;&#125;得到部门对象所属职员Hibernate:    select        emps0_.depa_id as depa_id3_1_0_,        emps0_.id as id1_1_0_,        emps0_.id as id1_1_1_,        emps0_.name as name2_1_1_,        emps0_.depa_id as depa_id3_1_1_    from        emp emps0_    where        emps0_.depa_id=?Emp&#123;id=1, name=&#x27;张三&#x27;&#125;利用脏检查删除部门对象所属的ID为1的职员查询ID为2的部门数据Depa&#123;id=2, name=&#x27;美工部&#x27;&#125;得到部门对象所属职员\n\n\n点击访问仓库案例为重新整理的, MySQL连接为主, 字段名进行了修改, 整体区别不大\n","categories":["hibernate","关系映射"],"tags":["hibernate","idea","mysql","oracle","多对多","一对多","多对一","many-to-many","many-to-one","one-to-many","关系映射"]},{"title":"Hibernate中的mappedBy和注解@JoinColumn","url":"/2017/06/06/Hibernate%E4%B8%AD%E7%9A%84mappedBy%E5%92%8C%E6%B3%A8%E8%A7%A3-JoinColumn/","content":"mappedBymappedBy用于指定具有双向关系的两个实体中。哪个实体是被关联处理的。\n只有OneToOne,OneToMany,ManyToMany上才有mappedBy属性，ManyToOne不存在该属性@OneToMany(mappedBy&#x3D;“由One的一方指向Many的一方，并且，这个属性应该等于Many的一方中含有One类的属性的对象名，否则会出错”)关系的拥有方(Many的一方)负责关系的维护，在拥有方建立外键。所以用到@JoinColumn\n\nimport javax.persistence.*;import java.util.Set;@Entity@Tablepublic class Users &#123;    @Id    @Column    private Integer id;    private String name;    //mappedBy由One的一方指向Many的一方，并且，这个属性应该等于Many的一方中含有One类的属性的对象名    @OneToMany(targetEntity = House.class, mappedBy = &quot;user_id&quot;)    private Set&lt;House&gt; houseSet;&#125;\n\nJoinColumn@JoinColumn指定了Users通过外键u_id关联到当前的user_id。用@JoinColumn指向One的一个外键字段(数据库对应外键字段名)。\nimport javax.persistence.*;import java.util.Date;@Entity@Tablepublic class House &#123;    @Id    @Column    private Integer id;    private String title;    @ManyToOne(targetEntity = Users.class)    @JoinColumn(name = &quot;u_id&quot;)    private Users user_id;&#125;\n","categories":["hibernate","注解"],"tags":["hibernate","mappedBy","JoinColumn"]},{"title":"Hibernate主键自增长increment","url":"/2017/06/18/Hibernate%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E9%95%BFincrement/","content":"increment由Hibernate从数据库中取出主键的最大值（每个session只取1次），以该值为基础，每次增量为1，在内存中生成主键，不依赖于底层的数据库，因此可以跨数据库。\n&lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;    &lt;generator class=&quot;increment&quot; /&gt;&lt;/id&gt;\nHibernate调用org.hibernate.id.IncrementGenerator类里面的generate()方法，使用select max(idColumnName) from tableName语句获取主键最大值。\n\n\n以上为 XML 配置自增长，而使用 注解 的方式就需要一下的步骤实现：\n@GenericGenerator(name = &quot;generator&quot;, strategy = &quot;increment&quot;)@GeneratedValue(generator = &quot;generator&quot;)@Id@Columnprivate Integer id;\n","categories":["hibernate","increment"],"tags":["hibernate","increment"]},{"title":"Hibernate配置文件hibernate.cfg.xml和.hbm.xml的详细解释","url":"/2017/05/31/Hibernate%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6hibernate-cfg-xml%E5%92%8C-hbm-xml%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A/","content":"什么是HibernateHibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet&#x2F;JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。\nHibernate配置文件hibernate.cfg.xml和.hbm.xml的详细解释Hibernate 中有两个常见的配置文件 hibernate.cfg.xml 和 XXX.hbm.xml\n其中 Maven 项目对象模型的 pom.xml 可以去 Maven知识库 得到对应的 dependency 部分\n\n\n如需手动导入文件，先下载文件。并用 mvn 执行\nmvn install:install-file -Dfile=下载文件所在路径 -DgroupId=dependency配置的groupId部分 -DartifactId=dependency配置的artifactId部分 -Dversion=dependency配置的版本 -Dpackaging=属于什么文件    \n\n例如\nmvn install:install-file -Dfile=c:\\ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0.1.0 -Dpackaging=jar\n\nhibernate.cfg.xml&lt;!--标准的XML文件的起始行，version=&#x27;1.0&#x27;表明XML的版本，encoding=&#x27;gb2312&#x27;表明XML文件的编码方式--&gt;       &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--表明解析本XML文件的DTD文档位置，DTD是Document Type Definition 的缩写,即文档类型的定义,XML解析器使用DTD文档来检查XML文件的合法性。hibernate.sourceforge.net/hibernate-configuration-3.0dtd可以在Hibernate3.1.3软件包中的src\\org\\hibernate目录中找到此文件--&gt;     &lt;!DOCTYPE hibernate-configuration PUBLIC     &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;     &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;     &lt;!--声明Hibernate配置文件的开始--&gt;          &lt;hibernate-configuration&gt;         &lt;!--表明以下的配置是针对session-factory配置的，SessionFactory是Hibernate中的一个类，这个类主要负责保存HIbernate的配置信息，以及对Session的操作--&gt;         &lt;session-factory&gt;                &lt;!--配置数据库的驱动程序，Hibernate在连接数据库时，需要用到数据库的驱动程序--&gt;             &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;oracle.jdbc.driver.OracleDriver &lt;/property&gt;             &lt;!--设置数据库的连接url:jdbc:mysql://localhost/hibernate,其中localhost表示mysql服务器名称，此处为本机，    hibernate是数据库名--&gt;              &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost/hibernate&lt;/property&gt;          &lt;!--连接数据库是用户名--&gt;             &lt;property name=&quot;hibernate.connection.username&quot;&gt;root &lt;/property&gt;             &lt;!--连接数据库是密码--&gt;             &lt;property name=&quot;hibernate.connection.password&quot;&gt;123456 &lt;/property&gt;                    &lt;!--数据库连接池的大小--&gt;             &lt;property name=&quot;hibernate.connection.pool.size&quot;&gt;20 &lt;/property&gt;                    &lt;!--是否在后台显示Hibernate用到的SQL语句，开发时设置为true，便于差错，程序运行时可以在Eclipse的控制台显示Hibernate的执行Sql语句。项目部署后可以设置为false，提高运行效率--&gt;             &lt;property name=&quot;hibernate.show_sql&quot;&gt;true &lt;/property&gt;             &lt;!--jdbc.fetch_size是指Hibernate每次从数据库中取出并放到JDBC的Statement中的记录条数。Fetch Size设的越大，读数据库的次数越少，速度越快，Fetch Size越小，读数据库的次数越多，速度越慢--&gt;             &lt;property name=&quot;jdbc.fetch_size&quot;&gt;50 &lt;/property&gt;             &lt;!--jdbc.batch_size是指Hibernate批量插入,删除和更新时每次操作的记录数。Batch Size越大，批量操作的向数据库发送Sql的次数越少，速度就越快，同样耗用内存就越大--&gt;             &lt;property name=&quot;jdbc.batch_size&quot;&gt;23 &lt;/property&gt;             &lt;!--jdbc.use_scrollable_resultset是否允许Hibernate用JDBC的可滚动的结果集。对分页的结果集。对分页时的设置非常有帮助--&gt;             &lt;property name=&quot;jdbc.use_scrollable_resultset&quot;&gt;false &lt;/property&gt;             &lt;!--connection.useUnicode连接数据库时是否使用Unicode编码--&gt;             &lt;property name=&quot;Connection.useUnicode&quot;&gt;true &lt;/property&gt;             &lt;!--connection.characterEncoding连接数据库时数据的传输字符集编码方式，最好设置为gbk，用gb2312有的字符不全--&gt;             &lt;property name=&quot;connection.characterEncoding&quot;&gt;gbk &lt;/property&gt;                  &lt;!--hibernate.dialect 只是Hibernate使用的数据库方言,就是要用Hibernate连接那种类型的数据库服务器。--&gt;             &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect &lt;/property&gt;             &lt;!--指定映射文件为“hibernate/ch1/UserInfo.hbm.xml”--&gt;                    &lt;mapping resource=&quot;org/mxg/UserInfo.hbm.xml&quot;&gt;         &lt;/session-factory&gt;     &lt;/hibernate-configuration&gt;        &lt;bean id=&quot;dataSource&quot;      class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;      destroy-method=&quot;close&quot;&gt;          //连接驱动            &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt;          //连接url,            &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;          //连接用户名            &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;          //连接密码            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;      &lt;/bean&gt;      &lt;bean id=&quot;hbSessionFactory&quot;      class=&quot;org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;          &lt;property name=&quot;configLocation&quot;&gt;              //hibernate配置文件位置                &lt;value&gt;WEB-INF/hibernate.cfg.xml &lt;/value&gt;          &lt;/property&gt;          &lt;property name=&quot;configurationClass&quot;          value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;          &lt;property name=&quot;hibernateProperties&quot;&gt;              &lt;props&gt;                  //针对oracle数据库的方言,特定的关系数据库生成优化的SQL                    &lt;prop key=&quot;hibernate.dialect&quot;&gt;                  org.hibernate.dialect.OracleDialect                    &lt;/prop&gt;                  //选择HQL解析器的实现                    &lt;prop key=&quot;hibernate.query.factory_class&quot;&gt;                  org.hibernate.hql.ast.ASTQueryTranslatorFactory                    &lt;/prop&gt;                  //是否在控制台打印sql语句                    &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true &lt;/prop&gt;                  //在Hibernate系统参数中hibernate.use_outer_join被打开的情况下,该参数用来允许使用outer join来载入此集合的数据。                    &lt;prop key=&quot;hibernate.use_outer_join&quot;&gt;true &lt;/prop&gt;                  //默认打开，启用cglib反射优化。cglib是用来在Hibernate中动态生成PO字节码的，打开优化可以加快字节码构造的速度                    &lt;prop key=&quot;hibernate.cglib.use_reflection_optimizer&quot;&gt;true &lt;/prop&gt;                  //输出格式化后的sql,更方便查看                    &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true &lt;/prop&gt;                  //“useUnicode”和“characterEncoding”决定了它是否在客户端和服务器端传输过程中进行Encode，以及如何进行Encode                    &lt;prop key=&quot;hibernate.connection.useUnicode&quot;&gt;true &lt;/prop&gt;                  //允许查询缓存, 个别查询仍然需要被设置为可缓存的.                    &lt;prop key=&quot;hibernate.cache.use_query_cache&quot;&gt;false &lt;/prop&gt;                  &lt;prop key=&quot;hibernate.default_batch_fetch_size&quot;&gt;16 &lt;/prop&gt;                  //连接池的最大活动个数                    &lt;prop key=&quot;hibernate.dbcp.maxActive&quot;&gt;100 &lt;/prop&gt;                  //当连接池中的连接已经被耗尽的时候，DBCP将怎样处理(0 = 失败,1 = 等待,2  =  增长)                    &lt;prop key=&quot;hibernate.dbcp.whenExhaustedAction&quot;&gt;1 &lt;/prop&gt;                  //最大等待时间                    &lt;prop key=&quot;hibernate.dbcp.maxWait&quot;&gt;1200 &lt;/prop&gt;                  //没有人用连接的时候，最大闲置的连接个数                    &lt;prop key=&quot;hibernate.dbcp.maxIdle&quot;&gt;10 &lt;/prop&gt;                  ##以下是对prepared statement的处理，同上。                    &lt;prop key=&quot;hibernate.dbcp.ps.maxActive&quot;&gt;100 &lt;/prop&gt;                  &lt;prop key=&quot;hibernate.dbcp.ps.whenExhaustedAction&quot;&gt;1 &lt;/prop&gt;                  &lt;prop key=&quot;hibernate.dbcp.ps.maxWait&quot;&gt;1200 &lt;/prop&gt;                  &lt;prop key=&quot;hibernate.dbcp.ps.maxIdle&quot;&gt;10 &lt;/prop&gt;              &lt;/props&gt;          &lt;/property&gt;      &lt;/bean&gt;\n\nXXX.hbm.xml&lt;?xml version=&quot;1.0&quot;?&gt;    &lt;!DOCTYPE hibernate-mapping PUBLIC         &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;    &lt;!--         &lt;hibernate-mapping&gt;一般不去配置，采用默认即可。        default-cascade=&quot;none&quot;：默认的级联风格，表与表联动。        default-lazy=&quot;true&quot;：默认延迟加载     --&gt;    &lt;hibernate-mapping&gt;        &lt;!--             &lt;class&gt;：使用class元素定义一个持久化类。            name=&quot;cn.javass.user.vo.UserModel&quot;：持久化类的java全限定名；            table=&quot;tbl_user&quot;：对应数据库表名；            mutable=&quot;true&quot;：默认为true，设置为false时则不可以被应用程序更新或删除；            dynamic-insert=&quot;false&quot;：默认为false，动态修改那些有改变过的字段，而不用修改所有字段；            dynamic-update=&quot;false&quot;：默认为false，动态插入非空值字段；            select-before-update=&quot;false&quot;：默认为false，在修改之前先做一次查询，与用户的值进行对比，有变化都会真正更新；            optimistic-lock=&quot;version&quot;：默认为version(检查version/timestamp字段)，取值：all(检查全部字段)、dirty(只检查修改过的字段)、                                       none(不使用乐观锁定)，此参数主要用来处理并发，每条值都有固定且唯一的版本，版本为最新时才能执行操作；         --&gt;        &lt;class name=&quot;cn.javass.user.vo.UserModel&quot; table=&quot;tbl_user&quot; dynamic-insert=&quot;true&quot; dynamic-update=&quot;true&quot; optimistic-lock=&quot;version&quot;&gt;            &lt;!--                 &lt;id&gt;：定义了该属性到数据库表主键字段的映射。                name=&quot;userId&quot;：标识属性的名字；                column=&quot;userId&quot;：表主键字段的名字，如果不填写与name一样；             --&gt;            &lt;id name=&quot;userId&quot;&gt;                &lt;!-- &lt;generator&gt;：指定主键由什么生成，推荐使用uuid（随机生成唯一通用的表示符，实体类的ID必须是String），                                 native（让数据库自动选择用什么生成（根据底层数据库的能力选择identity，sequence或hilo中的一种）），                                 assigned（指用户手工填入，默认）。 --&gt;                &lt;generator class=&quot;uuid&quot;/&gt;            &lt;/id&gt;            &lt;!--                 &lt;version/&gt;：使用版本控制来处理并发，要开启optimistic-lock=&quot;version&quot;和dynamic-update=&quot;true&quot;。                name=&quot;version&quot;：持久化类的属性名，column=&quot;version&quot;：指定持有版本号的字段名；             --&gt;            &lt;version name=&quot;version&quot; column=&quot;version&quot;/&gt;            &lt;!--                 &lt;property&gt;：为类定义一个持久化的javaBean风格的属性。                name=&quot;name&quot;：标识属性的名字，以小写字母开头；                column=&quot;name&quot;：表主键字段的名字，如果不填写与name一样；                update=&quot;true&quot;/insert=&quot;true&quot;：默认为true，表示可以被更新或插入；             --&gt;            &lt;property name=&quot;name&quot; column=&quot;name&quot; /&gt;            &lt;property name=&quot;sex&quot; column=&quot;sex&quot;/&gt;            &lt;property name=&quot;age&quot; column=&quot;age&quot;/&gt;            &lt;!--                 组件映射：把多个属性打包在一起当一个属性使用，用来把类的粒度变小。                &lt;component name=&quot;属性，这里指对象&quot;&gt;                    &lt;property name=&quot;name1&quot;&gt;&lt;/property&gt;                    &lt;property name=&quot;name2&quot;&gt;&lt;/property&gt;                &lt;/component&gt;             --&gt;             &lt;!--                 &lt;join&gt;:一个对象映射多个表，该元素必须放在所有&lt;property&gt;之后。                &lt;join table=&quot;tbl_test：子表名&quot;&gt;                    &lt;key column=&quot;uuid：子表主键&quot;&gt;&lt;/key&gt;                &lt;property name=&quot;name1：对象属性&quot; column=&quot;name：子表字段&quot;&gt;&lt;/property&gt;             &lt;/join&gt;              --&gt;        &lt;/class&gt;    &lt;/hibernate-mapping&gt;\n","categories":["hibernate"],"tags":["hibernate","配置"]},{"title":"HttpUtils 阿里云市场 api网关请求签名","url":"/2019/09/18/HttpUtils-%E9%98%BF%E9%87%8C%E4%BA%91%E5%B8%82%E5%9C%BA-api%E7%BD%91%E5%85%B3%E8%AF%B7%E6%B1%82%E7%AD%BE%E5%90%8D/","content":"HttpUtils 多用于 api网关请求签名\n请求方式 : Get Post Put Delete\n\n\nhttp接口请求工具类 HttpUtils.classimport org.apache.commons.lang.StringUtils;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.HttpClient;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpDelete;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.methods.HttpPut;import org.apache.http.conn.ClientConnectionManager;import org.apache.http.conn.scheme.Scheme;import org.apache.http.conn.scheme.SchemeRegistry;import org.apache.http.conn.ssl.SSLSocketFactory;import org.apache.http.entity.ByteArrayEntity;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.message.BasicNameValuePair;import javax.net.ssl.SSLContext;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.security.KeyManagementException;import java.security.NoSuchAlgorithmException;import java.security.cert.X509Certificate;import java.util.ArrayList;import java.util.List;import java.util.Map;/** * 重要提示如下: * HttpUtils请从 * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java * 下载 * &lt;p&gt; * 相应的依赖请参照 * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml */public class HttpUtils &#123;    /**     * get     *     * @param host     * @param path     * @param method     * @param headers     * @param querys     * @return     * @throws Exception     */    public static HttpResponse doGet(String host, String path, String method,                                     Map&lt;String, String&gt; headers,                                     Map&lt;String, String&gt; querys)            throws Exception &#123;        HttpClient httpClient = wrapClient(host);        HttpGet request = new HttpGet(buildUrl(host, path, querys));        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;            request.addHeader(e.getKey(), e.getValue());        &#125;        return httpClient.execute(request);    &#125;    /**     * post form     *     * @param host     * @param path     * @param method     * @param headers     * @param querys     * @param bodys     * @return     * @throws Exception     */    public static HttpResponse doPost(String host, String path, String method,                                      Map&lt;String, String&gt; headers,                                      Map&lt;String, String&gt; querys,                                      Map&lt;String, String&gt; bodys)            throws Exception &#123;        HttpClient httpClient = wrapClient(host);        HttpPost request = new HttpPost(buildUrl(host, path, querys));        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;            request.addHeader(e.getKey(), e.getValue());        &#125;        if (bodys != null) &#123;            List&lt;NameValuePair&gt; nameValuePairList = new ArrayList&lt;NameValuePair&gt;();            for (String key : bodys.keySet()) &#123;                nameValuePairList.add(new BasicNameValuePair(key, bodys.get(key)));            &#125;            UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(nameValuePairList, &quot;utf-8&quot;);            formEntity.setContentType(&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;);            request.setEntity(formEntity);        &#125;        return httpClient.execute(request);    &#125;    /**     * Post String     *     * @param host     * @param path     * @param method     * @param headers     * @param querys     * @param body     * @return     * @throws Exception     */    public static HttpResponse doPost(String host, String path, String method,                                      Map&lt;String, String&gt; headers,                                      Map&lt;String, String&gt; querys,                                      String body)            throws Exception &#123;        HttpClient httpClient = wrapClient(host);        HttpPost request = new HttpPost(buildUrl(host, path, querys));        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;            request.addHeader(e.getKey(), e.getValue());        &#125;        if (StringUtils.isNotBlank(body)) &#123;            request.setEntity(new StringEntity(body, &quot;utf-8&quot;));        &#125;        return httpClient.execute(request);    &#125;    /**     * Post stream     *     * @param host     * @param path     * @param method     * @param headers     * @param querys     * @param body     * @return     * @throws Exception     */    public static HttpResponse doPost(String host, String path, String method,                                      Map&lt;String, String&gt; headers,                                      Map&lt;String, String&gt; querys,                                      byte[] body)            throws Exception &#123;        HttpClient httpClient = wrapClient(host);        HttpPost request = new HttpPost(buildUrl(host, path, querys));        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;            request.addHeader(e.getKey(), e.getValue());        &#125;        if (body != null) &#123;            request.setEntity(new ByteArrayEntity(body));        &#125;        return httpClient.execute(request);    &#125;    /**     * Put String     *     * @param host     * @param path     * @param method     * @param headers     * @param querys     * @param body     * @return     * @throws Exception     */    public static HttpResponse doPut(String host, String path, String method,                                     Map&lt;String, String&gt; headers,                                     Map&lt;String, String&gt; querys,                                     String body)            throws Exception &#123;        HttpClient httpClient = wrapClient(host);        HttpPut request = new HttpPut(buildUrl(host, path, querys));        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;            request.addHeader(e.getKey(), e.getValue());        &#125;        if (StringUtils.isNotBlank(body)) &#123;            request.setEntity(new StringEntity(body, &quot;utf-8&quot;));        &#125;        return httpClient.execute(request);    &#125;    /**     * Put stream     *     * @param host     * @param path     * @param method     * @param headers     * @param querys     * @param body     * @return     * @throws Exception     */    public static HttpResponse doPut(String host, String path, String method,                                     Map&lt;String, String&gt; headers,                                     Map&lt;String, String&gt; querys,                                     byte[] body)            throws Exception &#123;        HttpClient httpClient = wrapClient(host);        HttpPut request = new HttpPut(buildUrl(host, path, querys));        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;            request.addHeader(e.getKey(), e.getValue());        &#125;        if (body != null) &#123;            request.setEntity(new ByteArrayEntity(body));        &#125;        return httpClient.execute(request);    &#125;    /**     * Delete     *     * @param host     * @param path     * @param method     * @param headers     * @param querys     * @return     * @throws Exception     */    public static HttpResponse doDelete(String host, String path, String method,                                        Map&lt;String, String&gt; headers,                                        Map&lt;String, String&gt; querys)            throws Exception &#123;        HttpClient httpClient = wrapClient(host);        HttpDelete request = new HttpDelete(buildUrl(host, path, querys));        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123;            request.addHeader(e.getKey(), e.getValue());        &#125;        return httpClient.execute(request);    &#125;    private static String buildUrl(String host, String path, Map&lt;String, String&gt; querys) throws UnsupportedEncodingException &#123;        StringBuilder sbUrl = new StringBuilder();        sbUrl.append(host);        if (!StringUtils.isBlank(path)) &#123;            sbUrl.append(path);        &#125;        if (null != querys) &#123;            StringBuilder sbQuery = new StringBuilder();            for (Map.Entry&lt;String, String&gt; query : querys.entrySet()) &#123;                if (0 &lt; sbQuery.length()) &#123;                    sbQuery.append(&quot;&amp;&quot;);                &#125;                if (StringUtils.isBlank(query.getKey()) &amp;&amp; !StringUtils.isBlank(query.getValue())) &#123;                    sbQuery.append(query.getValue());                &#125;                if (!StringUtils.isBlank(query.getKey())) &#123;                    sbQuery.append(query.getKey());                    if (!StringUtils.isBlank(query.getValue())) &#123;                        sbQuery.append(&quot;=&quot;);                        sbQuery.append(URLEncoder.encode(query.getValue(), &quot;utf-8&quot;));                    &#125;                &#125;            &#125;            if (0 &lt; sbQuery.length()) &#123;                sbUrl.append(&quot;?&quot;).append(sbQuery);            &#125;        &#125;        return sbUrl.toString();    &#125;    private static HttpClient wrapClient(String host) &#123;        HttpClient httpClient = new DefaultHttpClient();        if (host.startsWith(&quot;https://&quot;)) &#123;            sslClient(httpClient);        &#125;        return httpClient;    &#125;    private static void sslClient(HttpClient httpClient) &#123;        try &#123;            SSLContext ctx = SSLContext.getInstance(&quot;TLS&quot;);            X509TrustManager tm = new X509TrustManager() &#123;                public X509Certificate[] getAcceptedIssuers() &#123;                    return null;                &#125;                public void checkClientTrusted(X509Certificate[] xcs, String str) &#123;                &#125;                public void checkServerTrusted(X509Certificate[] xcs, String str) &#123;                &#125;            &#125;;            ctx.init(null, new TrustManager[]&#123;tm&#125;, null);            SSLSocketFactory ssf = new SSLSocketFactory(ctx);            ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);            ClientConnectionManager ccm = httpClient.getConnectionManager();            SchemeRegistry registry = ccm.getSchemeRegistry();            registry.register(new Scheme(&quot;https&quot;, 443, ssf));        &#125; catch (KeyManagementException ex) &#123;            throw new RuntimeException(ex);        &#125; catch (NoSuchAlgorithmException ex) &#123;            throw new RuntimeException(ex);        &#125;    &#125;&#125;\n\n相应的依赖请参照\nhttps://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.aliyun.api.gateway&lt;/groupId&gt;    &lt;artifactId&gt;java.demo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;fastjson&lt;/artifactId&gt;\t\t\t&lt;version&gt;1.2.15&lt;/version&gt;\t\t&lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;            &lt;version&gt;4.2.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;            &lt;artifactId&gt;httpcore&lt;/artifactId&gt;            &lt;version&gt;4.2.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-lang&lt;/groupId&gt;            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;            &lt;version&gt;2.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;            &lt;artifactId&gt;jetty-util&lt;/artifactId&gt;            &lt;version&gt;9.3.7.v20160115&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.5&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n","categories":["http","api网关请求"],"tags":["HttpUtils","http","接口请求","工具类","api网关请求"]},{"title":"IDEA生成 Serializable 序列化 UID 的快捷键","url":"/2019/02/20/IDEA%E7%94%9F%E6%88%90-Serializable-%E5%BA%8F%E5%88%97%E5%8C%96-UID-%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"首先创建一个类如User, 让该类实现Serializable序列化接口\npublic class User implements Serializable &#123;&#125;\n\n然后在菜单选择 File | Settings | Editor | Inspections\n\n\n在搜索框里输入\nSerializable class without &#x27;serialVersionUID&#x27;\n\n在搜索到的选项中勾选 Serializable class without &#39;serialVersionUID&#39; 点击 OK\n之后我们要将光标放到实体类的名字 User 上，然后 Alt + Enter(回车)\n会出现 Add &#39;serialVersionUID&#39; field 这个选项, 然后直接回车即可\n之后我们就可以看到自动生成的UID了\nprivate static final long serialVersionUID = 1L;\n","categories":["idea","Serializable"],"tags":["idea","Serializable","序列化","快捷键"]},{"title":"IntelliJ IDEA 下自动生成数据库实体类","url":"/2018/05/15/IntelliJ-IDEA-%E4%B8%8B%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BD%93%E7%B1%BB/","content":"按下图点击 view 选择 tool windows 选择 database 并点击弹出Database窗口，点击加号 + 选择 data source 选择想添加的数据库并点击弹出DataSources and Drivers窗口，填写连接数据库的信息\n\nHost  ip地址  本地填 localhost\nDatabase  数据库名称\nUser  账号\nPassword  密码\n第一次有些没有安装对应的插件，下面会有警告 点击警告下载即可\n点击一下 test Connection 如果连接成功，那么 test Connection 按钮的右边会显示 一句话提示连接成功。连接成功后就点击右下角的OK选择需要生成的数据表，右键选择 scripted extensions 点击 generate POJOs.groovy 即可","categories":["idea","自动生成数据库实体类"],"tags":["idea","自动生成数据库实体类"]},{"title":"Java中继承与多态实例","url":"/2017/07/04/Java%E4%B8%AD%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B/","content":"继承的概念继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。子类又被称为派生类； 父类又被称为超类（Super Class）。一个子类只能够继承一个父类，存在单继承局限。 在一个子类继承的时候，实际上会继承父类之中的所有操作（属性、方法），但是需要注意的是，对于所有的非私有（no private）操作属于显式继承（可以直接利用对象操作），而所有的私有操作属于隐式继承（间接完成）。在继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化，即：默认情况下，子类会找到父类之中的无参构造方法。\n\n\n用于理解的democlass A &#123;\tpublic String show(D obj) &#123;\t\treturn (&quot;A and D&quot;);\t&#125;\tpublic String show(A obj) &#123;\t\treturn (&quot;A and A&quot;);\t&#125;&#125;class B extends A &#123;\tpublic String show(B obj) &#123;\t\treturn (&quot;B and B&quot;);\t&#125;\tpublic String show(A obj) &#123;\t\treturn (&quot;B and A&quot;);\t&#125;&#125;class C extends B &#123;&#125;class D extends B &#123;&#125;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\tA a1 = new A();\t\tA a2 = new B();\t\tB b = new B();\t\tC c = new C();\t\tD d = new D();\t\tSystem.out.println(&quot;1--&quot; + a1.show(b));\t\tSystem.out.println(&quot;2--&quot; + a1.show(c));\t\tSystem.out.println(&quot;3--&quot; + a1.show(d));\t\tSystem.out.println(&quot;4--&quot; + a2.show(b));\t\tSystem.out.println(&quot;5--&quot; + a2.show(c));\t\tSystem.out.println(&quot;6--&quot; + a2.show(d));\t\tSystem.out.println(&quot;7--&quot; + b.show(b));\t\tSystem.out.println(&quot;8--&quot; + b.show(c));\t\tSystem.out.println(&quot;9--&quot; + b.show(d));\t&#125;&#125;\n\n控制台输出结果1--A and A2--A and A3--A and D4--B and A5--B and A6--A and D7--B and B8--B and B9--A and D\n","categories":["java","extends"],"tags":["java","继承","多态","extends","重写"]},{"title":"JWT生成Token做登录校验","url":"/2018/12/10/JWT%E7%94%9F%E6%88%90Token%E5%81%9A%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C/","content":"JWT生成Token做登录校验JWT官网文章采用提供者auth0版本(贡献者GitHub)maven&lt;dependency&gt;    &lt;groupId&gt;com.auth0&lt;/groupId&gt;    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;    &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n工具类import com.auth0.jwt.JWT;import com.auth0.jwt.JWTVerifier;import com.auth0.jwt.algorithms.Algorithm;import com.auth0.jwt.impl.PublicClaims;import com.auth0.jwt.interfaces.Claim;import com.auth0.jwt.interfaces.DecodedJWT;import java.util.Calendar;import java.util.Date;import java.util.HashMap;import java.util.Map;public class JwtToken &#123;    private static final String SECRET = &quot;simon&quot;;//公用私密    /**     * 生成token     *     * @param object     * @param minute     * @return     * @throws Exception     */    public static String createToken(Object object, Integer minute) throws Exception &#123;        //签发时间        Date iaDate = new Date();        //TODO 转换加密对象 User user=(User)object;        //过期时间 - 一分钟过期        Calendar nowTime = Calendar.getInstance();        nowTime.add(Calendar.MINUTE, minute);        Date expiresDate = nowTime.getTime();        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(PublicClaims.ALGORITHM, &quot;HS256&quot;);        map.put(PublicClaims.TYPE, &quot;JWT&quot;);        String token = JWT.create()                .withHeader(map)//TODO .withClaim(&quot;id&quot;,user.getId())                .withExpiresAt(expiresDate)//设置过期时间,过期时间大于签发时间                .withIssuedAt(iaDate)//设置签发时间                .sign(Algorithm.HMAC256(SECRET));//加密        return token;    &#125;    /**     * 解密token     *     * @param token     * @return     * @throws Exception     */    public static Map&lt;String, Claim&gt; verifyToken(String token) throws Exception &#123;        JWTVerifier verifier = JWT.require(Algorithm.HMAC256(SECRET)).build();        try &#123;            DecodedJWT verify = verifier.verify(token);            return verify.getClaims();        &#125; catch (Exception e) &#123;            throw new RuntimeException(&quot;Illegal request&quot;);        &#125;    &#125;&#125;\n","categories":["JWT"],"tags":["JWT","token","jsonwebtoken"]},{"title":"Java标签使用","url":"/2019/05/06/Java%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8/","content":"Java 中的标签是为循环设计的，是为了在多重循环中方便的使用break 和coutinue 。\n以下实例当在循环中使用 break 或 continue 循环时跳到指定的标签处\n\n\npublic class Main &#123;    public static void main(String[] args) &#123;        String strSearch = &quot;This is the string in which you have to search for a substring.&quot;;        String substring = &quot;substring&quot;;        boolean found = false;        int max = strSearch.length() - substring.length();        testlbl:        for (int i = 0; i &lt;= max; i++) &#123;            int length = substring.length();            int j = i;            int k = 0;            while (length-- != 0) &#123;                if(strSearch.charAt(j++) != substring.charAt(k++))&#123;                    continue testlbl;                &#125;            &#125;            found = true;            break testlbl;        &#125;        if (found) &#123;            System.out.println(&quot;发现子字符串。&quot;);        &#125;        else &#123;            System.out.println(&quot;字符串中没有发现子字符串。&quot;);        &#125;    &#125;&#125;\n\n以上代码运行输出结果为\n发现子字符串。\n\nbreak + 标签, 跳出循环, 并到标签处, 下次不再进入循环\ncontinue + 标签, 跳出循环, 从标签处继续执行, 可继续进入循环条件\n","categories":["java","标签"],"tags":["java","标签"]},{"title":"Java的Excel读写-easyExcel方法封装","url":"/2019/05/20/Java%E7%9A%84Excel%E8%AF%BB%E5%86%99-easyExcel%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/","content":"JAVA解析的Excel工具easyexcelJava解析，生成Excel比较有名的框架有Apache poi，jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大.easyexcel重写了poi对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到KB级别，并且再大的Excel中不会出现内存溢出，03版依赖POI的萨克斯模式。在上层做了模型转换的封装，让使用者更加简单方便\n\n\nMaven依赖&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;    &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;\n\ngitee源码请自行下载源码,访问 localhost/readExcelWithSheets 下载文件后自行用 Postman 测试\n","categories":["easyExcel"],"tags":["easyExcel","Excel"]},{"title":"Java集合总结","url":"/2016/11/12/Java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/","content":"Java集合类型//Java导包import java.util.List;import java.util.ArrayList;import java.util.Map;import java.util.HashMap;import java.util.Hashtable;\n\n\n\n泛型集合前面的都是接口 /** * 泛型集合 */List&lt;String&gt; list = new ArrayList&lt;String&gt;();/** * K键泛型集合 */Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();//Map添加数据map.put(Integer, String);\t//put塞入的意思\n\n集合前面的都是类 /** * 集合 */ArrayList array = new ArrayList();/** * K键集合 */Hashtable hashtable = new Hashtable();/** * Set集合\t//唯一\t//里面的值不能有重复的;重复添加不报错;会替换最后添加 */Set set = new HashSet();\n\n集合操作//清空集合数据list.clear();\n\nArrayList集合的应用//声明集合List list = new ArrayList();//新增数据list.add(Object类型值).list.add(int 索引号，值)//得到集合个数list.size();\t//长度//得到集合里面的数据Object obj = (集合存储数据类型)list.get(int i);\t//get得到集合下标位置int 类型 i 的数据//删除方式lis.remove(0);\t//删除索引第一个的数据lis.remove(Object类型值);\t//按照指定的对象名删除//判断集合中的对象是否存在if(list.contains(集合存储数据类型对象))&#123;\t//返回Boolean类型\t存在为true&#125;\n\n遍历方式(调用集合数据里的对象方法)//增强for循环for(Object obj : list)&#123;\t((集合存储数据类型)obj).该对象拥有的方法;&#125;//for循环for(int i = 0; i &lt; list.Size(); i++)&#123;\tObject obj = (集合存储数据类型)list.get(i);\t//get得到集合下标位置的数据\t集合存储数据类型 字段名 = (集合存储数据类型)obj;\t//拆箱\t字段名.该对象拥有的方法;&#125;\n\nLinkedList集合的应用//声明集合LinkedList list = new LinkedList();//新增数据(在ArrayList基础上新增方法)list.addFirst(Object类型值);\t//新增到第一个位置list.addLast(Object类型值);\t//新增到最后一个位置//得到集合里面的数据(在ArrayList基础上新增方法)Object obj = (集合存储数据类型)list.getFirst();\t\t//getFirst得到集合第一个位置的数据Object obj = (集合存储数据类型)list.getLast();\t\t//getLast得到集合最后一个位置的数据//删除方式(在ArrayList基础上新增方法)list.removeFirst();\t//删除第一个对象list.removeLast();\t//删除最后一个对象\n\nK键//判断带K键的集合中的K键是否存在if(list.containsKey(集合存储K键类型值))&#123;\t//返回Boolean类型\t存在为true&#125;//判断带K键的集合中的Value值是否存在if(list.containsValue(集合存储Value类型值))&#123;\t//返回Boolean类型\t存在为true&#125;//得到集合里面的数据集合存value储数据类型 value = (集合存储value数据类型)list.get(key);\t//get得到集合指定的K键名的value 数据//删除方式lis.remove(集合存储K键类型值);\t//按照指定的K键名删除对象//分别显示键集 / 值集 / 键值对集合list.keySet();\t\t//键集list.values();\t\t//值集list;\t\t\t//键值对集合\n\n迭代器Set keys = map.keySet();\t//迭代器方式Iterator it = keys.iterator();\t//获得Iterator对象while(it.hasNext())&#123;\tString key = (String)it.next();\t//获得键名\t集合存value储数据类型 value = (集合存储value数据类型)list.get(key);\t//get得到集合指定的K键名的value 数据\tvalue.该对象拥有的方法;&#125;\n","categories":["java","集合"],"tags":["java","集合"]},{"title":"Linux centOS 7.X 服务器Docker安装和部署容器化Redis","url":"/2021/10/26/Linux-centOS-7-X-%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2%E5%AE%B9%E5%99%A8%E5%8C%96Redis/","content":"Linux环境下安装Docker依次运行以下命令添加yum源yum updateyum install epel-release -yyum clean allyum list\n\n\n\n安装并运行Dockeryum install docker-io -ysystemctl start docker\n\n检查安装结果docker info\n\n运行Docker守护进程systemctl start docker\n\n停止Docker守护进程systemctl stop docker\n\n重启Docker守护进程systemctl restart docker\n\n修改镜像仓库vim /etc/docker/daemon.json\n\n改为下面内容 然后重启Docker&#123;&quot;debug&quot;:true,&quot;experimental&quot;:true,&quot;registry-mirrors&quot;:[&quot;https://pb5bklzr.mirror.aliyuncs.com&quot;,&quot;https://hub-mirror.c.163.com&quot;,&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125;\n\ndocker部署Redis(定义6379伪端口 转发 默认端口6379) 并配置密码docker run -itd --name redis -p 6379:6379 redis --requirepass 123456\n\n持久化部署docker run -itd --name redis -p 6379:6379 redis --requirepass 123456 -v /data/redis/data:/data\n\nRancher配置redis-server --appendonly yes --requirepass 123456\n\n\n\n\nOptions\nMean\n\n\n\n-i\n以交互模式运行容器，通常与 -t 同时使用\n\n\n-t\n为容器重新分配一个伪输入终端，通常与 -i 同时使用\n\n\n-d\n后台运行容器，并返回容器ID\n\n\n查询僵尸文件docker volume ls -qf dangling=true\n\n删除所有dangling数据卷（即无用的Volume，僵尸文件）docker volume rm $(docker volume ls -qf dangling=true)","tags":["linux","centOS","docker","Redis","rancher"]},{"title":"Linux安装MySQL","url":"/2018/12/13/Linux%E5%AE%89%E8%A3%85MySQL/","content":"Linux Ubuntu apt-get安装MySQLapt-get更新到最新sudo apt-get update\n\n\n\n安装 mysql-client-core-5.7sudo apt-get install mysql-client-core-5.7\n\n安装 mysql-client-5.7sudo apt-get install mysql-client-5.7\n\n安装 mysql-server-5.7sudo apt-get install mysql-server-5.7\n注意：在安装的时候会让你输入一个密码，此密码是mysql数据库root用户的密码，请记住自己输入的密码，此密码和服务器root用户的密码不是同一个。\n┌─────────────────────────────────────────┤ Configuring mysql-server-5.7 ├─────────────────────────────────────────┐│ While not mandatory, it is highly recommended that you set a password for the MySQL administrative &quot;root&quot; user.  ││                                                                                                                  ││ If this field is left blank, the password will not be changed.                                                   ││                                                                                                                  ││ New password for the MySQL &quot;root&quot; user:                                                                          ││                                                                                                                  ││ ________________________________________________________________________________________________________________ ││                                                                                                                  ││                                                      &lt;Ok&gt;                                                        ││                                                                                                                  │└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n密码输入完后,按 [shift+enter] 进行确定 !!!\n重启服务service mysql restart\n\n查看服务状态service mysql status\n服务开启输出的内容\n● mysql.service - MySQL Community Server   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)   Active: active (running) since Thu 2018-12-13 14:36:48 CST; 15s ago  Process: 26464 ExecStartPost=/usr/share/mysql/mysql-systemd-start post (code=exited, status=0/SUCCESS)  Process: 26450 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=exited, status=0/SUCCESS) Main PID: 26462 (mysqld)   CGroup: /system.slice/mysql.service           └─26462 /usr/sbin/mysqld\n\nLinux centOS wget安装MySQLwget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpmrpm -ivh mysql57-community-release-el7-8.noarch.rpmyum -y install mysql-server\n默认配置文件路径配置文件 : /etc/my.cnf日志文件 : /var/log/mysqld.log服务启动脚本 : /usr/lib/systemd/system/mysqld.servicesocket文件 : /var/run/mysqld/mysqld.pid\n安装完成后，密码为随机密码，需要重置密码启动mysql服务service mysqld restart\n重置密码grep &quot;password&quot; /var/log/mysqld.log\n显示以下格式日志\n2019-03-27T11:03:55.199916Z 1 [Note] A temporary password is generated for root@localhost: hRd&gt;NyG/K4ho\nhRd&gt;NyG/K4ho 为随机密码\n登录MySQLmysql -u root -p\n\n修改密码alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;\n\n刷新权限flush privileges;\n\n指令和上面ubuntu差不多 mysql 改成 mysqld\n设置用户 root 可以在任意 IP 下被访问grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;123456&#x27;;flush privileges;\n\nUbuntu安装Mysql时没有提示设置密码问题$sudo vim /etc/mysql/debian.cnf$mysql -u debian-sys-maint -puse mysql;update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host =&#x27;localhost&#x27;;update user set plugin=&quot;mysql_native_password&quot;;flush privileges;quit;$sudo service mysql restart\n\ndocker容器化部署数据库Mysqldocker run -p 3306:3306 --name mysql5.7 \\-v /usr/local/docker/mysql/conf:/etc/mysql \\-v /usr/local/docker/mysql/logs:/var/log/mysql \\-v /usr/local/docker/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\-d mysql:5.7","categories":["linux","mysql"],"tags":["linux","mysql","wget","apt-get"]},{"title":"MD5加密 springMVC文件上传显示示例","url":"/2018/07/26/MD5%E5%8A%A0%E5%AF%86-springMVC%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%98%BE%E7%A4%BA%E7%A4%BA%E4%BE%8B/","content":"Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2(一般老项目使用)等。\n\n\nMD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。\npom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;FileUpload&lt;/name&gt;    &lt;groupId&gt;com&lt;/groupId&gt;    &lt;artifactId&gt;FileUpload&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.8.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;3.2.13.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--文件上传  必备--&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-io&lt;/groupId&gt;            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;            &lt;version&gt;2.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\nspringMVC-servlet.xml 配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd&quot;       default-autowire=&quot;byName&quot;&gt;    &lt;!--注解扫描配置--&gt;    &lt;context:component-scan base-package=&quot;com&quot;/&gt;    &lt;!--内部资源视图解析器--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!--前缀解析--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt;        &lt;!--后缀解析--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!--文件上件必备--&gt;    &lt;bean class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot; name=&quot;multipartResolver&quot;&gt;        &lt;!--1MB = 1024KB 1KB = 1024B 单位字节/B--&gt;        &lt;property name=&quot;maxUploadSize&quot; value=&quot;7340032&quot;/&gt;&lt;!--7MB--&gt;        &lt;!--默认编码格式--&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;    &lt;/bean&gt;    &lt;!--使 @Controller 注解生效--&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--配置静态文件资源的访问--&gt;    &lt;!--否则 WEB-INF 下的 css 等资源文件访问不到--&gt;    &lt;mvc:resources mapping=&quot;/**&quot; location=&quot;/WEB-INF/&quot;/&gt;&lt;/beans&gt;\n\nweb.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.4&quot;         xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;    &lt;!--加载springMVC--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--配置加载的springMVC-servlet.xml 默认为 servlet-name 的值 XXX-servlet.xml--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springMVC-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\nFileUtil 工具类 创建文件夹package com.util;import java.io.File;public class FileUtil &#123;    /**     * 根据路径创建文件夹     */    public static void createDir(String path) &#123;        File file = new File(path);        //不存在则创建文件夹以及子文件夹        if (!file.exists())            file.mkdirs();    &#125;&#125;\n\nMD5Util 工具类 加密防止中文名图片可以上传不能显示\npackage com.util;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * EncoderByMd5 */public class MD5Util &#123;    public static String EncoderByMd5(String str) &#123;        MessageDigest md5 = null;        try &#123;            md5 = MessageDigest.getInstance(&quot;MD5&quot;);            // 这句是关键            md5.update(str.getBytes(&quot;UTF-8&quot;));        &#125; catch (NoSuchAlgorithmException e) &#123;            e.printStackTrace();        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;        byte b[] = md5.digest();        int i;        StringBuffer buf = new StringBuffer();        for (int offset = 0; offset &lt; b.length; offset++) &#123;            i = b[offset];            if (i &lt; 0)                i += 256;            if (i &lt; 16)                buf.append(&quot;0&quot;);            buf.append(Integer.toHexString(i));        &#125;        System.out.println(buf.toString());        return buf.toString();    &#125;    public static void main(String[] args) &#123;        System.out.println(MD5Util.EncoderByMd5(&quot;Simon&quot;));    &#125;&#125;\nImgController servlet层package com.controller;import com.util.FileUtil;import com.util.MD5Util;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpSession;import java.io.File;import java.io.IOException;@Controllerpublic class ImgController &#123;    //文件上传    @RequestMapping(&quot;/uploadImg&quot;)    public String uploadImg(MultipartFile imgFile, HttpSession session, Model model) &#123;        //获取上传文件的文件名字        String filename = imgFile.getOriginalFilename();        System.out.println(filename);        //文件名去后缀        String substring = filename.substring(0, filename.lastIndexOf(&quot;.jpg&quot;));        System.out.println(substring);        //加密加后缀        String s = new StringBuffer(MD5Util.EncoderByMd5(substring)).append(&quot;.jpg&quot;).toString();        //获取保存文件的目录        String path = session.getServletContext().getRealPath(&quot;/WEB-INF/img&quot;);        System.out.println(path);        //创建目录        FileUtil.createDir(path);        //文件保存路径        File outFile = new File(path, s);        model.addAttribute(&quot;img&quot;, s);        try &#123;            imgFile.transferTo(outFile);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return &quot;index&quot;;    &#125;&#125;\n\nindex.jsp 页面&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;uploadImg&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;imgFile&quot;/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt;&lt;img src=&quot;/img/$&#123;img&#125;&quot; height=&quot;700&quot;&gt;&lt;/body&gt;&lt;/html&gt;\n\n示例下载","categories":["springMVC"],"tags":["MD5","springMVC","文件上传"]},{"title":"Markdown 语法 API","url":"/2016/09/18/Markdown-Syntax-API/","content":"Markdown：语法概观\n\n哲学\n\nMarkdown旨在尽可能易于阅读和易于编写。\n但是，可读性强调一切。Markdown格式的文档应该以纯文本的形式发布，而不会看起来像标签或格式化指令。尽管Markdown的语法受到了几种现有的文本到HTML过滤器的影响，包括 Setext， atx， Textile， reStructuredText，Grutatext， 和 EtText ，Markdown语法的最大灵感来源是纯文本电子邮件的格式。\n为此，Markdown的语法完全由标点字符组成，标点字符经过仔细选择以便看起来像他们的意思。 例如，一个词的星号实际上看起来像 *强调*。 Markdown列表看起来就像列表。 即使blockquotes看起来像引用的文本段落，假设你曾经使用过电子邮件。\n\n\n内联HTML\n\nMarkdown的语法仅用于一个目的：用作网络 书写 的格式。\nMarkdown不是HTML的替代品，甚至不接近它。 它的语法非常小，仅对应于HTML标签的一小部分。 这个想法 并不是 创建一个使插入HTML标签更容易的语法。 在我看来，HTML标签已经很容易插入。 Markdown的想法是让阅读，写作和阅读变得容易编辑散文。 HTML是一种 发布 格式; Markdown是一种 书写 格式。 因此，Markdown的格式化语法只能解决以纯文本形式传达的问题。\n对于Markdown语法未涉及的任何标记，您只需使用HTML本身。 没有必要在前言或分隔它以表明您正在从Markdown切换到HTML; 你只需使用标签。\n唯一的限制是块级HTML元素 - 例如 &lt;div&gt;， &lt;table&gt;， &lt;pre&gt;， &lt;p&gt; 等等。必须通过空行将其与周围内容分开，并且块的开始和结束标记不应该用制表符或空格缩进。 Markdown足够智能，不会在HTML块级标签周围添加额外的（不需要的） &lt;p&gt; 标签。\n例如，要将一个HTML表添加到Markdown文章中：\n这是一个正常的段落。\n\n&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;Foo&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n这是另一个常规段落。\n\n请注意，Markdown格式化语法不在块级HTML标记中处理。 例如，您不能在HTML块中使用Markdown风格 *重点*。\n跨度级HTML标记 - 例如 &lt;span&gt;， &lt;cite&gt; 或 &lt;del&gt; - 可用于Markdown段落，列表项目或标题中的任何位置。 如果你愿意，你甚至可以使用HTML标签而不是Markdown格式; 例如 如果您希望使用HTML &lt;a&gt; 或 &lt;img&gt; 标记而不是Markdown的链接或图像语法，请继续前进。\n与块级HTML标签不同，Markdown语法 在 跨度级别标签内处理。\n自动转义特殊字符\n\n在HTML中，有两个字符需要特殊处理： &lt; 和 &amp;。 左尖括号用于启动标签; ＆符号用于表示HTML实体。 如果你想用它们作为文字字符，你必须将它们作为实体转义，例如 &amp;lt; 和 &amp;amp;。\n特别是对于网络编写者来说，＆符号是很困难的。 如果你想写’AT&amp;T’，你需要写’AT&amp;amp;T‘。 您甚至需要在网址中跳过＆符号。 因此，如果你想链接到：\nhttp://images.google.com/images?num=30&amp;q=larry+bird\n\n您需要将URL编码为：\nhttp://images.google.com/images?num=30&amp;amp;q=larry+bird\n\n在你的锚标记 href 属性中。 不用说，这很容易被遗忘，并且可能是在其他标记良好的网站中最常见的HTML验证错误来源。\nMarkdown允许您自然使用这些角色，并为您处理所有必要的转义。 如果使用＆符号作为HTML实体的一部分，则它保持不变; 否则它将被翻译成 &amp;amp;。\n所以，如果你想在你的文章中包含一个版权符号，你可以写：\n&amp;copy;\n\nMarkdown将不再支持它。 但是如果你写：\nAT&amp;T\n\nMarkdown会将其转化为：\nAT&amp;amp;T\n\n同样，由于Markdown支持 嵌入式HTML，因此如果您使用尖括号作为HTML标签的分隔符，Markdown会像这样对待它们。 但是如果你写：\n4 &lt; 5\n\nMarkdown会将其转化为：\n4 &amp;lt; 5\n\n但是，在Markdown代码跨度和块内部，尖括号和＆符号 总是 自动编码。 这使得使用Markdown很容易编写HTML代码。 （与原始HTML相反，这是一种用于编写HTML语法的可怕格式，因为您的示例代码中的每个 &lt; 和 &amp; 都需要被转义。）\n\n块元素\n\n\n段落和换行符\n\n段落只是一个或多个连续的文本行，由一个或多个空行分隔。 （空白行是任何看起来像空行的行 - 只包含空格或制表符的行被认为是空白。）普通段落不应该用空格或制表符缩进。\n“一条或多条连续文本”规则的含义是Markdown支持“硬包装”文本段落。 这与大多数其他文本到HTML格式化程序（包括Movable Type的“Convert Line Breaks”选项）有很大不同，它将段落中的每个换行符转换为一个 &lt;br /&gt; 标记。\n当你 想要 使用Markdown插入一个 &lt;br /&gt; 中断标签时，可以用两个或多个空格结束一行，然后输入返回。\n是的，这需要花费更多的努力来创建一个 &lt;br /&gt; ，但是一个简单的“每行换行符都是 &lt;br /&gt; ”规则对于Markdown来说不起作用。 Markdown的电子邮件风格的 块引用 和多段 列表项 最适合 - 并且看起来更好 - 当您用严格的休息格式化它们时。\n头\n\nMarkdown支持两种标题， [Setext] [1] 和 [atx] [2]。\nSetext风格的标题是使用等号（用于第一级标题）和破折号（用于第二级标题）的“下划线”。 例如：\n这是H1\n=============\n\n这是H2\n-------------\n\n任何数字的下划线 = 或 - 将起作用。\nAtx风格的标题在行首使用1-6个哈希字符，对应于标题级别1-6。 例如：\n# 这是H1\n\n## 这是H2\n\n###### 这是一个H6\n\n或者，你可以“关闭”atx风格的头文件。 这纯粹是美容 - 如果你认为它看起来更好，你可以使用它。 结束哈希值甚至不需要匹配用于打开头的哈希数。 （开放散列的数量\n确定标题级别。）：\n\n# 这是H1 #\n\n## 这是H2 ##\n\n### 这是一个H3 ######\n\n引用文字\n\nMarkdown使用电子邮件风格的 &gt; 字符进行区块引用。如果您熟悉在电子邮件中引用文本段落，那么您知道如何在Markdown中创建块引用。它看起来最好，如果你硬包装的文本，并把 &gt; 每一行前：\n&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n&gt;\n&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n&gt; id sem consectetuer libero luctus adipiscing.\n\nMarkdown可以让你懒惰，只把 &gt; 放在硬包装段落的第一行之前：\n&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\nconsectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\nVestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\nid sem consectetuer libero luctus adipiscing.\n\n块引号可以通过添加额外的 &gt;来嵌套（即块引用）：\n&gt; This is the first level of quoting.\n&gt;\n&gt; &gt; This is nested blockquote.\n&gt;\n&gt; Back to the first level.\n\nBlockquotes可以包含其他Markdown元素，包括标题，列表和代码块：\n&gt; ## This is a header.\n&gt;\n&gt; 1.   This is the first list item.\n&gt; 2.   This is the second list item.\n&gt;\n&gt; Here&#39;s some example code:\n&gt;\n&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);\n\n任何体面的文本编辑器都应该使电子邮件式引用变得容易。 例如，使用BBEdit，您可以进行选择并从文本菜单中选择“提高报价级别”。\n清单\n\nMarkdown支持有序（编号）和无序（项目符号）列表。\n无序列表使用星号，加号和连字符 - 可互换– 作为列表标记：\n*   Red\n*   Green\n*   Blue\n\n相当于：\n+   Red\n+   Green\n+   Blue\n\n和：\n-   Red\n-   Green\n-   Blue\n\n有序列表使用数字后跟句点：\n1.  Bird\n2.  McHale\n3.  Parish\n\n请注意，用于标记列表的实际数字对Markdown产生的HTML输出没有影响。 从上面的列表产生的HTML Markdown是：\n&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt;\n\n如果你改为在Markdown中写下这样的列表：\n1.  Bird\n1.  McHale\n1.  Parish\n\n甚至：\n3. Bird\n1. McHale\n8. Parish\n\n你会得到完全相同的HTML输出。 关键是，如果你愿意，你可以在你订购的Markdown列表中使用序号，以便你的源代码中的数字与发布的HTML中的数字相匹配。 但是如果你想懒惰，你不需要。\n但是，如果确实使用懒惰列表编号，则仍应以数字1开始列表。在将来的某个时间，Markdown可能支持以任意数字开始的有序列表。\n列表标记通常从左边界开始，但可以缩进最多三个空格。 列表标记后面必须跟一个或多个空格或制表符。\n为了使列表看起来不错，您可以使用悬挂缩进来包装项目：\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\n    viverra nec, fringilla in, laoreet vitae, risus.\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\n    Suspendisse id sem consectetuer libero luctus adipiscing.\n\n但是如果你想懒惰，你不必：\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\nAliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\nviverra nec, fringilla in, laoreet vitae, risus.\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\nSuspendisse id sem consectetuer libero luctus adipiscing.\n\n如果列表项以空行分隔，Markdown会将这些项目包装在HTML输出中的 &lt;p&gt; 标签中。 例如，这个输入：\n*   Bird\n*   Magic\n\n将变成：\n&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt;\n\n但是这个：\n*   Bird\n\n*   Magic\n\n将变成：\n&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;\n\n列表项目可能由多个段落组成。 列表项中的每个后续段落都必须缩进4个空格或一个制表符：\n1.  This is a list item with two paragraphs. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n    mi posuere lectus.\n\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n    sit amet velit.\n\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n它看起来不错，如果你缩进后续段落的每一行，但在这里再一次，Markdown会让你变得懒惰：\n*   This is a list item with two paragraphs.\n\n    This is the second paragraph in the list item. You&#39;re\nonly required to indent the first line. Lorem ipsum dolor\nsit amet, consectetuer adipiscing elit.\n\n*   Another item in the same list.\n\n要在列表项中放置一个块引用，需要缩进块引用的&gt;分隔符：\n*   A list item with a blockquote:\n\n    &gt; This is a blockquote\n    &gt; inside a list item.\n\n要将代码块放在列表项中，代码块需要缩进 两次 – 8个空格或两个制表符：\n*   A list item with a code block:\n\n        &lt;code goes here&gt;\n\n值得注意的是，有可能通过写这样的东西来偶然触发一个有序列表：\n1986. What a great season.\n\n换句话说，在一行的开始处的 数字周期空间 序列。 为了避免这种情况，您可以使用反斜杠来避开这段时间：\n1986\\. What a great season.\n\n代码块\n\n预格式化的代码块用于编写有关编程或标记源代码。 而不是形成正常的段落，字面上解释代码块的行。 Markdown在 &lt;pre&gt; 和 &lt;code&gt; 标签中包装了一个代码块。\n要在Markdown中生成代码块，只需将块的每一行缩进至少4个空格或1个标签。 例如，给出这个输入：\nThis is a normal paragraph:\n\n    This is a code block.\n\nMarkdown将产生：\n&lt;p&gt;This is a normal paragraph:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;This is a code block.&lt;/code&gt;&lt;/pre&gt;\n\n从代码块的每一行删除一级缩进 - 4个空格或1个制表符。 例如，这个：\nHere is an example of AppleScript:\n\n    tell application &quot;Foo&quot;\n        beep\n    end tell\n\n将变成：\n&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;    beepend tell&lt;/code&gt;&lt;/pre&gt;\n\n一个代码块会一直持续到它没有缩进的一行（或文章结尾）。\n在代码块中，＆符号（&amp;）和尖括号（&lt;和&gt;）会自动转换为HTML实体。 这使得使用Markdown包含示例HTML源代码变得非常简单 - 只需粘贴并缩进即可，Markdown将处理编码＆符号和尖括号的麻烦。 例如，这个：\n&lt;div class=&quot;footer&quot;&gt;    &amp;copy; 2004 Foo Corporation&lt;/div&gt;\n\n将变成：\n&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;    &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;\n\n定期Markdown语法不在代码块内处理。 例如，星号只是代码块内的字面星号。 这意味着使用Markdown编写Markdown自己的语法也很容易。\n横向规则\n\n您可以通过在一行上单独放置三个或更多连字符，星号或下划线来生成水平规则标签（&lt;hr /&gt;）。 如果你愿意，你可以在连字符或星号之间使用空格。 以下每一行都将生成一条水平线：\n* * *\n\n***\n\n*****\n\n- - -\n\n---------------------------------------\n\n\n跨度元素\n\n链接\n\nMarkdown支持两种链接： 内联 和 引用。\n在这两种样式中，链接文本都由[方括号]分隔。\n要创建内联链接，请在链接文本的方括号之后立即使用一组常规括号。 在圆括号内，将链接指向的URL以及链接的 可选 标题放在引号中。 例如：\nThis is [an example](http://example.com/ &quot;Title&quot;) inline link.\n\n[This link](http://example.net/) has no title attribute.\n\n会产生：\n&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt;\n\n如果您指的是同一台服务器上的本地资源，则可以使用相对路径：\nSee my [About](/about/) page for details.   \n\n引用样式链接使用第二组方括号，在其中放置您选择的标签以标识链接：\nThis is [an example][id] reference-style link.\n\n您可以选择使用空格来分隔括号组：\nThis is [an example] [id] reference-style link.\n\n然后，在文档的任何地方，您都可以像这样定义您的链接标签，并单独定义一行：\n[id]: http://example.com/  &quot;Optional Title Here&quot;\n\n那是：\n\nSquare brackets containing the link identifier (optionallyindented from the left margin using up to three spaces);\nfollowed by a colon;\nfollowed by one or more spaces (or tabs);\nfollowed by the URL for the link;\noptionally followed by a title attribute for the link, enclosedin double or single quotes, or enclosed in parentheses.\n\n以下三个链接定义是等价的：\n[foo]: http://example.com/  &quot;Optional Title Here&quot;\n[foo]: http://example.com/  &#39;Optional Title Here&#39;\n[foo]: http://example.com/  (Optional Title Here)\n\n注意： Markdown.pl 1.0.1中有一个已知的错误，它可以防止使用单引号来分隔链接标题。\n链接URL可以（可选）用尖括号包围：\n[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;\n\n您可以将title属性放在下一行，并使用额外的空格或制表符来填充，这对于更长的URL来说往往更好看：\n[id]: http://example.com/longish/path/to/resource/here\n    &quot;Optional Title Here&quot;\n\n链接定义仅用于在Markdown处理期间创建链接，并在HTML输出中从文档中剥离链接定义。\n链接定义名称可能由字母，数字，空格和标点符号组成 - 但它们不区分大小写。 例如。 这两个链接：\n[link text][a]\n[link text][A]\n\n是等同的。\n隐含链接名称 快捷方式允许您省略链接的名称，在这种情况下链接文本本身被用作名称。 只需使用一组空白的方括号 - 例如，将单词“Google”链接到google.com网站，您可以简单地编写：\n[Google][]\n\n然后定义链接：\n[Google]: http://google.com/\n\n由于链接名称可能包含空格，因此此快捷键甚至适用于链接文本中的多个单词：\nVisit [Daring Fireball][] for more information.\n\n然后定义链接：\n[Daring Fireball]: http://daringfireball.net/\n\n链接定义可以放置在Markdown文档的任何位置。 我倾向于在他们使用的每个段落之后立即放置它们，但是如果你愿意，可以将它们全部放在文档的末尾，有点像脚注。\n以下是实际参考链接的示例：\nI get 10 times more traffic from [Google] [1] than from\n[Yahoo] [2] or [MSN] [3].\n\n  [1]: http://google.com/        &quot;Google&quot;\n  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;\n  [3]: http://search.msn.com/    &quot;MSN Search&quot;\n\n使用隐式链接名称快捷方式，可以改为编写：\nI get 10 times more traffic from [Google][] than from\n[Yahoo][] or [MSN][].\n\n  [google]: http://google.com/        &quot;Google&quot;\n  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;\n  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;\n\n以上两个示例都会生成以下HTML输出：\n&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;\n\n为了比较，这里是使用Markdown的内联链接样式编写的同一段：\nI get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)\nthan from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or\n[MSN](http://search.msn.com/ &quot;MSN Search&quot;).\n\n引用式链接的关键不在于它们更容易编写。 关键是，使用参考样式的链接，您的文档来源更具可读性。 比较上面的例子：使用参考样式的链接，该段本身只有81个字符长; 带有内联式链接，它有176个字符; 并作为原始HTML，它是234个字符。 在原始HTML中，标记多于文本。\n使用Markdown的参考风格链接，源文档与浏览器中呈现的最终输出非常相似。 通过允许您将标记相关的元数据移出段落，您可以添加链接而不中断散文的叙述流程。\n重点\n\nMarkdown将星号（*）和下划线（_）作为重点指标。 用一个 * 或 _ 包裹的文本将用一个HTML &lt;em&gt; 标签包装; 用两个 * 或 _ 将被包含一个HTML &lt;strong&gt; 标签。 例如，这个输入：\n*single asterisks*\n\n_single underscores_\n\n**double asterisks**\n\n__double underscores__\n\n会产生：\n&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt;\n\n你可以使用你喜欢的任何风格; 唯一的限制是必须使用相同的字符来打开和关闭重点范围。\n强调可以用在词的中间：\nun*frigging*believable\n\n但是如果用空格包围 * 或 _ ，它将被视为文字星号或下划线。\n要在原本用作强调分隔符的位置生成文字星号或下划线，可以使用反斜杠进行转义：\n\\*this text is surrounded by literal asterisks\\*\n\n代码\n\n为了表示一段代码，用反引号引起来（`）。 与预格式化代码块不同，代码范围指示正常段落内的代码。 例如：\nUse the `printf()` function.\n\n会产生：\n&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;\n\n要在代码范围内包含文字反引号字符，可以使用多个反引号作为开始和结束分隔符：\n``There is a literal backtick (`) here.``\n\n这将产生这样的结果：\n&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;\n\n代码跨度周围的反引号分隔符可能包含空格 - 开放后一个，关闭之前一个。 这使您可以在代码范围的开头或结尾放置文字反引号字符：\nA single backtick in a code span: `` ` ``\n\nA backtick-delimited string in a code span: `` `foo` ``\n\n会产生：\n&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;\n\n通过代码跨度，＆符号和尖括号会自动编码为HTML实体，这样可以轻松包含示例HTML标记。 Markdown会变成这样：\nPlease don&#39;t use any `&lt;blink&gt;` tags.\n\n成：\n&lt;p&gt;Please don&#x27;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;\n\n你可以写这个：\n`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.\n\n产生：\n&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encodedequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;\n\n\n\n图片\n\n无可否认，设计用于将图像置于纯文本文档格式的“自然”语法相当困难。\nMarkdown使用图像语法，旨在类似链接的语法，允许两种样式：内联 和 引用。\n内联图像语法如下所示：\n![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg &quot;Optional title&quot;)\n\n那是：\n\n感叹号： !;\n然后是一组方括号，其中包含图像的 alt 属性文本;\n接着是一组括号，其中包含图像的URL或路径，以及用双引号或单引号括起来的可选 title 属性。\n\n参考风格的图像语法如下所示：\n![Alt text][id]\n\n其中“id”是定义的图像引用的名称。 图像引用是使用与链接引用相同的语法定义的：\n[id]: url/to/image  &quot;Optional title attribute&quot;\n\n在撰写本文时，Markdown没有指定图像尺寸的语法; 如果这对你来说很重要，你可以简单地使用普通的HTML标签 &lt;img&gt; 标签。\n\n杂项\n\n自动链接\n\nMarkdown支持创建URL和电子邮件地址的“自动”链接的快捷方式：只需使用尖括号围绕URL或电子邮件地址即可。 这意味着如果你想显示一个URL或电子邮件地址的实际文本，并且它也是一个可点击的链接，你可以这样做：\n&lt;http://example.com/&gt;\n\nMarkdown将把它变成：\n&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;\n\n电子邮件地址的自动链接的工作方式与此类似，但Markdown还会执行一些随机化的十进制和十六进制实体编码，以帮助屏蔽地址收集spambots的地址。 例如，Markdown会变成这样：\n&lt;address@example.com&gt;\n\n变成这样的东西：\n&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;\n\n这将在浏览器中呈现为“address@example.com”的可点击链接。\n（这种实体编码的技巧确实会欺骗很多（如果不是绝大多数）地址获取机器人，但它绝对不会欺骗所有这些机器人。总比没有好，但以这种方式发布的地址可能最终会开始接收 垃圾邮件。）\n反斜线转义\n\nMarkdown允许您使用反斜线转义来生成文字字符，否则这些字符在Markdown的格式化语法中会有特殊含义。 例如，如果您想用文字星号（而不是HTML &lt;em&gt; 标签）标记单词，则可以在星号之前使用反斜杠，如下所示：\n\\*literal asterisks\\*\n\nMarkdown为以下字符提供反斜杠转义符：\n\\   backslash\n`   backtick\n*   asterisk\n_   underscore\n&#123;&#125;  curly braces\n[]  square brackets\n()  parentheses\n#   hash mark\n+\tplus sign\n-\tminus sign (hyphen)\n.   dot\n!   exclamation mark\n\n","categories":["api","markdown"],"tags":["api","markdown"]},{"title":"Maven仓库修改阿里中央仓库","url":"/2018/12/25/Maven%E4%BB%93%E5%BA%93%E4%BF%AE%E6%94%B9%E9%98%BF%E9%87%8C%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/","content":"Maven仓库修改阿里中央仓库修改 conf 下的 settings.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements.  See the NOTICE filedistributed with this work for additional informationregarding copyright ownership.  The ASF licenses this fileto you under the Apache License, Version 2.0 (the&quot;License&quot;); you may not use this file except in compliancewith the License.  You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on an&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied.  See the License for thespecific language governing permissions and limitationsunder the License.--&gt;&lt;!-- | This is the configuration file for Maven. It can be specified at two levels: | |  1. User Level. This settings.xml file provides configuration for a single user, |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml. | |                 NOTE: This location can be overridden with the CLI option: | |                 -s /path/to/user/settings.xml | |  2. Global Level. This settings.xml file provides configuration for all Maven |                 users on a machine (assuming they&#x27;re all using the same Maven |                 installation). It&#x27;s normally provided in |                 $&#123;maven.conf&#125;/settings.xml. | |                 NOTE: This location can be overridden with the CLI option: | |                 -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;  &lt;!-- localRepository   | The path to the local repository maven will use to store artifacts.   |   | Default: $&#123;user.home&#125;/.m2/repository  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;  --&gt;  &lt;!-- interactiveMode   | This will determine whether maven prompts you when it needs input. If set to false,   | maven will use a sensible default value, perhaps based on some other setting, for   | the parameter in question.   |   | Default: true  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;  --&gt;  &lt;!-- offline   | Determines whether maven should attempt to connect to the network when executing a build.   | This will have an effect on artifact downloads, artifact deployment, and others.   |   | Default: false  &lt;offline&gt;false&lt;/offline&gt;  --&gt;  &lt;!-- pluginGroups   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.   |--&gt;  &lt;pluginGroups&gt;    &lt;!-- pluginGroup     | Specifies a further group identifier to use for plugin lookup.    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;    --&gt;  &lt;/pluginGroups&gt;  &lt;!-- proxies   | This is a list of proxies which can be used on this machine to connect to the network.   | Unless otherwise specified (by system property or command-line switch), the first proxy   | specification in this list marked as active will be used.   |--&gt;  &lt;proxies&gt;    &lt;!-- proxy     | Specification for one proxy, to be used in connecting to the network.     |    &lt;proxy&gt;      &lt;id&gt;optional&lt;/id&gt;      &lt;active&gt;true&lt;/active&gt;      &lt;protocol&gt;http&lt;/protocol&gt;      &lt;username&gt;proxyuser&lt;/username&gt;      &lt;password&gt;proxypass&lt;/password&gt;      &lt;host&gt;proxy.host.net&lt;/host&gt;      &lt;port&gt;80&lt;/port&gt;      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;    &lt;/proxy&gt;    --&gt;  &lt;/proxies&gt;  &lt;!-- servers   | This is a list of authentication profiles, keyed by the server-id used within the system.   | Authentication profiles can be used whenever maven must make a connection to a remote server.   |--&gt;  &lt;servers&gt;    &lt;!-- server     | Specifies the authentication information to use when connecting to a particular server, identified by     | a unique name within the system (referred to by the &#x27;id&#x27; attribute below).     |     | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are     |       used together.     |    &lt;server&gt;      &lt;id&gt;deploymentRepo&lt;/id&gt;      &lt;username&gt;repouser&lt;/username&gt;      &lt;password&gt;repopwd&lt;/password&gt;    &lt;/server&gt;    --&gt;    &lt;!-- Another sample, using keys to authenticate.    &lt;server&gt;      &lt;id&gt;siteServer&lt;/id&gt;      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;    &lt;/server&gt;    --&gt;  &lt;/servers&gt;  &lt;!-- mirrors   | This is a list of mirrors to be used in downloading artifacts from remote repositories.   |   | It works like this: a POM may declare a repository to use in resolving certain artifacts.   | However, this repository may have problems with heavy traffic at times, so people have mirrored   | it to several places.   |   | That repository definition will have a unique id, so we can create a mirror reference for that   | repository, to be used as an alternate download site. The mirror site will be the preferred   | server for that repository.   |--&gt;  &lt;mirrors&gt;    &lt;!-- mirror     | Specifies a repository mirror site to use instead of a given repository. The repository that     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.     |    &lt;mirror&gt;      &lt;id&gt;mirrorId&lt;/id&gt;      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;    &lt;/mirror&gt;     --&gt;\t&lt;mirror&gt;\t  &lt;id&gt;nexus-aliyun&lt;/id&gt;\t  &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t  &lt;name&gt;Nexus aliyun&lt;/name&gt;\t  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;\t&lt;/mirror&gt;  &lt;/mirrors&gt;  &lt;!-- profiles   | This is a list of profiles which can be activated in a variety of ways, and which can modify   | the build process. Profiles provided in the settings.xml are intended to provide local machine-   | specific paths and repository locations which allow the build to work in the local environment.   |   | For example, if you have an integration testing plugin - like cactus - that needs to know where   | your Tomcat instance is installed, you can provide a variable here such that the variable is   | dereferenced during the build process to configure the cactus plugin.   |   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles   | section of this document (settings.xml) - will be discussed later. Another way essentially   | relies on the detection of a system property, either matching a particular value for the property,   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a   | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;.   | Finally, the list of active profiles can be specified directly from the command line.   |   | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact   |       repositories, plugin repositories, and free-form properties to be used as configuration   |       variables for plugins in the POM.   |   |--&gt;  &lt;profiles&gt;    &lt;!-- profile     | Specifies a set of introductions to the build process, to be activated using one or more of the     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;     | or the command line, profiles have to have an ID that is unique.     |     | An encouraged best practice for profile identification is to use a consistent naming convention     | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc.     | This will make it more intuitive to understand what the set of introduced profiles is attempting     | to accomplish, particularly when you only have a list of profile id&#x27;s for debug.     |     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.    &lt;profile&gt;      &lt;id&gt;jdk-1.4&lt;/id&gt;      &lt;activation&gt;        &lt;jdk&gt;1.4&lt;/jdk&gt;      &lt;/activation&gt;      &lt;repositories&gt;        &lt;repository&gt;          &lt;id&gt;jdk14&lt;/id&gt;          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;          &lt;layout&gt;default&lt;/layout&gt;          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;        &lt;/repository&gt;      &lt;/repositories&gt;    &lt;/profile&gt;    --&gt;    &lt;!--     | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;,     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration     | might hypothetically look like:     |     | ...     | &lt;plugin&gt;     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;     |     |   &lt;configuration&gt;     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;     |   &lt;/configuration&gt;     | &lt;/plugin&gt;     | ...     |     | NOTE: If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.     |    &lt;profile&gt;      &lt;id&gt;env-dev&lt;/id&gt;      &lt;activation&gt;        &lt;property&gt;          &lt;name&gt;target-env&lt;/name&gt;          &lt;value&gt;dev&lt;/value&gt;        &lt;/property&gt;      &lt;/activation&gt;      &lt;properties&gt;        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;      &lt;/properties&gt;    &lt;/profile&gt;    --&gt;  &lt;/profiles&gt;  &lt;!-- activeProfiles   | List of profiles that are active for all builds.   |  &lt;activeProfiles&gt;    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;  &lt;/activeProfiles&gt;  --&gt;&lt;/settings&gt;\n","categories":["maven"],"tags":["maven","阿里"]},{"title":"Maven管理的pom.xml文件配置（自动下载所依赖的jar包）","url":"/2018/02/25/Maven%E7%AE%A1%E7%90%86%E7%9A%84pom-xml%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%EF%BC%88%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E6%89%80%E4%BE%9D%E8%B5%96%E7%9A%84jar%E5%8C%85%EF%BC%89/","content":"Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。Maven这个单词来自于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项目中用来简化构建过程。当时有一些项目（有各自Ant build文件），仅有细微的差别，而JAR文件都由CVS来维护。于是希望有一种标准化的方式构建项目，一个清晰的方式定义项目的组成，一个容易的方式发布项目的信息，以及一种简单的方式在多个项目中共享JARs。\n\n\nproperties 全局变量&lt;properties&gt;    &lt;!-- 通过 $&#123;spring.version&#125; 获取 --&gt;    &lt;spring.version&gt;5.3.18&lt;/spring.version&gt;&lt;/properties&gt;\n\npom.xml&lt;!-- spring-webmvc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 实现多内部资源视图解析器 生成xml工具jar包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 事务 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 初始化会话工厂 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring AOP就是用aspectj来实现的，是依赖关系 --&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.9.7&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- mybatis框架 --&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis与spring对接的jar包 --&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis与springboot对接的jar包 --&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MySQL连接器 --&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.28&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 阿里druid数据源 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- JSP 标准标签库 (JSTL) --&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- json转换工具包 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;2.0.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 获取页面session对象request对象response对象 HttpServletXXX jar包 --&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- spring集成JSR-303验证框架-Hibernate-validator实现 验证框架的jar包 start --&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;6.2.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;    &lt;version&gt;6.2.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.validation/validation-api --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.validation&lt;/groupId&gt;    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;    &lt;version&gt;2.0.1.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring集成JSR-303验证框架-Hibernate-validator实现 验证框架的jar包 end --&gt;&lt;!-- jsonwebtoken(JWT)通过数字签名进行验证和信任 --&gt;&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;    &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 整合 Shiro --&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;    &lt;version&gt;1.7.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- shiro+redis缓存插件 --&gt;&lt;!-- https://mvnrepository.com/artifact/org.crazycake/shiro-redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.crazycake&lt;/groupId&gt;    &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- HttpUtils需要导入的包 start --&gt;&lt;!--json转换工具包--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.15&lt;/version&gt;&lt;/dependency&gt;&lt;!--HttpClient4.x工具--&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;    &lt;version&gt;4.5.13&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpcore&lt;/artifactId&gt;    &lt;version&gt;4.4.13&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-lang/commons-lang --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-lang&lt;/groupId&gt;    &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;    &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-util --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;    &lt;artifactId&gt;jetty-util&lt;/artifactId&gt;    &lt;version&gt;9.4.43.v20210629&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.13.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- HttpUtils需要导入的包 end --&gt;&lt;!-- 快速开发工具包 --&gt;&lt;!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all --&gt;&lt;dependency&gt;    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;    &lt;version&gt;5.7.22&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 模拟Java数据工具框架 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.jsonzou/jmockdata --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.jsonzou&lt;/groupId&gt;    &lt;artifactId&gt;jmockdata&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 序列化/反序列化 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson/jackson-bom --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson&lt;/groupId&gt;    &lt;artifactId&gt;jackson-bom&lt;/artifactId&gt;    &lt;version&gt;2.12.4&lt;/version&gt;    &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt;\n","categories":["maven","pom.xml"],"tags":["maven","pom.xml"]},{"title":"MyBatis 映射配置解析以及动态SQL配置案例","url":"/2018/04/05/MyBatis-%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81SQL%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B/","content":"什么是 MyBatis ？MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。\nMyBatis的 Git 代码库\n\ncorp数据库全部表结构与数据DROP DATABASE IF EXISTS `corp`;CREATE DATABASE `corp`;USE `corp`;-- 部门 CREATE TABLE `depa` (  `id` INT AUTO_INCREMENT PRIMARY KEY,  `depa_name` NVARCHAR (50) NOT NULL) ;-- 职员 CREATE TABLE `emp` (  `id` INT AUTO_INCREMENT PRIMARY KEY,  `emp_name` NVARCHAR (50) NOT NULL,  `depa_id` INT NOT NULL) ;-- 职位 CREATE TABLE `post` (  `id` INT AUTO_INCREMENT PRIMARY KEY,  `post_name` NVARCHAR (50) NOT NULL) ;-- 职员职位 CREATE TABLE `emp_post` (  `emp_id` INT NOT NULL,  `post_id` INT NOT NULL) ;INSERT INTO `depa`(`depa_name`) VALUES(&#x27;销售部&#x27;);INSERT INTO `depa`(`depa_name`) VALUES(&#x27;美工部&#x27;);INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES(&#x27;张三&#x27;,2);INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES(&#x27;李四&#x27;,1);INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES(&#x27;王五&#x27;,1);INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES(&#x27;赵六&#x27;,1);INSERT INTO `post`(`post_name`) VALUES(&#x27;职员&#x27;);INSERT INTO `post`(`post_name`) VALUES(&#x27;主管&#x27;);INSERT INTO `post`(`post_name`) VALUES(&#x27;经理&#x27;);INSERT INTO `post`(`post_name`) VALUES(&#x27;部门经理&#x27;);INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(1,1);INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(2,2);INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(3,3);INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(4,4);INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(1,4);SELECT * FROM `depa`;SELECT * FROM `emp`;SELECT * FROM `post`;SELECT * FROM `emp_post`;DROP TABLE `depa`;DROP TABLE `emp`;DROP TABLE `post`;DROP TABLE `emp_post`;\n\npom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com&lt;/groupId&gt;    &lt;artifactId&gt;Corp&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.38&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\nMybatisUtil Mybatis工具类package com.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtil &#123;    private static SqlSessionFactory sessionFactory;    static &#123;        try &#123;            InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);            sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static SqlSession getSession() &#123;        return sessionFactory.openSession(false);//true为自动提交事务    &#125;&#125;\n\nDepa 部门实体类package com.entity;import java.util.ArrayList;import java.util.List;public class Depa &#123;    private Integer id;    private String depa_name;    private List&lt;Emp&gt; emps = new ArrayList&lt;Emp&gt;();    @Override    public String toString() &#123;        return &quot;Depa&#123;&quot; +                &quot;id=&quot; + id +                &quot;, depa_name=&#x27;&quot; + depa_name + &#x27;\\&#x27;&#x27; +                &quot;, emps=&quot; + emps +                &#x27;&#125;&#x27;;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getDepa_name() &#123;        return depa_name;    &#125;    public void setDepa_name(String depa_name) &#123;        this.depa_name = depa_name;    &#125;    public List&lt;Emp&gt; getEmps() &#123;        return emps;    &#125;    public void setEmps(List&lt;Emp&gt; emps) &#123;        this.emps = emps;    &#125;&#125;\n\n对应 Depa 部门实体类 的实现接口 DepaDao 接口类package com.dao;import com.entity.Depa;import java.util.List;public interface DepaDao &#123;    List&lt;Depa&gt; getAll();&#125;\n\n对应 Depa 部门实体类 的映射配置文件 DepaMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace mapper接口 必填 随便填值 防止SQL语句ID重名--&gt;&lt;mapper namespace=&quot;com.dao.DepaDao&quot;&gt;    &lt;!--&lt;insert id=&quot;&quot;&gt;&lt;/insert&gt;--&gt;    &lt;!--&lt;delete id=&quot;&quot;&gt;&lt;/delete&gt;--&gt;    &lt;!--&lt;update id=&quot;&quot;&gt;&lt;/update&gt;--&gt;    &lt;!--resultType 返回类型 实体类全限定类名--&gt;    &lt;select id=&quot;getAll&quot; resultMap=&quot;DepaMapper&quot;&gt;        SELECT *,e.`id` eId,d.`id` dId FROM depa d        INNER JOIN emp e ON d.`id`=e.`depa_id`    &lt;/select&gt;    &lt;!--type 为resultMap返回类型--&gt;    &lt;resultMap id=&quot;DepaMapper&quot; type=&quot;Depa&quot;&gt;        &lt;!--column 为数据库查到后取的别名 property 为type对象对应属性名--&gt;        &lt;result column=&quot;dId&quot; property=&quot;id&quot;/&gt;        &lt;!--因为数据库的字段与实体类属性名一致--&gt;        &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;--&gt;        &lt;!--达到 自动映射行为 : 局部的PARTIAL 重复的 &lt;result/&gt; 可以省略--&gt;        &lt;!--&lt;result column=&quot;&quot; property=&quot;&quot;/&gt;--&gt;        &lt;!--收集 一对多--&gt;        &lt;!--property 为type对象对应属性名 javaType 为所属类型--&gt;        &lt;collection property=&quot;emps&quot; javaType=&quot;Emp&quot;&gt;            &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt;            &lt;result column=&quot;&quot; property=&quot;&quot;/&gt;            &lt;!--因为数据库的字段与实体类属性名一致--&gt;            &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;--&gt;            &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt;            &lt;result column=&quot;eId&quot; property=&quot;id&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;\n\nEmp 职员实体类package com.entity;import java.util.ArrayList;import java.util.List;public class Emp &#123;    private Integer id;    private String emp_name;    private Depa depa_id;    private List&lt;Post&gt; posts = new ArrayList&lt;Post&gt;();    @Override    public String toString() &#123;        return &quot;Emp&#123;&quot; +                &quot;id=&quot; + id +                &quot;, emp_name=&#x27;&quot; + emp_name + &#x27;\\&#x27;&#x27; +                &quot;, depa_id=&quot; + depa_id +                &quot;, posts=&quot; + posts +                &#x27;&#125;&#x27;;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getEmp_name() &#123;        return emp_name;    &#125;    public void setEmp_name(String emp_name) &#123;        this.emp_name = emp_name;    &#125;    public Depa getDepa_id() &#123;        return depa_id;    &#125;    public void setDepa_id(Depa depa_id) &#123;        this.depa_id = depa_id;    &#125;    public List&lt;Post&gt; getPosts() &#123;        return posts;    &#125;    public void setPosts(List&lt;Post&gt; posts) &#123;        this.posts = posts;    &#125;&#125;\n\n对应 Emp 职员实体类 的实现接口 EmpDao 接口类package com.dao;import com.entity.Emp;import java.util.List;import java.util.Map;public interface EmpDao &#123;    List&lt;Emp&gt; getAll();    Integer saveOrUpdate(Emp emp);    Integer del(Integer[] idArray);    List&lt;Emp&gt; getByNames(List names);    List&lt;Emp&gt; getByIdAndNames(Map map);&#125;\n\n对应 Emp 职员实体类 的映射配置文件 EmpMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace mapper接口 必填 随便填值 防止SQL语句ID重名--&gt;&lt;mapper namespace=&quot;com.dao.EmpDao&quot;&gt;    &lt;!--        &lt;where&gt; 自动删除第一个 and 或者 or        item 表示集合中每一个元素进行迭代时的别名        open 表示该语句以什么开始        separator 表示在每次进行迭代之间以什么符号作为分隔符        close表示以什么结束        如果传入的是单参数且参数类型是一个List的时候，collection属性值为list        如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array        如果传入的参数是多个的时候，就需要把它们封装成一个Map map的key就是参数名--&gt;    &lt;delete id=&quot;del&quot;&gt;        DELETE FROM emp        &lt;where&gt;            &lt;foreach collection=&quot;array&quot; item=&quot;eId&quot;&gt;                OR id = #&#123;eId&#125;            &lt;/foreach&gt;        &lt;/where&gt;    &lt;/delete&gt;    &lt;!--&lt;set&gt; 自动去除最后的逗号 , --&gt;    &lt;update id=&quot;saveOrUpdate&quot;&gt;        &lt;if test=&quot;null != id&quot;&gt;            UPDATE emp            &lt;set&gt;                &lt;if test=&quot;null != emp_name&quot;&gt;                    emp_name = #&#123;emp_name&#125;,                &lt;/if&gt;                &lt;if test=&quot;null != depa_id and null != depa_id.id&quot;&gt;                    depa_id = #&#123;depa_id.id&#125;,                &lt;/if&gt;            &lt;/set&gt;            where id = #&#123;id&#125;        &lt;/if&gt;        &lt;if test=&quot;null == id&quot;&gt;            INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES(#&#123;emp_name&#125;,#&#123;depa_id.id&#125;)        &lt;/if&gt;    &lt;/update&gt;    &lt;!--resultType 返回类型 实体类全限定类名--&gt;    &lt;select id=&quot;getAll&quot; resultMap=&quot;EmpMapper&quot;&gt;        SELECT * FROM emp e        INNER JOIN depa d ON d.`id`=e.`depa_id`        INNER JOIN emp_post ep ON ep.`emp_id`=e.`id`        INNER JOIN post p ON p.`id`=ep.`post_id`    &lt;/select&gt;    &lt;!--        prefix 前缀添加什么        prefixOverrides 前缀移除什么 || 为或者        suffix 后缀添加什么        suffixOverrides 后缀移除什么 || 为或者        &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;OR || AND&quot;&gt; 等价 &lt;where&gt;--&gt;    &lt;select id=&quot;getByNames&quot; resultMap=&quot;EmpMapper&quot;&gt;        SELECT * FROM emp e        INNER JOIN depa d ON d.`id`=e.`depa_id`        INNER JOIN emp_post ep ON ep.`emp_id`=e.`id`        INNER JOIN post p ON p.`id`=ep.`post_id`        &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;OR || AND&quot;&gt;            &lt;foreach collection=&quot;list&quot; item=&quot;name&quot;&gt;                OR e.`emp_name` LIKE CONCAT(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)            &lt;/foreach&gt;        &lt;/trim&gt;    &lt;/select&gt;    &lt;!--    prefix 前缀添加什么    prefixOverrides 前缀移除什么 || 为或者    suffix 后缀添加什么    suffixOverrides 后缀移除什么 || 为或者    &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;OR || AND&quot;&gt; 等价 &lt;where&gt;--&gt;    &lt;select id=&quot;getByIdAndNames&quot; resultMap=&quot;EmpMapper&quot;&gt;        SELECT * FROM emp e        INNER JOIN depa d ON d.`id`=e.`depa_id`        INNER JOIN emp_post ep ON ep.`emp_id`=e.`id`        INNER JOIN post p ON p.`id`=ep.`post_id`        &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;OR|AND&quot;&gt;            AND e.`id` = #&#123;mapIdName&#125; AND        &lt;/trim&gt;        &lt;trim prefixOverrides=&quot;OR|AND&quot;&gt;            e.`emp_name` IN            &lt;foreach collection=&quot;mapNameList&quot; item=&quot;name&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                #&#123;name&#125;            &lt;/foreach&gt;        &lt;/trim&gt;    &lt;/select&gt;    &lt;!--type 为resultMap返回类型--&gt;    &lt;resultMap id=&quot;EmpMapper&quot; type=&quot;Emp&quot;&gt;        &lt;!--column 为数据库查到后取的别名 property 为type对象对应属性名--&gt;        &lt;result column=&quot;emp_id&quot; property=&quot;id&quot;/&gt;        &lt;!--因为数据库的字段与实体类属性名一致--&gt;        &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;--&gt;        &lt;!--达到 自动映射行为 : 局部的PARTIAL 重复的 &lt;result/&gt; 可以省略--&gt;        &lt;!--&lt;result column=&quot;&quot; property=&quot;&quot;/&gt;--&gt;        &lt;!--联合查询 一对一--&gt;        &lt;!--property 为type对象对应属性名 javaType 为所属类型--&gt;        &lt;association property=&quot;depa_id&quot; javaType=&quot;Depa&quot;&gt;            &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt;            &lt;result column=&quot;depa_id&quot; property=&quot;id&quot;/&gt;            &lt;!--因为数据库的字段与实体类属性名一致--&gt;            &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;--&gt;            &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt;            &lt;!--&lt;result column=&quot;&quot; property=&quot;&quot;/&gt;--&gt;        &lt;/association&gt;        &lt;!--收集 一对多--&gt;        &lt;!--property 为type对象对应属性名 javaType 为所属类型--&gt;        &lt;collection property=&quot;posts&quot; javaType=&quot;Post&quot;&gt;            &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt;            &lt;result column=&quot;post_id&quot; property=&quot;id&quot;/&gt;            &lt;!--因为数据库的字段与实体类属性名一致--&gt;            &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;--&gt;            &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt;            &lt;!--&lt;result column=&quot;&quot; property=&quot;&quot;/&gt;--&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;\n\nPost 职位实体类package com.entity;import java.util.ArrayList;import java.util.List;public class Post &#123;    private Integer id;    private String post_name;    private List&lt;Emp&gt; emps = new ArrayList&lt;Emp&gt;();    @Override    public String toString() &#123;        return &quot;Post&#123;&quot; +                &quot;id=&quot; + id +                &quot;, post_name=&#x27;&quot; + post_name + &#x27;\\&#x27;&#x27; +                &quot;, emps=&quot; + emps +                &#x27;&#125;&#x27;;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getPost_name() &#123;        return post_name;    &#125;    public void setPost_name(String post_name) &#123;        this.post_name = post_name;    &#125;    public List&lt;Emp&gt; getEmps() &#123;        return emps;    &#125;    public void setEmps(List&lt;Emp&gt; emps) &#123;        this.emps = emps;    &#125;&#125;\n\n对应 Post 职位实体类 的实现接口 PostDao 接口类package com.dao;import com.entity.Post;import java.util.List;public interface PostDao &#123;    List&lt;Post&gt; getAll();&#125;\n\n对应 Post 职位实体类 的映射配置文件 PostMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace mapper接口 必填 随便填值 防止SQL语句ID重名--&gt;&lt;mapper namespace=&quot;com.dao.PostDao&quot;&gt;    &lt;!--resultType 返回类型 实体类全限定类名--&gt;    &lt;select id=&quot;getAll&quot; resultMap=&quot;PostMapper&quot;&gt;        SELECT * FROM post p        INNER JOIN emp_post ep ON ep.`post_id`=p.`id`        INNER JOIN emp e ON e.`id`=ep.`emp_id`        INNER JOIN depa d ON d.`id`=e.`depa_id`    &lt;/select&gt;    &lt;!--type 为resultMap返回类型--&gt;    &lt;resultMap id=&quot;PostMapper&quot; type=&quot;Post&quot;&gt;        &lt;!--column 为数据库查到后取的别名 property 为type对象对应属性名--&gt;        &lt;result column=&quot;post_id&quot; property=&quot;id&quot;/&gt;        &lt;!--因为数据库的字段与实体类属性名一致--&gt;        &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;--&gt;        &lt;!--达到 自动映射行为 : 局部的PARTIAL 重复的 &lt;result/&gt; 可以省略--&gt;        &lt;!--&lt;result column=&quot;&quot; property=&quot;&quot;/&gt;--&gt;        &lt;!--联合查询 一对一--&gt;        &lt;!--property 为type对象对应属性名 javaType 为所属类型--&gt;        &lt;association property=&quot;emps&quot; javaType=&quot;Emp&quot;&gt;            &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt;            &lt;result column=&quot;emp_id&quot; property=&quot;id&quot;/&gt;            &lt;!--因为数据库的字段与实体类属性名一致--&gt;            &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;--&gt;            &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt;            &lt;!--&lt;result column=&quot;&quot; property=&quot;&quot;/&gt;--&gt;            &lt;association property=&quot;depa_id&quot; javaType=&quot;Depa&quot;&gt;                &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt;                &lt;result column=&quot;depa_id&quot; property=&quot;id&quot;/&gt;                &lt;!--因为数据库的字段与实体类属性名一致--&gt;                &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;--&gt;                &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt;                &lt;!--&lt;result column=&quot;&quot; property=&quot;&quot;/&gt;--&gt;            &lt;/association&gt;        &lt;/association&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;\n\nmybatis-config.xml MyBatis配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--可以配置在Java属性配置文件 *.properties 中--&gt;    &lt;properties resource=&quot;&quot;&gt;        &lt;!--可以配置键值对属性在这里而不用配置文件--&gt;        &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;    &lt;/properties&gt;    &lt;settings&gt;        &lt;!-- 打印查询语句 --&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;        &lt;!--达到 自动映射行为 : 全部FULL 局部的PARTIAL 禁止自动匹配NONE--&gt;        &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;    &lt;/settings&gt;    &lt;!--为Java类型命名一个别名 alias 用于 mappers.xml 的 resultType 直接调用 不用写全限定类名--&gt;    &lt;typeAliases&gt;        &lt;!--为一个Java类型命名一个别名--&gt;        &lt;!--&lt;typeAlias type=&quot;&quot; alias=&quot;&quot;/&gt;--&gt;        &lt;!--为 com.entity 包 全部Java类型命名一个别名 别名为Java类名--&gt;        &lt;package name=&quot;com.entity&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;!--环境变量--&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!--事务管理器--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!--数据源--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;simon&quot;/&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;!--MySQL数据库--&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/corp&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--映射器--&gt;    &lt;mappers&gt;        &lt;!--实体类映射--&gt;        &lt;mapper resource=&quot;com/entity/DepaMapper.xml&quot;/&gt;        &lt;mapper resource=&quot;com/entity/EmpMapper.xml&quot;/&gt;        &lt;mapper resource=&quot;com/entity/PostMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\nTest 测试类package com.test;import com.dao.DepaDao;import com.dao.EmpDao;import com.dao.PostDao;import com.entity.Depa;import com.entity.Emp;import com.entity.Post;import com.util.MybatisUtil;import org.apache.ibatis.session.SqlSession;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;public class Test &#123;    public static void main(String[] args) &#123;        SqlSession session = MybatisUtil.getSession();        DepaDao depaDao = session.getMapper(DepaDao.class);        EmpDao empDao = session.getMapper(EmpDao.class);        PostDao postDao = session.getMapper(PostDao.class);        List&lt;Depa&gt; depaDaoAll = depaDao.getAll();        for (Depa depa : depaDaoAll) &#123;            System.out.println(depa);        &#125;        System.out.println(&quot;getByNames------三 || 四&quot;);        List&lt;Emp&gt; byNames = empDao.getByNames(Arrays.asList(&quot;三&quot;, &quot;四&quot;));        for (Emp emp : byNames) &#123;            System.out.println(emp);        &#125;        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(&quot;mapIdName&quot;, 2);        map.put(&quot;mapNameList&quot;, Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;));        List&lt;Emp&gt; byIdAndNames = empDao.getByIdAndNames(map);        System.out.println(&quot;byIdAndNames------&quot; + map);        for (Emp emp : byIdAndNames) &#123;            System.out.println(emp);        &#125;        Emp simon = new Emp();        simon.setId(1);        simon.setEmp_name(&quot;Simon&quot;);        Depa depa = new Depa();        depa.setId(1);        simon.setDepa_id(depa);        if (0 == empDao.saveOrUpdate(simon))            System.out.println(&quot;saveOrUpdate-----false&quot;);        else            System.out.println(&quot;saveOrUpdate-----true&quot;);        Integer del = empDao.del(new Integer[]&#123;2, 3&#125;);        if (0 == del)            System.out.println(&quot;del-----false&quot;);        else            System.out.println(&quot;del-----true&quot;);        System.out.println(&quot;del-----&quot; + del);        List&lt;Emp&gt; empDaoAll = empDao.getAll();        for (Emp emp : empDaoAll) &#123;            System.out.println(emp);        &#125;        List&lt;Post&gt; postDaoAll = postDao.getAll();        for (Post post : postDaoAll) &#123;            System.out.println(post);        &#125;    &#125;&#125;\n\n控制台输出结果mybatis-config.xml 配置 &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; 控制台会打印执行的SQL语句以及得到的参数\n==&gt;  Preparing: SELECT *,e.`id` eId,d.`id` dId FROM depa d INNER JOIN emp e ON d.`id`=e.`depa_id`==&gt; Parameters:&lt;==    Columns: id, depa_name, id, emp_name, depa_id, eId, dId&lt;==        Row: 1, 销售部, 2, 李四, 1, 2, 1&lt;==        Row: 1, 销售部, 3, 王五, 1, 3, 1&lt;==        Row: 1, 销售部, 4, 赵六, 1, 4, 1&lt;==        Row: 2, 美工部, 1, 张三, 2, 1, 2&lt;==      Total: 4Depa&#123;id=1, depa_name=&#x27;销售部&#x27;, emps=[Emp&#123;id=2, emp_name=&#x27;李四&#x27;, depa_id=null, posts=[]&#125;, Emp&#123;id=3, emp_name=&#x27;王五&#x27;, depa_id=null, posts=[]&#125;, Emp&#123;id=4, emp_name=&#x27;赵六&#x27;, depa_id=null, posts=[]&#125;]&#125;Depa&#123;id=2, depa_name=&#x27;美工部&#x27;, emps=[Emp&#123;id=1, emp_name=&#x27;张三&#x27;, depa_id=null, posts=[]&#125;]&#125;getByNames------三 || 四==&gt;  Preparing: SELECT * FROM emp e INNER JOIN depa d ON d.`id`=e.`depa_id` INNER JOIN emp_post ep ON ep.`emp_id`=e.`id` INNER JOIN post p ON p.`id`=ep.`post_id` WHERE e.`emp_name` LIKE CONCAT(&#x27;%&#x27;,?,&#x27;%&#x27;) OR e.`emp_name` LIKE CONCAT(&#x27;%&#x27;,?,&#x27;%&#x27;)==&gt; Parameters: 三(String), 四(String)&lt;==    Columns: id, emp_name, depa_id, id, depa_name, emp_id, post_id, id, post_name&lt;==        Row: 1, 张三, 2, 2, 美工部, 1, 1, 1, 职员&lt;==        Row: 2, 李四, 1, 1, 销售部, 2, 2, 2, 主管&lt;==        Row: 1, 张三, 2, 2, 美工部, 1, 4, 4, 部门经理&lt;==      Total: 3Emp&#123;id=1, emp_name=&#x27;张三&#x27;, depa_id=Depa&#123;id=2, depa_name=&#x27;美工部&#x27;, emps=[]&#125;, posts=[Post&#123;id=1, post_name=&#x27;职员&#x27;, emps=[]&#125;, Post&#123;id=4, post_name=&#x27;部门经理&#x27;, emps=[]&#125;]&#125;Emp&#123;id=2, emp_name=&#x27;李四&#x27;, depa_id=Depa&#123;id=1, depa_name=&#x27;销售部&#x27;, emps=[]&#125;, posts=[Post&#123;id=2, post_name=&#x27;主管&#x27;, emps=[]&#125;]&#125;==&gt;  Preparing: SELECT * FROM emp e INNER JOIN depa d ON d.`id`=e.`depa_id` INNER JOIN emp_post ep ON ep.`emp_id`=e.`id` INNER JOIN post p ON p.`id`=ep.`post_id` WHERE e.`id` = ? AND e.`emp_name` IN ( ? , ? , ? )==&gt; Parameters: 2(Integer), 张三(String), 李四(String), 王五(String)&lt;==    Columns: id, emp_name, depa_id, id, depa_name, emp_id, post_id, id, post_name&lt;==        Row: 2, 李四, 1, 1, 销售部, 2, 2, 2, 主管&lt;==      Total: 1byIdAndNames------&#123;mapIdName=2, mapNameList=[张三, 李四, 王五]&#125;Emp&#123;id=2, emp_name=&#x27;李四&#x27;, depa_id=Depa&#123;id=1, depa_name=&#x27;销售部&#x27;, emps=[]&#125;, posts=[Post&#123;id=2, post_name=&#x27;主管&#x27;, emps=[]&#125;]&#125;==&gt;  Preparing: UPDATE emp SET emp_name = ?, depa_id = ? where id = ?==&gt; Parameters: Simon(String), 1(Integer), 1(Integer)&lt;==    Updates: 1saveOrUpdate-----true==&gt;  Preparing: DELETE FROM emp WHERE id = ? OR id = ?==&gt; Parameters: 2(Integer), 3(Integer)&lt;==    Updates: 2del-----truedel-----2==&gt;  Preparing: SELECT * FROM emp e INNER JOIN depa d ON d.`id`=e.`depa_id` INNER JOIN emp_post ep ON ep.`emp_id`=e.`id` INNER JOIN post p ON p.`id`=ep.`post_id`==&gt; Parameters:&lt;==    Columns: id, emp_name, depa_id, id, depa_name, emp_id, post_id, id, post_name&lt;==        Row: 1, Simon, 1, 1, 销售部, 1, 1, 1, 职员&lt;==        Row: 4, 赵六, 1, 1, 销售部, 4, 4, 4, 部门经理&lt;==        Row: 1, Simon, 1, 1, 销售部, 1, 4, 4, 部门经理&lt;==      Total: 3Emp&#123;id=1, emp_name=&#x27;Simon&#x27;, depa_id=Depa&#123;id=1, depa_name=&#x27;销售部&#x27;, emps=[]&#125;, posts=[Post&#123;id=1, post_name=&#x27;职员&#x27;, emps=[]&#125;, Post&#123;id=4, post_name=&#x27;部门经理&#x27;, emps=[]&#125;]&#125;Emp&#123;id=4, emp_name=&#x27;赵六&#x27;, depa_id=Depa&#123;id=1, depa_name=&#x27;销售部&#x27;, emps=[]&#125;, posts=[Post&#123;id=4, post_name=&#x27;部门经理&#x27;, emps=[]&#125;]&#125;==&gt;  Preparing: SELECT * FROM post p INNER JOIN emp_post ep ON ep.`post_id`=p.`id` INNER JOIN emp e ON e.`id`=ep.`emp_id` INNER JOIN depa d ON d.`id`=e.`depa_id`==&gt; Parameters:&lt;==    Columns: id, post_name, emp_id, post_id, id, emp_name, depa_id, id, depa_name&lt;==        Row: 1, 职员, 1, 1, 1, Simon, 1, 1, 销售部&lt;==        Row: 4, 部门经理, 4, 4, 4, 赵六, 1, 1, 销售部&lt;==        Row: 4, 部门经理, 1, 4, 1, Simon, 1, 1, 销售部&lt;==      Total: 3Post&#123;id=1, post_name=&#x27;职员&#x27;, emps=[Emp&#123;id=1, emp_name=&#x27;Simon&#x27;, depa_id=Depa&#123;id=1, depa_name=&#x27;销售部&#x27;, emps=[]&#125;, posts=[]&#125;]&#125;Post&#123;id=4, post_name=&#x27;部门经理&#x27;, emps=[Emp&#123;id=4, emp_name=&#x27;赵六&#x27;, depa_id=Depa&#123;id=1, depa_name=&#x27;销售部&#x27;, emps=[]&#125;, posts=[]&#125;, Emp&#123;id=1, emp_name=&#x27;Simon&#x27;, depa_id=Depa&#123;id=1, depa_name=&#x27;销售部&#x27;, emps=[]&#125;, posts=[]&#125;]&#125;\n","categories":["mybatis","xml","映射配置","动态SQL"],"tags":["idea","mysql","多对多","一对多","多对一","mybatis","一对一","动态SQL","映射配置"]},{"title":"MyBatis框架映射文件配置以及配置文件详解","url":"/2018/04/03/MyBatis%E6%A1%86%E6%9E%B6%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","content":"什么是 MyBatis ？MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。\n\n\nMyBatis的 Git 代码库环境idea\njdk\nmaven\nMySQL\n\nalia_SQL.sql 创建数据库-- 创建数据库aliaCREATE DATABASE alia;USE alia;-- 供应商表CREATE TABLE alia_provider(\tid INT(20) AUTO_INCREMENT PRIMARY KEY,\tproCode VARCHAR(20),\tproName VARCHAR(20),\tproDesc VARCHAR(50),\tproContact VARCHAR(20),\tproPhone VARCHAR(20),\tproAddress VARCHAR(50),\tproFax VARCHAR(20),\tcreatedBy INT(20),\tcreationDate DATETIME,\tmodifyBy INT(20),\tmodifyDate DATETIME);INSERT  INTO `alia_provider`(`id`,`proCode`,`proName`,`proDesc`,`proContact`,`proPhone`,`proAddress`,`proFax`,`createdBy`,`creationDate`,`modifyDate`,`modifyBy`) VALUES (1,&#x27;BJ_GYS001&#x27;,&#x27;北京三木堂商贸有限公司&#x27;,&#x27;长期合作伙伴，主营产品:茅台、五粮液、郎酒、酒鬼酒、泸州老窖、赖茅酒、法国红酒等&#x27;,&#x27;张国强&#x27;,&#x27;13566667777&#x27;,&#x27;北京市丰台区育芳园北路&#x27;,&#x27;010-58858787&#x27;,1,&#x27;2013-03-21 16:52:07&#x27;,NULL,NULL);INSERT  INTO `alia_provider`(`id`,`proCode`,`proName`,`proDesc`,`proContact`,`proPhone`,`proAddress`,`proFax`,`createdBy`,`creationDate`,`modifyDate`,`modifyBy`) VALUES (2,&#x27;HB_GYS001&#x27;,&#x27;石家庄帅益食品贸易有限公司&#x27;,&#x27;长期合作伙伴，主营产品:饮料、水饮料、植物蛋白饮料、休闲食品、果汁饮料、功能饮料等&#x27;,&#x27;王军&#x27;,&#x27;13309094212&#x27;,&#x27;河北省石家庄新华区&#x27;,&#x27;0311-67738876&#x27;,1,&#x27;2016-04-13 04:20:40&#x27;,NULL,NULL);SELECT * FROM alia_provider;\n\npom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com&lt;/groupId&gt;    &lt;artifactId&gt;MyBiatisLink&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.38&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\nMybatisUtil 创建访问数据库得到session对象工具类package com.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;/** * @author James */public class MybatisUtil &#123;    private static SqlSessionFactory sessionFactory;    static &#123;        try &#123;            InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);            sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static SqlSession getSession() &#123;        //true为自动提交事务        return sessionFactory.openSession(false);    &#125;&#125;\n\nProvider 数据库对应的实体类package com.entity;import java.util.Date;/** * @author James */public class Provider &#123;    private Integer id;    private String proCode;    private String proName;    private String proDesc;    private String proContact;    private String proPhone;    private String proAddress;    private String proFax;    private Integer createdBy;    private Date creationDate;    private Integer modifyBy;    private Date modifyDate;    @Override    public String toString() &#123;        return &quot;Provider&#123;&quot; +                &quot;id=&quot; + id +                &quot;, proCode=&#x27;&quot; + proCode + &#x27;\\&#x27;&#x27; +                &quot;, proName=&#x27;&quot; + proName + &#x27;\\&#x27;&#x27; +                &quot;, proDesc=&#x27;&quot; + proDesc + &#x27;\\&#x27;&#x27; +                &quot;, proContact=&#x27;&quot; + proContact + &#x27;\\&#x27;&#x27; +                &quot;, proPhone=&#x27;&quot; + proPhone + &#x27;\\&#x27;&#x27; +                &quot;, proAddress=&#x27;&quot; + proAddress + &#x27;\\&#x27;&#x27; +                &quot;, proFax=&#x27;&quot; + proFax + &#x27;\\&#x27;&#x27; +                &quot;, createdBy=&quot; + createdBy +                &quot;, creationDate=&quot; + creationDate +                &quot;, modifyBy=&quot; + modifyBy +                &quot;, modifyDate=&quot; + modifyDate +                &#x27;&#125;&#x27;;    &#125;    // 省略getter and setter部分代码&#125;\n\nProviderDao 创建实现访问数据库的接口package com.dao;import com.entity.Provider;import java.util.List;/** * @author James */public interface ProviderDao &#123;    /**     * 获取供应商列表     *     * @return List&lt;Provider&gt;     */    List&lt;Provider&gt; getProviderList();    /**     * 按名称获取供应商     *     * @param provider &#123;@link Provider&#125;     * @return List&lt;Provider&gt;     */    List&lt;Provider&gt; getProviderByName(Provider provider);&#125;\n\nProvider.xml Provider对象与数据库的映射文件配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace mapper接口 必填 随便填值 防止SQL语句ID重名--&gt;&lt;mapper namespace=&quot;com.dao.ProviderDao&quot;&gt;    &lt;!--resultType 返回类型 实体类全限定类名--&gt;    &lt;!--为一个Java类型命名一个别名 aliasProvider--&gt;    &lt;select id=&quot;getProviderList&quot; resultType=&quot;aliasProvider&quot;&gt;        SELECT * FROM alia_provider    &lt;/select&gt;    &lt;!--为 com.entity 包 全部Java类型命名一个别名 别名为Java类名--&gt;    &lt;!--ProviderDao 参数为对象 得到对象的属性值方式 #&#123;对象的属性值&#125;--&gt;    &lt;select id=&quot;getProviderByName&quot; resultType=&quot;Provider&quot;&gt;        SELECT * FROM alia_provider WHERE proName LIKE CONCAT(&#x27;%&#x27;,#&#123;proName&#125;,&#x27;%&#x27;)    &lt;/select&gt;&lt;/mapper&gt;\n\ndatebase.properties 数据库配置文件有需要可以加上配置文件,或者直接将数据填到 MyBatis上下文配置 mybatis-config.xml 中\nmysql.username=rootmysql.password=123456db=alia\n\nmybatis-config.xml 连接数据库的MyBatis上下文配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--可以配置在Java属性配置文件中 用 $&#123;键值&#125;--&gt;    &lt;properties resource=&quot;db.properties&quot;&gt;        &lt;!--可以配置键值对属性在这里而不用配置文件--&gt;        &lt;property name=&quot;mysql.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;mysql.url&quot; value=&quot;jdbc:mysql://localhost:3306/&quot;/&gt;    &lt;/properties&gt;    &lt;!--为Java类型命名一个别名 alias 用于 mappers.xml 的 resultType 直接调用 不用写全限定类名--&gt;    &lt;typeAliases&gt;        &lt;!--为一个Java类型命名一个别名--&gt;        &lt;typeAlias type=&quot;com.entity.Provider&quot; alias=&quot;aliasProvider&quot;/&gt;        &lt;!--为 com.entity 包 全部Java类型命名一个别名 别名为Java类名--&gt;        &lt;package name=&quot;com.entity&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;!--环境变量--&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!--事务管理器--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!--数据源--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;mysql.username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;mysql.password&#125;&quot;/&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;mysql.driver&#125;&quot;/&gt;                &lt;!--MySQL数据库--&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;mysql.url&#125;$&#123;db&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--映射器--&gt;    &lt;mappers&gt;        &lt;!--实体类映射--&gt;        &lt;mapper resource=&quot;com/entity/Provider.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\nTest 测试类package com.test;import com.dao.ProviderDao;import com.entity.Provider;import com.util.MybatisUtil;import org.apache.ibatis.session.SqlSession;import java.util.List;/** * @author James */public class Test &#123;    public static void main(String[] args) &#123;        SqlSession session = MybatisUtil.getSession();//        直接去 Mapper.xml 得到数据访问数据库 参数为 namespace.id        List&lt;Provider&gt; objects = session.selectList(&quot;com.dao.ProviderDao.getProviderList&quot;);        for (Provider provider : objects) &#123;            System.out.println(provider);        &#125;        System.out.println(&quot;-----------------------------面向对象的方式访问数据库-----------------------------&quot;);//        面向对象的方式访问数据库        ProviderDao providerDao = session.getMapper(ProviderDao.class);        objects = providerDao.getProviderList();        for (Provider provider : objects) &#123;            System.out.println(provider);        &#125;        System.out.println(&quot;-----------------------------ProviderDao接口带参数 实现带参数查询-----------------------------&quot;);        Provider p = new Provider();        p.setProName(&quot;石&quot;);        objects = providerDao.getProviderByName(p);        for (Provider provider : objects) &#123;            System.out.println(provider);        &#125;//        关闭会话        session.close();    &#125;&#125;\n\n点击下载案例","categories":["mybatis","mysql"],"tags":["idea","mysql","关系映射","mybatis","配置文件"]},{"title":"MySQL支持emoji表情存储","url":"/2018/11/30/MySQL%E6%94%AF%E6%8C%81emoji%E8%A1%A8%E6%83%85%E5%AD%98%E5%82%A8/","content":"MySQL插入emoji表情，出现错误java.sql.SQLException: Incorrect string value: &#x27;\\xF0\\x9F\\x98\\x8A&#x27; for column &#x27;content&#x27; at row\n\n可以对4字节的字符进行编码存储，然后取出来的时候，再进行解码。但是这样做会使得任何使用该字符的地方都要进行编码与解码。\nutf8mb4编码是utf8编码的超集，兼容utf8，并且能存储4字节的表情字符。采用utf8mb4编码的好处是：存储与获取数据的时候，不用再考虑表情字符的编码与解码问题。\nMySQL的版本utf8mb4的最低mysql版本支持版本为5.5.3+，若不是，请升级到较新版本。\n\n\nMySQL驱动5.1.34可用,最低不能低于5.1.13\n修改MySQL配置文件修改mysql配置文件my.cnf（Windows为my.ini）my.cnf 一般在 /etc/mysql/my.cnf 位置\n部分Linux系统的 my.cnf 文件打开后是这样的\n## The MySQL database server configuration file.## You can copy this to one of:# - &quot;/etc/mysql/my.cnf&quot; to set global options,# - &quot;~/.my.cnf&quot; to set user-specific options.## One can use all long options that the program supports.# Run program with --help to get a list of available options and with# --print-defaults to see which it would actually understand and use.## For explanations see# http://dev.mysql.com/doc/mysql/en/server-system-variables.html## * IMPORTANT: Additional settings that can override those from this file!#   The files must end with &#x27;.cnf&#x27;, otherwise they&#x27;ll be ignored.#!includedir /etc/mysql/conf.d/!includedir /etc/mysql/mysql.conf.d/\n\n那么这个配置文件的路径应该改成文件内容下面的地址\n/etc/mysql/conf.d/mysql.cnf\n\n找到后请在以下三部分里添加或修改如下内容\n[client]default-character-set=utf8mb4[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ciinit_connect=&#x27;SET NAMES utf8mb4&#x27;[mysql]default-character-set=utf8mb4\n\n重启数据库，检查变量Windows终端指令\nnet stop mysql57net start mysql57\n\nLinux终端指令\nservice mysql stopservice mysql startservice mysql status\n\n数据库SQL语句\nSHOW VARIABLES WHERE Variable_name LIKE &#x27;character\\_set\\_%&#x27; OR Variable_name LIKE &#x27;collation%&#x27;;\n\n修改前输出\n+--------------------------+-------------------+| Variable_name            | Value             |+--------------------------+-------------------+| character_set_client     | gbk               || character_set_connection | gbk               || character_set_database   | latin1            || character_set_filesystem | binary            || character_set_results    | gbk               || character_set_server     | latin1            || character_set_system     | utf8              || collation_connection     | gbk_chinese_ci    || collation_database       | latin1_swedish_ci || collation_server         | latin1_swedish_ci |+--------------------------+-------------------+\n\n修改后输出\n+--------------------------+--------------------+| Variable_name            | Value              |+--------------------------+--------------------+| character_set_client     | utf8mb4            || character_set_connection | utf8mb4            || character_set_database   | utf8mb4            || character_set_filesystem | binary             || character_set_results    | utf8mb4            || character_set_server     | utf8mb4            || character_set_system     | utf8               || collation_connection     | utf8mb4_unicode_ci || collation_database       | utf8mb4_unicode_ci || collation_server         | utf8mb4_unicode_ci |+--------------------------+--------------------+\n","categories":["mysql","emoji"],"tags":["mysql","配置","emoji"]},{"title":"OGNL创建和配置自定义日期类型转换器","url":"/2017/06/12/OGNL%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8/","content":"OGNLOGNL 中文名 对象图导航语言 是 Object-Graph Navigation Language 的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。\n\n\n基于OGNL的类型转换器Struts2的类型转换器都需要实现一个TypeConverter接口，该接口位于ognl.jar包内，也是就Struts2框架的转换器使用了OGNL技术。该接口定义了一个convertValue()方法，实现该接口的类型转换器实现类都需要重写该方法来进行类型转换。OGNL还提供了一个实现TypeConverter接口的类DefaultTypeConverter，开发者只要继承该类，就可以开发类型转换器的实现类。\nDefaultTypeConverter类的子类需要重写convertValue()方法，来实现字符串类型与复合类型之间的双向转换。convertValue()方法有三个参数：Map context：该参数为类型转换环境的上下文内容；Object value：该参数为需要转换的参数；Class toType：该参数指的是转换目标的类型。\npublic class PointConverter extends DefaultTypeConverter &#123;    public Object convertValue(Map context,Object value,Class toType)&#123;        System.out.println(&quot;正在转换...&quot;);        if(toType==Point.class)&#123;            String[] p=(String[])value;            Point point=new Point();            String[] pp=p[0].split(&quot;,&quot;);            point.setX(pp[0]);            point.setY(pp[1]);            return point;                &#125;        else if(toType==String.class)&#123;            Point point=(Point) value;            return &quot;&lt;&quot;+point.getX()+&quot;,&quot;+point.getY()+&quot;&gt;&quot;;        &#125;        return null;    &#125;&#125;\n\nconvertValue()方法是通过toType的类型判断来实现双向转换的\n基于Struts2的类型转换器Struts2框架提供了一个类型转换器的StrutsTypeConverter抽象类，开发者可以继承该类来开发自定义的类型转换器实现类。 该抽象类实际上继承了DefaultTypeConverter类，在该类的基础上进行了简化。StrutsTypeConverter抽象类是Struts2框架中类型转换器的基础，该类中提供了两个抽象方法，这两个抽象方法分别实现“form字符串参数-Struts复合类型”之间的双向转换\npublic class PointConverter2 extends StrutsTypeConverter &#123;    //定义convertFromString方法    @Override    public Object convertFromString(Map arg0, String[] arg1, Class arg2) &#123;        // TODO Auto-generated method stub        System.out.println(&quot;正在转换：从字符串转换到复合类型...&quot;);        Point point=new Point();        String[] pp=arg1[0].split(&quot;,&quot;);        point.setX(pp[0]);        point.setY(pp[1]);        return point;    &#125;    //定义convertToString方法    @Override        public String convertToString(Map arg0, Object arg1) &#123;        // TODO Auto-generated method stub        Point point=(Point) arg1;        return &quot;&lt;&quot;+point.getX()+&quot;,&quot;+point.getY()+&quot;&gt;&quot;;      &#125;&#125;\n\n自定义日期类型转换器例子环境idea\nJava\nMaven\nStruts2\nTomcat\n\npom.xml 配置 dependencies&lt;dependencies&gt;    &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-core --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;        &lt;artifactId&gt;struts2-core&lt;/artifactId&gt;        &lt;version&gt;2.3.16.3&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\nutil包 DateConverter类package com.util;import com.opensymphony.xwork2.conversion.TypeConversionException;import org.apache.struts2.util.StrutsTypeConverter;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Map;public class DateConverter extends StrutsTypeConverter &#123;    //支持转换的多种日期格式,可增加时间格式    private final DateFormat[] dfs = &#123;            new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;),            new SimpleDateFormat(&quot;yyyy/MM/dd&quot;),            new SimpleDateFormat(&quot;yyyy-MM-dd&quot;),            new SimpleDateFormat(&quot;yyyy@MM@dd&quot;)    &#125;;    /**     * 将指定格式字符串转换为日期类型     *     * @param map     类型转换环境的上下文内容     * @param strings 需要转换的参数     * @param aClass  转换目标的类型     * @return     */    public Object convertFromString(Map map, String[] strings, Class aClass) &#123;        String dateStr = strings[0];            //获取日期的字符串        for (int i = 0; i &lt; dfs.length; i++) &#123;  //遍历日期支持格式,进行转换            try &#123;                return dfs[i].parse(dateStr);            &#125; catch (Exception e) &#123;                continue;            &#125;        &#125;        //如果遍历完毕后仍没有转换成功,表明出现转换异常        throw new TypeConversionException();    &#125;    /**     * 将日期转换为指定格式字符串     *     * @param map     * @param o     * @return     */    public String convertToString(Map map, Object o) &#123;        Date date = (Date) o;        //输出的格式是yyyy-MM-dd        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(date);    &#125;&#125;\n\naction包 DateAction类package com.action;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ValidationAware;import java.util.Date;public class DateAction extends ActionSupport implements ValidationAware &#123;    public Date getTime() &#123;        return time;    &#125;    public void setTime(Date time) &#123;        this.time = time;    &#125;    private Date time;    @Override    public String execute() throws Exception &#123;        return SUCCESS;    &#125;&#125;\n\nxwork-conversion.properties 配置转换类全名=类型转换器类全名\n\njava.util.Date=com.util.DateConverter\n\n测试页面 index.jsp&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;format.action&quot; method=&quot;post&quot;&gt;    日期类型转换器:    &lt;input type=&quot;text&quot; name=&quot;time&quot; value=&quot;1993@12@24&quot;/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;&lt;s:property value=&quot;time&quot;/&gt;&lt;s:fielderror/&gt;&lt;/body&gt;&lt;/html&gt;\n\nweb.xml 配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.4&quot;         xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;Struts&lt;/filter-name&gt;        &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;Struts&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\nstruts.xml 配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;        &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt;    &lt;!--value 的 message 为指定根目录的 message.properties 配置文件--&gt;    &lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;message&quot;/&gt;    &lt;package name=&quot;default&quot; extends=&quot;struts-default&quot;&gt;        &lt;action name=&quot;format&quot; class=&quot;com.action.DateAction&quot;&gt;            &lt;result&gt;index.jsp&lt;/result&gt;            &lt;result name=&quot;input&quot;&gt;index.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;\n\nmessage.properties 修改错误信息配置xwork.default.invalid.fieldvalue=\\u5b57\\u6bb5&quot;&#123;0&#125;&quot;\\u7684\\u503c\\u65e0\\u6548\n\n`\\u5b57\\u6bb5&quot;&#123;0&#125;&quot;\\u7684\\u503c\\u65e0\\u6548` 为 Unicode编码 `字段&quot;&#123;0&#125;&quot;的值无效` 配置文件 `中文` 需要转换成 `Unicode编码`\n\nUnicode编码转换网站\n","categories":["struts2","OGNL","自定义转换器"],"tags":["idea","java","OGNL","自定义转换器","struts2"]},{"title":"Open Session In View 模式","url":"/2017/06/06/Open-Session-In-View-%E6%A8%A1%E5%BC%8F/","content":"什么是 Open Session In View 模式在hibernate中使用load方法时，并未把数据真正获取时就关闭了session，当我们真正想获取数据时会迫使load加载数据，而此时 session已关闭，所以就会出现异常。 比较典型的是在MVC模式中，我们在M层调用持久层获取数据时(持久层用的是load方法加载数据)，当这一调用结束时，session随之关闭，而我们 希望在V层使用这些数据，这时才会迫使load加载数据，我们就希望这时的session是open着得，这就是所谓的Open Session In view 。 我们可以filter来达到此目的\n\n\nOpenSesstionInViewFilter.java 的主要代码package com.accp.filter;import com.accp.util.HibernateUtil;import org.hibernate.HibernateException;import org.hibernate.Transaction;import javax.servlet.*;import java.io.IOException;public class OpenSesstionInViewFilter implements Filter &#123;    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        Transaction transaction = null;        try &#123;            System.out.println(&quot;请求到达时打开session并启动事务&quot;);            transaction = HibernateUtil.currentSesstion().beginTransaction();            System.out.println(&quot;执行请求处理链&quot;);            filterChain.doFilter(servletRequest, servletResponse);            System.out.println(&quot;返回响应时，提交事务&quot;);            transaction.commit();        &#125; catch (HibernateException e) &#123;            e.printStackTrace();            if (transaction != null) &#123;                transaction.rollback();                System.out.println(&quot;回滚事务&quot;);            &#125;        &#125;    &#125;    public void destroy() &#123;    &#125;&#125;\n\nweb.xml 中 Filter 的配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;         version=&quot;3.0&quot;&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;OpenSesstionInView&lt;/filter-name&gt;        &lt;filter-class&gt;com.accp.filter.OpenSesstionInViewFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;OpenSesstionInView&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;\n","categories":["hibernate","session","filter"],"tags":["hibernate","session","filter"]},{"title":"Rancher 1.6 快速安装指南","url":"/2021/12/11/Rancher-1-6-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/","content":"快速安装指南在本节中，我们将进行简单快速的Rancher安装，即在一台Linux机器上安装Rancher，并使其能够完成所有Rancher必要功能。\n\n\n准备LINUX主机先安装一个64位的Ubuntu 16.04 Linux主机，其内核必须高于3.10。你可以使用笔记本、虚拟机或物理服务器。请确保该Linux主机内存不低于1GB。在该主机上安装 支持的Docker版本。\n在主机上安装Docker的方法请参照Docker网站的安装说明。\n\n注意：目前Rancher尚不支持Docker for Windows以及Docker for Mac。\n\nRANCHER SERVER标签Rancher Server当前版本中有2个不同的标签。对于每一个主要的release标签，我们都会提供对应版本的文档。\n\nrancher/server:latest 此标签是我们的最新一次开发的构建版本。这些构建已经被我们的CI框架自动验证测试。但这些release并不代表可以在生产环境部署。\n\nrancher/server:stable 此标签是我们最新一个稳定的release构建。这个标签代表我们推荐在生产环境中使用的版本。\n\n\n请不要使用任何带有 rc&#123;n&#125; 前缀的release。这些构建都是Rancher团队的测试构建。\n启动RANCHER SERVER你只需要一条命令就可以启动Rancher Server。当Rancher Server容器启动以后，我们将能查看到相关的日志。\n$ sudo docker run -d --restart=unless-stopped -p 8080:8080 rancher/server:stable# Tail the logs to show Rancher$ sudo docker logs -f &lt;CONTAINER_ID&gt;\n启动Rancher Server只需要几分钟时间。当日志中显示 .... Startup Succeeded, Listening on port...的时候，Rancher UI就能正常访问了。配置一旦完成，这行日志就会立刻出现。需要注意的是，这一输出之后也许还会有其他日志，因此，在初始化过程中这不一定是最后一行日志。\nRancher UI的默认端口是 8080。所以为了访问UI，需打开http://&lt;SERVER_IP&gt;:8080。需要注意的事，如果你的浏览器和Rancher Server是运行在同一主机上的，你需要通过主机的真实IP地址访问，比如 http://192.168.1.100:8080 ，而不是 http://localhost:8080 或http://127.0.0.1:8080，以防在添加主机的时候使用了不可达的IP而出现问题。\n\n注意：\n\n初始安装时Rancher的访问控制并未配置，任何能够访问你的IP地址的人，都可以访问你的UI和API。我们建议你配置 访问控制. \n国内的公有云主机，如果需要使用80和8080端口，需备案后才可以使用。\n\n\n添加主机在这里，为了简化操作，我们将添加运行着Rancher Server的主机为Rancher内的主机。在实际的生产环境中，请使用专用的主机来运行Rancher Server。\n想要添加主机，首先你需要进入UI界面，点击基础架构，然后你将看到主机界面。点击添加主机，Rancher将提示你选择主机注册URL。这个URL是Rancher Server运行所在的URL，且它必须可以被所有你要添加的主机访问到——当Rancher Server会通过NAT防火墙或负载均衡器被暴露至互联网时，这一设定就非常重要了。如果你的主机有一个私有或本地的IP地址，比如 192.168.*.*，Rancher将提示一个警告信息，提醒你务必确保这个URL可以被主机访问到。\n因为我们现在只会添加Rancher Server主机自身，你可以暂时忽略这些警告。点击保存。默认选择自定义选项，你将得到运行Rancher agent容器的Docker命令。这里还有其他的公有云的选项，使用这些选项，Rancher可以使用Docker Machine来启动主机。\nRancher UI会给你提供一些指示，比如你的主机上应该开放的端口，还有其他一些可供选择的信息。鉴于我们现在添加的是Rancher Server运行的主机，我们需要添加这个主机所使用的公网IP。页面上的一个选项提供输入此IP的功能，此选项会自动更新Docker命令中的环境变量参数以保证正确。\n然后请在运行Rancher Server的主机上运行这个命令。\n当你在Rancher UI上点击关闭按钮时，你会被返回到基础架构-&gt;主机界面。一两分钟之后，主机会自动出现在这里。\n基础设施服务当你第一次登陆Rancher时，你将自动进入默认环境。默认已经为此环境选择了Cattle环境模板来启动基础设施服务。要想充分利用Rancher的一些功能，如DNS、元数据、网络、健康检查，你需要启动这些基础设施服务。这些基础设施可以在应用栈 -&gt; 基础设施中找到。在主机被添加至Rancher之前，这些栈会处于 unhealthy 状态。主机添加完成后，建议等到所有基础设施服务都处于active状态之后再添加服务。\n在主机上，所有属于基础设施服务的容器将被隐藏，除非你单击“显示系统容器”复选框。\n通过UI创建一个容器导航到应用页面，如果你看到了欢迎屏幕，可以在欢迎屏幕中单击定义服务的按钮。如果你的Rancher设置中已有服务，你可以在任何现有应用中点击添加服务，或者创建一个新的应用来添加服务。应用只是将服务组合在一起的便捷方式。 如果需要创建新的应用，请单击添加应用，填写名称和描述，然后单击创建。 接着，在新的应用中单击添加服务。\n给服务取个名字，比如“第一个服务”。你可以使用我们的默认设置，然后单击创建。Rancher将开始在主机上启动容器。不论你的主机IP地址是什么，第一个容器的IP地址都将在 10.42.*.* 的范围内，因为Rancher已使用ipsec基础设施服务创建了一个托管网络。各容器之间是通过这个托管网络进行跨主机通信的。\n如果你单击第一个容器的下拉列表，你将可以进行各种管理操作，如停止容器、查看日志或访问容器控制台。\n通过DOCKER原生CLI创建一个容器Rancher会显示主机之上的所有容器，即使有些容器是在UI之外创建的。在主机的shell终端中创建一个容器。\ndocker run -d -it --name=second-container ubuntu:14.04.2\n\n在UI中，你将看到第二个容器在你的主机上出现！\nRancher会对Docker守护进程中发生的事件做出反应，调整自己以反映现实情况。你可以在此了解更多通过Docker原生CLI使用Rancher的事宜。\n如果你查看第二个容器的IP地址，你将发现它不在10.42.*.* 范围内。它的IP地址是Docker守护进程分配的常用IP地址。这是通过CLI创建Docker容器的预期行为。\n如果我们想通过CLI创建一个Docker容器，但仍希望它使用Rancher托管网络的IP地址，该怎么做呢？我们只需要在命令中添加一个标签(io.rancher.container.network=true)，让Rancher知道你希望此容器成为托管网络的一部分。\ndocker run -d -it --label io.rancher.container.network=true ubuntu:14.04.2\n\n创建一个多容器应用上文中我们已经介绍了如何创建单个容器以及这些单个容器之间如何进行跨主机网络通信。然而，现实情况中，大多数应用程序其实是由多个服务构成的，而每个服务又是由多个容器构成的。比如说，一个LetsChat应用程序，就是由下列几项服务构成的：\n\n\n一个负载均衡器。负载均衡器把Internet流量转发给“LetsChat”应用程序。\n\n\n\n\n一个由两个“LetsChat”容器组成的web服务。\n\n\n\n\n一个由一个“Mongo”容器组成的数据库服务。\n\n\n负载均衡器的目标是web服务（即LetsChat），Web服务将连接到数据库服务（即Mongo）。\n在本节中，我们将介绍如何在Rancher中创建和部署LetsChat应用程序。\n导航到应用页面，如果你看到了欢迎屏幕，可以在欢迎屏幕中单击定义服务的按钮。 如果你的Rancher设置中已有服务，你可以在任何现有应用中点击添加应用，来创建一个新的应用。填写名称和描述，然后单击创建。 接着，在新的应用中单击添加服务。\n首先，我们将创建一个名为database的数据库服务，并使用mongo镜像。单击创建。你将立即被带到应用页面，页面中将包含新创建的数据库服务。\n接下来，再次点击添加服务以添加其他服务。我们将添加一个LetsChat服务并链接到database服务。让我们使用名称web以及sdelements/lets-chat镜像。在UI中，我们可以移动滑块，将服务扩容至2个容器。在服务链接中，添加database服务并将其命名为mongo。就像Docker的做法一样，Rancher会在letschat容器里加入这个链接所需要的相关环境变量。单击创建。\n最后，我们将创建我们的负载均衡器。单击添加服务按钮旁的下拉菜单图标。选择添加负载均衡。提供一个类似于letschatapplb这样的名字。输入访问端口（例如80端口），选择目标服务（即web），并选择目标端口（即8080端口）。web服务正在侦听8080端口。单击创建。\n至此，我们的LetsChat应用程序已完成！在应用页面上，你可以查找到超链接形式的负载均衡所暴露端口。点击该链接，将会打开一个新的页面，你将能看到LetsChat应用程序了。\n使用RANCHER CLI创建一个多容器应用程序在本节中，我们将介绍如何使用我们的命名行工具Rancher CLI创建和部署跟上一节中我们创建的一样的LetsChat应用程序。\n当在Rancher中创建服务时，Rancher CLI工具与颇受欢迎的Docker Compose工具的工作方式类似。 它接收相同的docker-compose.yml文件，并在Rancher上部署应用程序。 你可以在rancher-compose.yml文件中指定更多的属性，该文件将扩展并覆盖docker-compose.yml文件。\n在上一节中，我们创建了一个具有一个负载均衡器的LetsChat应用程序。如果你已经在Rancher中创建了它，你可以直接在UI中下载这些文件，只需在应用的下拉菜单中选择导出配置即可。docker-compose.yml文件与 rancher-compose.yml 文件与下方示例类似：\nDOCKER-COMPOSE.YML示例version: &#x27;2&#x27;services:  letschatapplb:    #If you only have 1 host and also created the host in the UI,    # you may have to change the port exposed on the host.    ports:    - 80:80/tcp    labels:      io.rancher.container.create_agent: &#x27;true&#x27;      io.rancher.container.agent.role: environmentAdmin    image: rancher/lb-service-haproxy:v0.4.2  web:    labels:      io.rancher.container.pull_image: always    tty: true    image: sdelements/lets-chat    links:    - database:mongo    stdin_open: true  database:    labels:      io.rancher.container.pull_image: always    tty: true    image: mongo    stdin_open: true\n\nRANCHER-COMPOSE.YML示例version: &#x27;2&#x27;services:  letschatapplb:    scale: 1    lb_config:      certs: []      port_rules:      - hostname: &#x27;&#x27;        path: &#x27;&#x27;        priority: 1        protocol: http        service: web        source_port: 80        target_port: 8080    health_check:      port: 42      interval: 2000      unhealthy_threshold: 3      healthy_threshold: 2      response_timeout: 2000  web:    scale: 2  database:    scale: 1\n\n在Rancher UI中单击下载CLI（该按钮位于页面的右下角），即可下载Rancher CLI二进制文件，Windows、Mac和Linux的二进制文件均可下载。\n若想使用Rancher CLI在Rancher中启动服务，你需要设置一些环境变量。你需要在Rancher UI中创建一个账户API Key。单击API -&gt; 密钥。单击添加账户API Key。填写一个名字，然后单击创建。保存Access Key（用户名）和Secret Key（密码）。通过运行rancher config配置RancherCLI，使用Rancher URL、Access Key和Secret Key。\n# Configure Rancher CLI$ rancher config# Set the Rancher URLURL []: http://&lt;SERVER_IP&gt;:8080/# Set the access key, i.e. usernameAccess Key []: &lt;accessKey_of_account_api_key&gt;# Set the secret key, i.e. passwordSecret Key []:  &lt;secretKey_of_account_api_key&gt;\n\n现在进入保存了docker-compose.yml和rancher-compose.yml 文件的目录中，运行下面这个命令。\n$ rancher up -d -s NewLetsChatApp\n\n在Rancher中，一个叫做NewLetsChatApp的应用将被创建，且所有服务都将在Rancher中运行起来。\n","categories":["linux","docker","rancher"],"tags":["linux","docker","rancher","容器编排"]},{"title":"RedisDesktopManager连接远程Linux系统的Redis服务","url":"/2018/12/04/RedisDesktopManager%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8BLinux%E7%B3%BB%E7%BB%9F%E7%9A%84Redis%E6%9C%8D%E5%8A%A1/","content":"进入Redis安装目录root@Ubuntu:/usr/local/software/redis-4.0.9# lltotal 316drwxrwxr-x  6 root root   4096 Dec  4 15:47 ./drwxr-xr-x  6 root root   4096 Dec  4 14:55 ../-rw-rw-r--  1 root root 157632 Mar 27  2018 00-RELEASENOTES-rw-rw-r--  1 root root     53 Mar 27  2018 BUGS-rw-rw-r--  1 root root   1815 Mar 27  2018 CONTRIBUTING-rw-rw-r--  1 root root   1487 Mar 27  2018 COPYINGdrwxrwxr-x  6 root root   4096 Dec  4 11:49 deps/-rw-rw-r--  1 root root    376 Mar 27  2018 .gitignore-rw-rw-r--  1 root root     11 Mar 27  2018 INSTALL-rw-rw-r--  1 root root    151 Mar 27  2018 Makefile-rw-rw-r--  1 root root   4223 Mar 27  2018 MANIFESTO-rw-rw-r--  1 root root  20543 Mar 27  2018 README.md-rw-rw-r--  1 root root  58824 Dec  4 15:47 redis.conf    (Redis配置文件)-rwxrwxr-x  1 root root    271 Mar 27  2018 runtest*-rwxrwxr-x  1 root root    280 Mar 27  2018 runtest-cluster*-rwxrwxr-x  1 root root    281 Mar 27  2018 runtest-sentinel*-rw-rw-r--  1 root root   7606 Mar 27  2018 sentinel.confdrwxrwxr-x  3 root root   4096 Dec  4 15:53 src/          (执行脚本)drwxrwxr-x 10 root root   4096 Mar 27  2018 tests/drwxrwxr-x  8 root root   4096 Mar 27  2018 utils/\n\n\n\n进入src目录，执行脚本root@Ubuntu:/usr/local/software/redis-4.0.9/src# ./redis-server981:C 04 Dec 15:51:33.295 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo981:C 04 Dec 15:51:33.295 # Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=981, just started981:C 04 Dec 15:51:33.295 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf                _._                                                             _.-``__ &#x27;&#x27;-._                                                   _.-``    `.  `_.  &#x27;&#x27;-._           Redis 4.0.9 (00000000/0) 64 bit  .-`` .-```.  ```\\/    _.,_ &#x27;&#x27;-._                                    (    &#x27;      ,       .-`  | `,    )     Running in standalone mode |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 6379 |    `-._   `._    /     _.-&#x27;    |     PID: 981  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                    |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                   |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io          `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                    |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                   |    `-._`-._        _.-&#x27;_.-&#x27;    |                                    `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                         `-._    `-.__.-&#x27;    _.-&#x27;                                                 `-._        _.-&#x27;                                                         `-.__.-&#x27;                                               981:M 04 Dec 15:51:33.296 # Server initialized981:M 04 Dec 15:51:33.296 * DB loaded from disk: 0.000 seconds981:M 04 Dec 15:51:33.296 * Ready to accept connections\n\n修改进程守护 daemonize yes此时Redis服务已经可以成功启动了；但问题来了，界面一直停留在Redis服务窗口中，按Ctrl+C虽然可以屏蔽服务窗口，但同时也会结束Redis服务。Redis服务默认是前台运行，需要修改为后台运行；返回上一层目录，修改redis.conf配置文件。找到daemonize（守护进程）配置，默认no咱们修改了配置文件，但没告诉Redis读取最新的配置文件。启动服务的同时读取最新的配置文件root@Ubuntu:/usr/local/software/redis-4.0.9/src# ./redis-server ../redis.conf\n\nRedis默认只支持本地链接编辑redis.conf配置文件# bind 127.0.0.1protected-mode no\n\n修改完毕后保存,并且启动服务的同时读取最新的配置文件\n输入进程命令查看root@Ubuntu:/usr/local/software/redis-4.0.9/src# ps -ef | grep redisroot      1059     1  0 16:02 ?        00:00:00 ./redis-server *:6379root      1065  1013  0 16:04 pts/1    00:00:00 grep --color=auto redis\n\n编辑Linux关闭防火墙关闭防火墙\nsudo ufw disable\n开启防火墙\nsudo ufw enable\n查看当前防火墙状态(inactive关闭状态 active开启状态)\nsudo ufw status\n\n添加安全组规则根据自己购买的ECS平台添加安全组规则","categories":["linux","Redis","RedisDesktopManage"],"tags":["linux","Redis","RedisDesktopManage"]},{"title":"RocketMQ4.x本地源码部署","url":"/2019/05/05/RocketMQ4-x%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2/","content":"安装前提条件(推荐)64bit OS&#x2F;Linux&#x2F;Unix&#x2F;Mac&#x2F;(Windows不兼容)\n64bit JDK 1.8+\n快速开始本快速入门指南是在本地计算机上设置RocketMQ消息传递系统以发送和接收消息的详细说明。\n下载安装包wget http://mirror.bit.edu.cn/apache/rocketmq/4.4.0/rocketmq-all-4.4.0-source-release.zip\n\n\n\n解压并编译unzip rocketmq-all-4.4.0-source-release.zipcd rocketmq-all-4.4.0/mvn -Prelease-all -DskipTests clean install -Ucd distribution/target/apache-rocketmq\n最终路径 distribution/target/apache-rocketmq\n启动nameServernohup sh bin/mqnamesrv &amp;\n\n查看日志tail -f nohup.out\n结尾为 The Name Server boot success. serializeType=JSON 说明启动成功\nJava HotSpot(TM) 64-Bit Server VM warning: Using the DefNew young collector with the CMS collector is deprecated and will likely be removed in a future releaseJava HotSpot(TM) 64-Bit Server VM warning: UseCMSCompactAtFullCollection is deprecated and will likely be removed in a future release.The Name Server boot success. serializeType=JSON\n部署问题Please set the JAVA_HOME variable in your environment, We need java(x64)解决: 本地需要配置 JAVA_HOME 环境变量\necho $JAVA_HOME/usr/local/software/jdk8\n\nLinux系统jdk配置见 linux下使用wget下载jdk8\nexport JAVA_HOME=/usr/local/software/jdk8export MAVEN_HOME=/usr/local/software/apache-maven-3.3.9export JAVA_BIN=/usr/local/software/jdk8export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME MAVEN_HOME JAVA_BIN PATH CLASSPATH\n\n启动broker-n 指定 nameserver 地址, nameserver服务端口号为 9876, broker 默认端口号 10911\nnohup sh bin/mqbroker -n localhost:9876 &amp;\n\nRocketMQ的broker启动失败解决进入 bin 目录 apache-rocketmq/bin\n修改runbroker.shvim runbroker.sh\n将第一个JAVA_OPT改成\nJAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m&quot;\n\n修改runserver.shvim runserver.sh\n将第一个JAVA_OPT改成\nJAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms128m -Xmx256m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;\n\n关闭 broker nameserver 执行的命令sh bin/mqshutdown brokersh bin/mqshutdown namesrv\n\n使用jps查看进程jps\n\n验证是否成功# 设置名称服务地址export NAMESRV_ADDR=localhost:9876# 投递消息sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer# 消费消息sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer\n","categories":["消息队列","RocketMQ"],"tags":["wget","RocketMQ","消息队列"]},{"title":"SSR搭建梯子(VPS)教程","url":"/2019/03/19/SSR%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90-VPS-%E6%95%99%E7%A8%8B/","content":"VPS用途VPS虚拟服务器技术可以通过多种不同的方式灵活地分配服务器资源，每个虚拟化服务器的资源都可以有很大的不同，可以灵活的满足各种高端用户的需求。通过在一台服务器上创建10个左右的VPS主机，可以确保每一个虚拟主机的用户独享VPS资源，其运行和管理完全和独立主机相同。VPS主机可以为高端用户提供安全、可靠、高品质的主机服务。\n\n\n创建服务器 Vultr登录官网自行注册,并选择支付宝充值10美金,不想充钱的可以绕道了,不用往下看了\n点击Server栏目找到里面的 + 按钮 Deploy New Server 新增服务器 会跳转到\n部署新实例Server Location选择自己服务器地区\nServer Type服务器类型选择: CentOS 7x64\nServer Size这个不多说,有钱土豪的随便选,没钱的最左边最便宜的\nDeploy New其他的都不用管,直接点击最下面的Deploy New\n进入服务器自己想办法进去Linux系统服务器,百度一堆\n执行安装SSR指令wget --no-check-certificate https://freed.ga/github/shadowsocksR.sh; bash shadowsocksR.sh\n如提示:\nwget :com.m.and not found\n请执行:\nyum install wget -y\n最后等着就行了\n安装SSTapSSTap是SocksCap64作者新开发的一款利用虚拟网卡实现的网络层代理。SSTap能在网络层拦截所有连接并转发给HTTP，SOCKS4，5，SHADOWSOCKS代理.而无需对被代理的应用程序做任何修改或设置。它能同时转发TCP, UDP数据包。它非常适合于游戏玩家使用。享受你的游戏时光！请使用SSTap！\nSSR常用命令启动/etc/init.d/shadowsocks start\n停止/etc/init.d/shadowsocks stop\n重启/etc/init.d/shadowsocks restart\n状态/etc/init.d/shadowsocks status\nSSR修改密码、配置多端口vim /etc/shadowsocks.json\n修改后进行重启/etc/init.d/shadowsocks restart\n如不能联网,则关闭防火墙 逐条输入service iptables restartservice iptables stopchkconfig iptables off\n","categories":["VPN"],"tags":["SSR","VPN","VPS"]},{"title":"Scheduled 定时任务","url":"/2019/03/27/Scheduled-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","content":"启动类 添加 EnableScheduling 注解@SpringBootApplication@EnableScheduling   // 定时任务public class ScheduApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ScheduApplication.class, args);    &#125;&#125;\n\n\n\n服务层 添加 Component 和 Scheduled 注解import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class ScheduledServiceImpl &#123;    @Scheduled(cron = &quot;0 0/25 2 * * ? *&quot;) // 凌晨2:00-2:59开始,每二十五分钟执行一次    public void printSay() &#123;        System.out.println(&quot;This is a say method!&quot; + new Date());    &#125;&#125;\n在线Cron表达式生成器规则字段　　允许值　　允许的特殊字符 秒     　 0-59 　　　　, - * / 分     　 0-59　　　　 , - * / 小时      0-23 　　　　, - * / 日期      1-31 　　　　, - * ? / L W C 月份      1-12 　　　　, - * / 星期      1-7 　　　　  , - * ? / L C # 年     1970-2099 　　, - * /\n星期(1-7)可对应(SUN，MON，TUE，WED，THU，FRI，SAT)\n解析0/5 * * * * ? 每5秒执行一次\n*字符被用来指定所有的值。如：*在分钟的字段域里表示每分钟。 ?字符只在日期域和星期域中使用。它被用来指定非明确的值。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。 月份中的日期和星期中的日期这两个元素时互斥的一起应该通过设置一个问号来表明不想设置那个字段。\n-字符被用来指定一个范围。如：10-12在小时域意味着10点、11点、12点。\n,字符被用来指定另外的值。如：MON,WED,FRI在星期域里表示星期一、星期三、星期五。\n/字符用于指定增量。如：0/15在秒域意思是每分钟的0，15，30和45秒。5/15在分钟域表示每小时的5，20，35和50。 符号*在/前面（如：*/10）等价于0在/前面（如：0&#x2F;10）。记住一条本质：表达式的每个数值域都是一个有最大值和最小值的集合，如： 秒域和分钟域的集合是0-59，日期域是1-31，月份域是1-12。字符/可以帮助你在每个字符域中取相应的数值。如：7/6在月份域的时候只 有当7月的时候才会触发，并不是表示每个6月。\nL是‘last’的省略写法可以表示day-of-month和day-of-week域，但在两个字段中的意思不同，例如day-of- month域中表示一个月的最后一天。如果在day-of-week域表示‘7’或者‘SAT’，如果在day-of-week域中前面加上数字，它表示 一个月的最后几天，例如‘6L’就表示一个月的最后一个星期五。\n字符W只允许日期域出现。这个字符用于指定日期的最近工作日。例如：如果你在日期域中写 15W，表示：这个月15号最近的工作日。所以，如果15号是周六，则任务会在14号触发。如果15好是周日，则任务会在周一也就是16号触发。如果 是在日期域填写1W即使1号是周六，那么任务也只会在下周一，也就是3号触发，W字符指定的最近工作日是不能够跨月份的。字符W只能配合一个 单独的数值使用，不能够是一个数字段，如：1-15W是错误的。\nL和W可以在日期域中联合使用，LW表示这个月最后一周的工作日。\n字符#只允许在星期域中出现。这个字符用于指定本月的某某天。例如：6#3表示本月第三周的星期五（6表示星期五，3表示第三周）。2#1表示本月第一周的星期一。4#5表示第五周的星期三。\n字符C允许在日期域和星期域出现。这个字符依靠一个指定的日历。也就是说这个表达式的值依赖于相关的日历的计算结果，如果没有日历 关联，则等价于所有包含的日历。如：日期域是5C表示关联日历中第一天，或者这个月开始的第一天的后5天。星期域是1C表示关联日历 中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）。\n例子0 0 10,14,16 * * ? 每天上午10点，下午2点，4点0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时0 0 12 ? * WED 表示每个星期三中午12点 0 0 12 * * ? 每天中午12点触发 0 15 10 ? * * 每天上午10:15触发 0 15 10 * * ? 每天上午10:15触发 0 15 10 * * ? * 每天上午10:15触发 0 15 10 * * ? 2005 2005年的每天上午10:15触发 0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 15 10 15 * ? 每月15日上午10:15触发 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发\n","categories":["Scheduled"],"tags":["Scheduled","定时任务"]},{"title":"Sentinel流量限流熔断降级控制Docker容器化部署","url":"/2021/12/07/Sentinel%E6%B5%81%E9%87%8F%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E6%8E%A7%E5%88%B6Docker%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","content":"Docker Hub 仓库地址拉取镜像docker pull bladex/sentinel-dashboard\n\n\n\n运行镜像docker run --name sentinel -d -p 8858:8858 -d bladex/sentinel-dashboard\n\n列出容器docker ps\n\n查看日志docker logs -f $&#123;CONTAINER ID&#125;\n\n访问Sentinel记得开放阿里云的网络安全组\nhttp://localhost:8858\n默认登录密码sentinel/sentinel\n\n持久化Sentinel在生产环境中使用 Sentinel\n\n\n推送模式\n说明\n优点\n缺点\n\n\n\n原始模式\nAPI 将规则推送至客户端并直接更新到内存中，扩展写数据源（WritableDataSource）\n简单，无任何依赖\n不保证一致性；规则保存在内存中，重启即消失。严重不建议用于生产环境\n\n\nPull 模式\n扩展写数据源（WritableDataSource）， 客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 RDBMS、文件 等\n简单，无任何依赖；规则持久化\n不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题。\n\n\nPush 模式\n扩展读数据源（ReadableDataSource），规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用 Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证。生产环境下一般采用 push 模式的数据源。\n规则持久化；一致性；快速\n引入第三方依赖\n\n\nSentinel流控规则持久化到nacos配置中心引入maven依赖 pom.xml&lt;!--sentinel流控规则持久化到nacos配置中心--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置 application.ymlspring:  application:    name: api-gateway  #nacos配置  cloud:    #注册中心地址    nacos:      discovery:        server-addr: 127.0.0.1:8848    #限流熔断    sentinel:      transport:        dashboard: 127.0.0.1:8858  #控制台端口        #本地启的端口, 随机选个不能被占用的, 与dashboard进行数据交互, 会在应用对应机器上启动一个 HttpServer, 该 Server 会与 Sentinel 控制台做交互, 若被占用, 则开始+1一次扫描        port: 9999      #sentinel流控规则持久化到nacos配置中心      datasource:        ds1:          nacos:            server-addr: 127.0.0.1:8848            data-id: $&#123;spring.application.name&#125;.json            group-id: DEFAULT_GROUP            data-type: json            rule-type: flow\n\n配置nacos配置中心新建配置 $&#123;spring.application.name&#125;.json\nSentinel配置文档\n示例配置\n[    &#123;        &quot;resource&quot;:&quot;/api/v1/page&quot;,        &quot;controlBehavior&quot;:0,        &quot;count&quot;:1,        &quot;grade&quot;:1,        &quot;limitApp&quot;:&quot;default&quot;,        &quot;strategy&quot;:0    &#125;,    &#123;        &quot;resource&quot;:&quot;/api/v2/page&quot;,        &quot;controlBehavior&quot;:0,        &quot;count&quot;:2,        &quot;grade&quot;:1,        &quot;limitApp&quot;:&quot;default&quot;,        &quot;strategy&quot;:0    &#125;]\n规则的种类Sentinel 的所有规则都可以在内存态中动态地查询及修改，修改之后立即生效。同时 Sentinel 也提供相关 API，供您来定制自己的规则策略。\nSentinel 支持以下几种规则：流量控制规则、熔断降级规则、系统保护规则、来源访问控制规则 和 热点参数规则。\n流量控制规则 (FlowRule)流量规则的定义\n\n\nField\n说明\n默认值\n\n\n\nresource\n资源名，资源名是限流规则的作用对象\n\n\n\ncount\n限流阈值\n\n\n\ngrade\n限流阈值类型，QPS 模式（1）或并发线程数模式（0）\nQPS 模式\n\n\nlimitApp\n流控针对的调用来源\ndefault，代表不区分调用来源\n\n\nstrategy\n调用关系限流策略：直接、链路、关联\n根据资源本身（直接）\n\n\ncontrolBehavior\n流控效果（直接拒绝&#x2F;WarmUp&#x2F;匀速+排队等待），不支持按调用关系限流\n直接拒绝\n\n\nclusterMode\n是否集群限流\n否\n\n\n同一个资源可以同时有多个限流规则，检查规则时会依次检查。\n通过代码定义流量控制规则理解上面规则的定义之后，我们可以通过调用 FlowRuleManager.loadRules() 方法来用硬编码的方式定义流量控制规则，比如：\nprivate void initFlowQpsRule() &#123;    List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();    FlowRule rule = new FlowRule(resourceName);    // set limit qps to 20    rule.setCount(20);    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);    rule.setLimitApp(&quot;default&quot;);    rules.add(rule);    FlowRuleManager.loadRules(rules);&#125;\n\n熔断降级规则 (DegradeRule)熔断降级规则包含下面几个重要的属性：\n\n\n\nField\n说明\n默认值\n\n\n\nresource\n资源名，即规则的作用对象\n\n\n\ngrade\n熔断策略，支持慢调用比例&#x2F;异常比例&#x2F;异常数策略\n慢调用比例\n\n\ncount\n慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例&#x2F;异常数模式下为对应的阈值\n\n\n\ntimeWindow\n熔断时长，单位为 s\n\n\n\nminRequestAmount\n熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）\n5\n\n\nstatIntervalMs\n统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）\n1000 ms\n\n\nslowRatioThreshold\n慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）\n\n\n\n同一个资源可以同时有多个降级规则。\n理解上面规则的定义之后，我们可以通过调用 DegradeRuleManager.loadRules() 方法来用硬编码的方式定义流量控制规则。\nprivate void initDegradeRule() &#123;    List&lt;DegradeRule&gt; rules = new ArrayList&lt;&gt;();    DegradeRule rule = new DegradeRule();    rule.setResource(KEY);    // set threshold RT, 10 ms    rule.setCount(10);    rule.setGrade(RuleConstant.DEGRADE_GRADE_RT);    rule.setTimeWindow(10);    rules.add(rule);    DegradeRuleManager.loadRules(rules);&#125;\n\n系统保护规则 (SystemRule)Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。\n系统规则包含下面几个重要的属性：\n\n\n\nField\n说明\n默认值\n\n\n\nhighestSystemLoad\nload1 触发值，用于触发自适应控制阶段\n-1 (不生效)\n\n\navgRt\n所有入口流量的平均响应时间\n-1 (不生效)\n\n\nmaxThread\n入口流量的最大并发数\n-1 (不生效)\n\n\nqps\n所有入口资源的 QPS\n-1 (不生效)\n\n\nhighestCpuUsage\n当前系统的 CPU 使用率（0.0-1.0）\n-1 (不生效)\n\n\n理解上面规则的定义之后，我们可以通过调用 SystemRuleManager.loadRules() 方法来用硬编码的方式定义流量控制规则。\nprivate void initSystemRule() &#123;    List&lt;SystemRule&gt; rules = new ArrayList&lt;&gt;();    SystemRule rule = new SystemRule();    rule.setHighestSystemLoad(10);    rules.add(rule);    SystemRuleManager.loadRules(rules);&#125;\n\n注意系统规则只针对入口资源（EntryType&#x3D;IN）生效。更多详情可以参考 系统自适应保护文档。\n访问控制规则 (AuthorityRule)很多时候，我们需要根据调用方来限制资源是否通过，这时候可以使用 Sentinel 的访问控制（黑白名单）的功能。黑白名单根据资源的请求来源（origin）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。\n授权规则，即黑白名单规则（AuthorityRule）非常简单，主要有以下配置项：\n\nresource：资源名，即规则的作用对象\nlimitApp：对应的黑名单&#x2F;白名单，不同 origin 用 , 分隔，如 appA,appB\nstrategy：限制模式，AUTHORITY_WHITE 为白名单模式，AUTHORITY_BLACK 为黑名单模式，默认为白名单模式\n\n热点规则 (ParamFlowRule)详情可以参考 热点参数限流。\n","categories":["linux","centOS","docker","sentinel"],"tags":["linux","centOS","docker","sentinel"]},{"title":"Spring-Boot2.X 中 HTTPS 配置","url":"/2018/12/11/Spring-Boot2-X-%E4%B8%AD-HTTPS-%E9%85%8D%E7%BD%AE/","content":"Spring-Boot2.X 中 HTTPS 配置网上资料的错误在Spring Boot2.0以上配置嵌入式Servlet容器时EmbeddedServletContainerCustomizer类不存在,经查询发现被WebServerFactoryCustomizer替代.使用WebServerFactoryCustomizer接口替换EmbeddedServletContainerCustomizer组件完成对嵌入式Servlet容器的配置\n准备工作\n阿里云ECS\n域名\nSSL证书 (用于支持https)\nspringboot项目 (本文采用jar方式打包)\n\n  \n\n购买阿里云ECS配置安全组规则\n如果不配置安全组规则，我们将没法访问我们阿里云服务器 ，安全组中的 80/80 和 443/443 必须配置，因为只有这里配置了才能支持http和https访问我们的网站\n授权对象最好填 0.0.0.0/0\n\n配置https 申请SSL证书申请SSL证书是实现https必不可少的\n购买申请SSL证书地址在品牌里面你会发现 都没有免费证书 GeoTrust GlobalSign CFCA Symantec选择 Symantec 品牌 , 再选择证书类型:分别有 专业版OV SSL 通配符DV SSL 增强型OV SSL 就是没有免费的证书证书类型选择 增强型OV SSL 你会发现又多出了几个证书 其中就有 免费型DV SSL 然后买就对了\n通常审核10分钟左右就行，如果资料不全或者不真实可能就久些审核通过后，就去下载相应的SSL证书，由于springboot内置的是tomcat，所以这里下载tomcat对应的SSL证书\n解压后会得到 .pfx .txt 后缀的文件夹 , 将.pfx复制到项目资源文件根目录并配置 配置文件 以.yml后缀配置文件为例\nhttp:  port: 80server:  port: 443  ssl:    key-store: classpath:*.pfx    key-store-password: password\nkey-store 填写复制到项目资源文件根目录的 .pfx 文件路径 . 因为在资源文件根目录所以填写 classpath: + 文件名.pfxkey-store-password 填写解压.txt后缀的文本内容\nHTTP自动转向HTTPS在springboot启动类 Application 加上以下配置代码\nimport org.apache.catalina.Context;import org.apache.catalina.connector.Connector;import org.apache.tomcat.util.descriptor.web.SecurityCollection;import org.apache.tomcat.util.descriptor.web.SecurityConstraint;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.ConfigurableWebServerFactory;import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.context.annotation.Bean;import static org.springframework.boot.web.embedded.tomcat.TomcatReactiveWebServerFactory.DEFAULT_PROTOCOL;@SpringBootApplicationpublic class Application &#123;    // 监听的http请求的端口,需要在application配置中添加http.port=端口号  如80    @Value(&quot;$&#123;http.port&#125;&quot;)    Integer httpPort;    //正常启用的https端口 如443    @Value(&quot;$&#123;server.port&#125;&quot;)    Integer httpsPort;    public static void main(String[] args) &#123;        SpringApplication.run(BbsApplication.class, args);    &#125;    // 拦截所有请求    @Bean    public TomcatServletWebServerFactory servletContainer() &#123;        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() &#123;            @Override            protected void postProcessContext(Context context) &#123;                SecurityConstraint constraint = new SecurityConstraint();                constraint.setUserConstraint(&quot;CONFIDENTIAL&quot;);                SecurityCollection collection = new SecurityCollection();                collection.addPattern(&quot;/*&quot;);                constraint.addCollection(collection);                context.addConstraint(constraint);            &#125;        &#125;;        tomcat.addAdditionalTomcatConnectors(httpConnector());        return tomcat;    &#125;    //配置http转https    @Bean    public Connector httpConnector() &#123;        Connector connector = new Connector(DEFAULT_PROTOCOL);        connector.setScheme(&quot;http&quot;);        //Connector监听的http的端口号        connector.setPort(httpPort);        connector.setSecure(false);        //监听到http的端口号后转向到的https的端口号        connector.setRedirectPort(httpsPort);        return connector;    &#125;    /**     * //这里设置默认端口为443，即https的，如果这里不设置，会https和http争夺80端口     */    @Bean    public WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer() &#123;        return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() &#123;            @Override            public void customize(ConfigurableWebServerFactory factory) &#123;                factory.setPort(443);            &#125;        &#125;;    &#125;&#125;\n","categories":["springboot","https"],"tags":["http","springboot","https","80","443"]},{"title":"SpringBoot跨域配置，解决跨域上传文件","url":"/2018/12/06/SpringBoot%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","content":"SpringBoot跨域配置，解决跨域上传文件\n\n@SpringBootApplicationpublic class Application &#123;    private CorsConfiguration buildConfig() &#123;        CorsConfiguration corsConfiguration = new CorsConfiguration();        corsConfiguration.addAllowedOrigin(&quot;*&quot;);        corsConfiguration.addAllowedHeader(&quot;*&quot;);        corsConfiguration.addAllowedMethod(&quot;*&quot;);        corsConfiguration.setAllowCredentials(true);//这两句不加不能跨域上传文件        corsConfiguration.setMaxAge(3600l);//加上去就可以了        return corsConfiguration;    &#125;    /**     * 跨域过滤器     */    @Bean    public CorsFilter corsFilter() &#123;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); // 4        return new CorsFilter(source);    &#125;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n","categories":["springboot","跨域配置"],"tags":["springboot","跨域配置"]},{"title":"SpringMVC JSON传递参数 多视图解析 自定义类型转换 拦截器","url":"/2018/07/25/SpringMVC%20JSON%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%20%E5%A4%9A%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%20%E6%8B%A6%E6%88%AA%E5%99%A8/","content":"springMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2(一般老项目使用)等。\n\n\n返回结果为Bean对象，name又如何转换成JSON对象输出？Controller层@RequestMapping(value = &quot;/showJson&quot;)//,produces = &#123;&quot;application/json;charset=utf-8&quot;&#125;)@ResponseBodypublic String showJson()&#123;    UserMessage um = new UserMessage();    um.setError(&quot;exception&quot;);    um.setMessage(&quot;异常&quot;);    //return &quot;&#123;\\&quot;error\\&quot;:\\&quot;exception\\&quot;,\\&quot;message\\&quot;:\\&quot;异常\\&quot;&#125;&quot;;    return JSON.toJSONString(um);&#125;\n在上述代码中，通过\n@RequestMapping\n指定请求的URL。通过\n@ResponseBody\n来进行处理结果的输出。在方法体内，通过um对象将um转换成JSON格式的字符串。\n解决JSON数据传递的中文乱码问题局部指定的编码集，如上述代码注释的部分produces = &#123;&quot;application/json;charset=utf-8&quot;&#125;\n\n\n在sringmvc-servlet.xml 中解决JSON数据传递的中文乱码问题：&lt;mvc:annotation-driven &gt;        &lt;mvc:message-converters&gt;            &lt;!--解决springmvc返回的json中文问题  --&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                &lt;constructor-arg value=&quot;utf-8&quot; /&gt;            &lt;/bean&gt;            &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;                &lt;property name=&quot;supportedMediaTypes&quot;&gt;                    &lt;list&gt;                        &lt;value&gt;application/json&lt;/value&gt;                    &lt;/list&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;\n\n解决JSON数据传递的日期格式问题在SpringMVC中使用@ResponseBody返回JSON数据是，日期默认显示为时间戳。如(512323200000)，我们需要把他转换成具有可读性的 ‘yyyy-MM-dd’ 日期格式（如1986-02-28）具体的解决方案有两种：\n1) 注解方式在属性上加\n@JSONfield(format=&quot;yyyy-MM-dd&quot;)\n\n\n2)配置FastJosn消息 转换器————FastJsonHttpMessageConverter：此方式默认格式为 yyyy-MM-dd HH:mm:ss\n&lt;mvc:annotation-driven &gt;        &lt;mvc:message-converters&gt;            &lt;!--解决springmvc返回的json中文问题  --&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                &lt;constructor-arg value=&quot;utf-8&quot; /&gt;            &lt;/bean&gt;            &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;                &lt;property name=&quot;supportedMediaTypes&quot;&gt;                    &lt;list&gt;                        &lt;value&gt;application/json&lt;/value&gt;                    &lt;/list&gt;                &lt;/property&gt;                &lt;property name=&quot;features&quot;&gt;                    &lt;list&gt;                    \t&lt;!--输出Date的日期转换器--&gt;                        &lt;value&gt;WriteDateUseDateFormat&lt;/value&gt;                    &lt;/list&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;\n\n单独配置JSP解析器&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt;\n\n多视图解析器导入XML生成的jar包&lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;      &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n配置springmvc-servlet&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;        &lt;!-- 指定JSON用什么工具解析  XML用什么工具解析--&gt;        &lt;property name=&quot;defaultViews&quot;&gt;            &lt;list&gt;                &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonJsonView&quot;&gt;                    &lt;property name=&quot;charset&quot; value=&quot;UTF-8&quot;/&gt;                &lt;/bean&gt;                &lt;bean class=&quot;org.springframework.web.servlet.view.xml.MarshallingView&quot;&gt;                    &lt;constructor-arg&gt;                        &lt;bean class=&quot;org.springframework.oxm.jaxb.Jaxb2Marshaller&quot;&gt;                            &lt;property name=&quot;classesToBeBound&quot;&gt;                                &lt;list&gt;                                    &lt;value&gt;com.entity.SmbmsUser&lt;/value&gt;                                    &lt;value&gt;com.entity.SmbmsProvider&lt;/value&gt;                                    &lt;value&gt;com.entity.SmbmsBill&lt;/value&gt;                                    &lt;value&gt;com.entity.SmbmsRole&lt;/value&gt;                                    &lt;value&gt;com.entity.SmbmsAddress&lt;/value&gt;                                &lt;/list&gt;                            &lt;/property&gt;                        &lt;/bean&gt;                    &lt;/constructor-arg&gt;                &lt;/bean&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;!-- 指定jsp解析器--&gt;        &lt;!--在此配置jsp解析器后，不需要再配置专门的解析器--&gt;        &lt;property name=&quot;viewResolvers&quot;&gt;            &lt;list&gt;                &lt;bean   class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;                    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;                    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;                &lt;/bean&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;\n\n自定义类型转换器单个格式转换&lt;bean name=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;        &lt;property name=&quot;converters&quot;&gt;            &lt;set&gt;                &lt;bean class=&quot;com.converter.DataConverter&quot; p:dataPatter=&quot;yyyy-MM-dd&quot; /&gt;            &lt;/set&gt;        &lt;/property&gt;&lt;/bean&gt;&lt;!--覆盖默认的ConversionService--&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; /&gt;\npublic class DataConverter implements Converter&lt;String,Date&gt; &#123;    private String dataPatter;    public void setDataPatter(String dataPatter) &#123;        this.dataPatter = dataPatter;    &#125;    public Date convert(String s) &#123;        Date data = null;        try &#123;            data = new SimpleDateFormat(dataPatter).parse(s);        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return data;    &#125;&#125;\n多个格式转换&lt;bean name=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;set&gt;            &lt;!--&lt;bean class=&quot;com.converter.DataConverter&quot; p:dataPatter=&quot;yyyy-MM-dd&quot;/&gt;--&gt;            &lt;bean class=&quot;com.converter.DataConverters&quot;&gt;                &lt;property name=&quot;dataPatters&quot;&gt;                    &lt;array&gt;                        &lt;value&gt;yyyy-MM-dd&lt;/value&gt;                        &lt;value&gt;yyyy/MM/dd&lt;/value&gt;                        &lt;value&gt;yyyy MM dd&lt;/value&gt;                    &lt;/array&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!--覆盖默认的ConversionService--&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; /&gt;\npublic class DataConverters implements Converter&lt;String, Date&gt; &#123;    private String[] dataPatters;    public Date convert(String s) &#123;        Date date = null;        for (String dataPatter : dataPatters) &#123;            try &#123;                date = new SimpleDateFormat(dataPatter).parse(s);                //转换成功出循环                break;            &#125; catch (ParseException e) &#123;                System.out.println(e.getMessage());                //转换失败进入下次循环                continue;            &#125;        &#125;        return date;    &#125;    public void setDataPatters(String[] dataPatters) &#123;        this.dataPatters = dataPatters;    &#125;&#125;\n\n拦截器&lt;!--拦截器配置--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--拦截所有url请求--&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;!--放过登录方法--&gt;        &lt;mvc:exclude-mapping path=&quot;/login&quot;/&gt;        &lt;!--放过 样式，图片 等请求路径--&gt;        &lt;mvc:exclude-mapping path=&quot;/css/**&quot;/&gt;        &lt;mvc:exclude-mapping path=&quot;/images/**&quot;/&gt;        &lt;mvc:exclude-mapping path=&quot;/js/**&quot;/&gt;        &lt;bean class=&quot;com.interceptor.MyInterceptor&quot;/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\nimport org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor extends HandlerInterceptorAdapter &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;one&quot;);        Object userSession = request.getSession().getAttribute(&quot;userSession&quot;);        if (null == userSession) &#123;            response.sendRedirect(&quot;/login&quot;);            //返回false 不会进入 two three            return false;        &#125;        return super.preHandle(request, response, handler);    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;two&quot;);        super.postHandle(request, response, handler, modelAndView);    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;three&quot;);        super.afterCompletion(request, response, handler, ex);    &#125;&#125;\n\n示例下载 密码: ksqj","categories":["springMVC"],"tags":["springMVC","JSON","多视图解析","自定义类型转换","拦截器","ajax"]},{"title":"SpringCloud连接远程nacos报错, 一直提示连接本地localhost:8848","url":"/2021/12/07/SpringCloud%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8Bnacos%E6%8A%A5%E9%94%99-%E4%B8%80%E7%9B%B4%E6%8F%90%E7%A4%BA%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0localhost-8848/","content":"console[NACOS ConnectException httpPost] currentServerAddr: http://localhost:8848, err : Connection refused: connect\n\n\n\napplication.ymlspring:  application:    #服务名    name: gateway  #nacos配置  cloud:    #注册中心地址    nacos:      discovery:        server-addr: xxx.xxx.xxx.xxx:8848\n\nbootstrap.yml在resources下创建: bootstrap.ymlbootstrap.yml 比 application.yml 提前执行\n#nacos configspring:  application:    #服务名    name: gateway  cloud:    nacos:      config:        server-addr: xxx.xxx.xxx.xxx:8848\n","categories":["springcloud","gateway","nacos"],"tags":["springcloud","gateway","nacos"]},{"title":"SpringMVC 文件上传 验证框架","url":"/2018/07/25/SpringMVC-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%20%E9%AA%8C%E8%AF%81%E6%A1%86%E6%9E%B6/","content":"springMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2(一般老项目使用)等。\n\n\n文件上传编写工具类public class FileUtil &#123;    /**     * 创建目录     * @param path     */    public static void createDir(String path)&#123;        File file = new File(path);        if(!file.exists())&#123;            file.mkdirs();        &#125;    &#125;&#125;\n\nhtml标签&lt;input type=&quot;file&quot; name=&quot;imgFile&quot; /&gt;\n\n在Controller中编写方法//文件上传    @RequestMapping(&quot;/uploadImg.html&quot;)    public String uploadImg(User user, MultipartFile imgFile, HttpSession session)&#123;        System.out.println(session.getServletContext().getRealPath(&quot;upload&quot;));        //获取上传文件的文件名字        System.out.println(imgFile.getOriginalFilename());        //获取保存文件的目录        String path = session.getServletContext().getRealPath(&quot;upload&quot;);        System.out.println(path);        //创建目录        FileUtil.createDir(path);        //文件保存路径        File outFile = new File(path, imgFile.getOriginalFilename());        try &#123;            imgFile.transferTo(outFile);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return &quot;/index&quot;;    &#125;\n\nXML配置&lt;!--上传文件必备--&gt;&lt;bean name=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;        &lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot; /&gt; &lt;!--单位字节--&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;    &lt;/bean&gt;\n\n文件上传必备jar包&lt;!--文件上传  必备1--&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-io&lt;/groupId&gt;      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;      &lt;version&gt;2.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;      &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;      &lt;version&gt;1.2.2&lt;/version&gt;    &lt;/dependency&gt;\n\n验证框架必备jar包&lt;!--验证框架的jar包--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;      &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;      &lt;version&gt;4.3.2.Final&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;      &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;      &lt;version&gt;4.3.2.Final&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt;      &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt;      &lt;version&gt;3.1.0.CR2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.validation&lt;/groupId&gt;      &lt;artifactId&gt;validation-api&lt;/artifactId&gt;      &lt;version&gt;1.0.0.GA&lt;/version&gt;    &lt;/dependency&gt;\n配合使用的注解(注解标记在实体类属性上)@NotEmpty(message&#x3D;””) (验证注解的元素值不为null且不为空,字符串长度不为0、集合大小不为0)@Null(message&#x3D;””) (被注释的元素必须为null)@NotNull(message&#x3D;””) (被注释的元素必须不为null)@Length(min&#x3D;””,max&#x3D;””,message&#x3D;””) ()@AssertTrue(message&#x3D;””) (被注释的元素必须为true)@AssertFalse(message&#x3D;””) (被注释的元素必须为false)@Min(value,message&#x3D;””) (被注释的元素必须是一个数字，其值必须大于等于指定的最小值)@Max(value,message&#x3D;””) (被注释的元素必须是一个数字，其值必须小于于等于指定的最大值)@DecimalMin(value,message&#x3D;””) (被注释的元素必须是一个数字，其值必须大于等于指定的最小值)@DecimalMax(value,message&#x3D;””) (被注释的元素必须是一个数字，其值必须小于等于指定的最大值)@Size(max,min,message&#x3D;””) (被注释的元素的大小必须在指定的范围内)@Digits(integer&#x3D;整数位数, fraction&#x3D;小数位数,message&#x3D;””) (验证注解的元素值的整数位数和小数位数上限)@Past(message&#x3D;””) (被注释的元素必须是一个过去的日期)@Future(message&#x3D;””) (被注释的元素必须是一个将来的日期)@Pattern(value,message&#x3D;””) (被注释的元素必须符合指定的正则表达式)\nController代码示例@RequestMapping(&quot;/saveUser.html&quot;)   //@valid注解标识的参数后方，必须紧跟BindingResult   public String saveUser(@Valid User u, BindingResult br)&#123;       if(br.hasErrors())&#123;           return &quot;error&quot;;       &#125;       userService.addUser(new User(&quot;Simon&quot;));       return &quot;index&quot;;   &#125;\n\n\najax展示调用验证@RequestMapping(&quot;/addUserVerify&quot;)    @ResponseBody    public Object addUserVerify(@Valid SmbmsUser user, BindingResult br)&#123;        if(br.hasErrors())&#123;            List&lt;FieldError&gt; fieldErrors = br.getFieldErrors();            //fieldErrors.get(0).getField();   得到出现错误的属性名称            //fieldErrors.get(0).getDefaultMessage(); 得到错误消息            return fieldErrors;        &#125;        return null;    &#125;\n\nvar flag;function abc() &#123;    $.ajax(&#123;        type:&quot;POST&quot;,//请求类型        url:&quot;/addUserVerify&quot;,//请求的url        data:&#123;userCode:$(&quot;#userCode&quot;).val(),userPassword:$(&quot;#userPassword&quot;).val()&#125;,//请求参数        dataType:&quot;json&quot;,//ajax接口（请求url）返回的数据类型        async:false,        success:function(data)&#123;//data：返回数据（json对象）            if(data != null)&#123;                //在html页面创建一个标签  名字和错误的键名一致  然后循环放入错误消息                for(var i = 0; i &lt; data.length; i++)&#123;                    var temp = $(&quot;#&quot;+data[i].field);                    var msg = data[i].defaultMessage;                    temp.next().html(msg);                &#125;                flag = false;            &#125;else&#123;                flag = true;            &#125;        &#125;    &#125;);    return flag;&#125;\n","categories":["springMVC"],"tags":["springMVC","文件上传","验证框架"]},{"title":"Struts2 与 Servlet API 解耦,耦合的访问方式","url":"/2018/05/15/Struts2-%E4%B8%8E-Servlet-API-%E8%A7%A3%E8%80%A6-%E8%80%A6%E5%90%88%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/","content":"与Servlet API解耦的访问方式为了避免与Servlet API耦合在一起，方便Action类做单元测试，Struts2对HttpServletRequest、HttpSession和ServletContext进行了封装，构造了三个Map对象来替代这三种对象，在Action中，直接使用HttpServletRequest、HttpSession、ServletContext对应的Map对象来保存和读取数据。要获得这三个Map对象，可以使用com.opensymphony.xwork2.ActionContext类\n\n\nActionContext - 请求上下文　。就是struts2封装的request.包含了request,session,application上面这三个都是Map//导包import com.opensymphony.xwork2.ActionContext;import java.util.Map;//常量import static org.apache.struts2.StrutsStatics.HTTP_REQUEST;import static org.apache.struts2.StrutsStatics.HTTP_RESPONSE;Map&lt;String, Object&gt; session = ActionContext.getContext().getSession();Map&lt;String, Object&gt; request = (Map&lt;String, Object&gt;) ActionContext.getContext().get(HTTP_REQUEST);Map&lt;String, Object&gt; response = (Map&lt;String, Object&gt;) ActionContext.getContext().get(HTTP_RESPONSE);\n\n与Servlet API耦合的访问方式直接访问 Servlet API将使Action类与Servlet API耦合在一起，Servlet API对象均由Servlet容器来构造，与这些对象绑定在一起，测试过程中就必须有Servlet容器，这样不便于Action类的测试，但有时候，确实需要访问这些对象，Struts2同样提供了直接访问ServletAPI对象的方式\n要直接获取Servlet API对象可以使用org.apache.struts2.ServletActionContext类，该类是ActionContext类的子类import org.apache.struts2.ServletActionContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public HttpServletRequest request = ServletActionContext.getRequest();public HttpServletResponse response = ServletActionContext.getResponse();public HttpSession session = request.getSession(true);\n\n在实际开发中，可能多个页面需要得到这三个对象，为了避免代码冗余。创建一个 ActionBase 类package cn.action;import cn.pojo.User;import cn.util.Constants;import com.opensymphony.xwork2.ActionSupport;import org.apache.struts2.ServletActionContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class ActionBase extends ActionSupport &#123;    public HttpServletRequest request = ServletActionContext.getRequest();    public HttpServletResponse response = ServletActionContext.getResponse();    public HttpSession session = request.getSession(true);    public ActionBase() &#123;        //避免ajax提取数据中文乱码        response.setContentType(&quot;text/html;charset=UTF-8&quot;);    &#125;    public User getSessionUser() &#123;        Object o = session.getAttribute(Constants.USER_SESSION);        if (null == o)            return null;        return (User) o;    &#125;&#125;\n\nUSER_SESSION 为自定义的常量工具类 ConstantsUser 为用户对象实体类\n每个自定义的 action 类，都需要继承 ActionSupport 而 ActionBase 继承 ActionSupport 并新增想要的属性和方法以便需要继承的 ActionSupport 的类 直接继承 ActionBase\n新增属性上面代码可见新增了 request response session 的属性 这样就实现自己新增的属性以及 ActionSupport 的属性\n新增方法上面代码可见新增了 getSessionUser 的方法 这样就实现自己新增的方法以及 ActionSupport 的方法，以便自己可以直接提取存在会话的用户对象 User\n","categories":["struts2"],"tags":["struts2","Servlet API","解耦","耦合"]},{"title":"Struts2如何在Action与JSP之间传值","url":"/2017/06/29/Struts2%E5%A6%82%E4%BD%95%E5%9C%A8Action%E4%B8%8EJSP%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/","content":"struts2中Action到底是什么，怎么理解\n\n问题描述struts2中Action到底是什么，怎么理解1.配置完web.xml2.创建视图页面login.jsp3.创建业务控制器LoginAction类（解释说：创建业务控制器LoginAction类，该类为程序的Action类）4.配置LoginAction类（解释说：当Action处理完客户端请求后返回一个字符串，没个字符串对应一个视图）\n那么这个Action到底是什么，是一个类吗？怎么理解它，它和用于标签的有什么区别。\n解决方案首先，你了解Servlet么？Servlet是运行在java服务器端的java代码，这个Action本质就是Servlet啊。它作为java web应用的控制层，它完成浏览器的请求后返回一个页面给客户端浏览器。其次，action的处理流程是由strut2的中央控制器完成的，Action处理完客户端请求后返回一个字符串，每个字符串对应一个视图，也就是说它处理浏览器的请求的过程，返回的视图本质就是jsp页面。结论就是：action的本质就是Servlet。\nStruts2如何在Action与JSP之间传值pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;ActionValueOf&lt;/name&gt;    &lt;groupId&gt;com&lt;/groupId&gt;    &lt;artifactId&gt;ActionValueOf&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-core --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;            &lt;artifactId&gt;struts2-core&lt;/artifactId&gt;            &lt;version&gt;2.3.16.3&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\nUser 用户实体类package entity;public class User &#123;    private String username;    private String password;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;&#125;\n\nInfoActionpackage action;import com.opensymphony.xwork2.ActionSupport;import entity.User;public class InfoAction extends ActionSupport &#123;    private User user = new User();    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;&#125;\n\nindex.jspindex.jsp 只用于打开页面时先进入 action\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--meta标签在 index.jsp 打开后跳转到指定的 action--%&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=info.action&quot;/&gt;&lt;/body&gt;&lt;/html&gt;\n\ninfo.jspinfo.jsp 用一个页面来实现与 action 的相互传值,其中用 OGNL 来提取 action 实体类的值\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;info.action&quot;&gt;    用户名 : &lt;input type=&quot;text&quot; name=&quot;user.username&quot; value=&quot;&lt;s:property value=&quot;user.username&quot;/&gt;&quot;/&gt;    密　码 : &lt;input type=&quot;password&quot; name=&quot;user.password&quot; value=&quot;&lt;s:property value=&quot;user.password&quot;/&gt;&quot;/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;&lt;a href=&quot;info.action?user.username=Simon&amp;user.password=password&quot;&gt;利用script get方式进入action&lt;/a&gt;&lt;h1&gt;用户名 : &lt;s:property value=&quot;user.username&quot;/&gt;&lt;/h1&gt;&lt;h1&gt;密　码 : &lt;s:property value=&quot;user.password&quot;/&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n\nstruts.xml 配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;        &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt;    &lt;package name=&quot;default&quot; extends=&quot;struts-default&quot;&gt;        &lt;action name=&quot;info&quot; class=&quot;action.InfoAction&quot; method=&quot;execute&quot;&gt;            &lt;result&gt;info.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;\n\nweb.xml 配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.4&quot;         xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts&lt;/filter-name&gt;        &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;&lt;/web-app&gt;\n\n点击下载案例","categories":["struts2","Action"],"tags":["idea","OGNL","struts2","Action","传值"]},{"title":"Struts2拦截器实现用户访问控制","url":"/2017/06/14/Struts2%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","content":"拦截器 Interceptorjava里的拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。\n\n\n自定义拦截器自定义一个实现Interceptor接口（或者继承自AbstractInterceptor）的类。在struts.xml中注册上一步中定义的拦截器。在需要使用的Action中引用上述定义的拦截器，为了方便也可将拦截器定义为默认的拦截器，这样在不加特殊声明的情况下所有的Action都被这个拦截器拦截。与过滤器的区别过滤器可以简单理解为“取你所想取”，忽视掉那些你不想要的东西；拦截器可以简单理解为“拒你所想拒”，关心你想要拒绝掉哪些东西，比如一个BBS论坛上拦截掉敏感词汇。\n拦截器是基于java反射机制的，而过滤器是基于函数回调的。过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。拦截器只对action起作用，而过滤器几乎可以对所有请求起作用。拦截器可以访问action上下文、值栈里的对象，而过滤器不能。在action的生命周期里，拦截器可以多起调用，而过滤器只能在容器初始化时调用一次。关键代码package com.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;public class LoginInterceptor extends AbstractInterceptor &#123;    public String intercept(ActionInvocation actionInvocation) throws Exception &#123;        //得到session key为users 的数据        Object users = actionInvocation.getInvocationContext().getSession().get(&quot;users&quot;);        String name = actionInvocation.getInvocationContext().getName();        //得到访问action 的名字 login.action 得到 login        System.out.println(name);        //第一次登录时users 肯定为空,如果登录时找不到users 应该给它通过拦截器        if (null != users || &quot;login&quot;.equals(name))            //继续执行剩余的拦截器和action            return actionInvocation.invoke();        return &quot;login&quot;;    &#125;&#125;\n\nstruts.xml 拦截器配置&lt;struts&gt;    &lt;package name=&quot;default&quot; extends=&quot;struts-default&quot;&gt;        &lt;interceptors&gt;            &lt;!--定义权限验证拦截器--&gt;            &lt;interceptor name=&quot;sessionUser&quot; class=&quot;com.interceptor.LoginInterceptor&quot;&gt;&lt;/interceptor&gt;            &lt;interceptor-stack name=&quot;LoginFlag&quot;&gt;                &lt;interceptor-ref name=&quot;sessionUser&quot;/&gt;                &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;            &lt;/interceptor-stack&gt;        &lt;/interceptors&gt;        &lt;!--定义默认拦截器--&gt;        &lt;default-interceptor-ref name=&quot;LoginFlag&quot;/&gt;    &lt;/package&gt;&lt;/struts&gt;\n\n其中可以看到有一行配置 &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; defaultStack该拦截器用于实现数据的传输，如果不写的话会出现数据提取不到\n","categories":["struts2","idea","Interceptor","AbstractInterceptor"],"tags":["idea","struts2","拦截器","Interceptor"]},{"title":"Struts2的配置 struts.xml Action详解","url":"/2018/05/15/Struts2%E7%9A%84%E9%85%8D%E7%BD%AE-struts-xml-Action%E8%AF%A6%E8%A7%A3/","content":"struts.xml中的package的配置name:逻辑上的包名\nnamespace:命名空间，用来区分同意struts下的相同action（注意是一种逻辑上的的路径） 默认 /\nextends: 继承某个配置文件 默认 struts-default\n\n\n具体使用过程中要注意，有与命名空间的命名，我们要在相应的过程中加上对应的命名空间的路径，例如：&lt;s:form action=&quot;db/login.action&quot; method=&quot;post&quot;&gt;\n\n此代码说明的就是将会去调用db命名空间下的login对应的action\n标签的下的是物理路径（绝对路径），即指在项目中的实际位置，代码如下&lt;result name=&quot;success&quot;&gt;/login/error.jsp&lt;/result&gt;\n\nstruts.xml中的result的配置对于action的配置我这里面只是简单的概括，具体很多细节性的东西我将专门写一篇博客，主要讲解的动态的对action进行配置属性有：name:Action类的映射名称 默认值 success\nclass:Action类的完整路径\nmethod:默认使用的execute()方法，如果要自定义触发方法，需要使用method自定义 默认值 execute\nstruts.xml配置过程中的注意信息在实际开发的项目中，我们可能需要配置很多的action，有时候为了便于我们的分类，我们一般需要创建不同包下的struts-user.xml文件，不过最终我们的这些配置都是要导入进我们的struts.xml文件中。使用的标签和jsp编程中\nstruts.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;        &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt;    &lt;include file=&quot;struts-user.xml&quot;&gt;&lt;/include&gt;&lt;/struts&gt;\n\nstruts-user.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;        &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt;&lt;constant name=&quot;struts.ui.theme&quot; value=&quot;simple&quot;&gt;&lt;/constant&gt;  &lt;package name=&quot;user&quot; namespace=&quot;/db&quot; extends=&quot;struts-default&quot;&gt;      &lt;action name=&quot;login&quot; class=&quot;com.action.UserAction&quot;          method=&quot;execude2&quot;&gt;  &lt;!--result下的路径是物理路径 --&gt;          &lt;result name=&quot;success&quot;&gt;/login/success.jsp&lt;/result&gt;          &lt;result name=&quot;error&quot;&gt;/login/error.jsp&lt;/result&gt;      &lt;/action&gt;  &lt;/package&gt;  &lt;!-- 包名不能相同 --&gt;  &lt;package name=&quot;usertemp&quot; namespace=&quot;/temp&quot; extends=&quot;struts-default&quot;&gt;      &lt;action name=&quot;login&quot; class=&quot;com.action.UserAction&quot;          method=&quot;execude2&quot;&gt;  &lt;!--result下的路径是物理路径 --&gt;          &lt;result name=&quot;success&quot;&gt;/login/error.jsp&lt;/result&gt;          &lt;result name=&quot;error&quot;&gt;/login/success.jsp&lt;/result&gt;      &lt;/action&gt;  &lt;/package&gt;  &lt;/struts&gt;\n\nAction的动态结果的配置通过通配符实现，不同的类响应不同的类中的方法：&lt;action name=&quot;*_*&quot; class=&quot;com.action.&#123;1&#125;Action&quot; method=&quot;&#123;2&#125;&quot;&gt;    &lt;result &gt;/&#123;2&#125;.jsp&lt;/result&gt;&lt;/action&gt;\n\nUserAction.Javapublic class UserAction extends ActionSupport &#123;    private String nextResult;    ...&#125;\n\nStruts2.xml&lt;action name=&quot;user&quot; class=&quot;action.UserAction&quot;&gt;    &lt;result&gt;/&#123;nextResult&#125;&lt;/result&gt;&lt;/action&gt;\n","categories":["struts2","struts.xml"],"tags":["struts2","Action","struts.xml"]},{"title":"Struts2的配置和一个简单的例子","url":"/2017/06/07/Struts2%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/","content":"什么是Struts2Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。\n\n\n环境idea\ntomcat\njdk\nmaven\n\n步骤pom.xml 配置 Struts2点击前往获取自己想要的版本对应的XML\n&lt;dependencies&gt;    &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-core --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;        &lt;artifactId&gt;struts2-core&lt;/artifactId&gt;        &lt;version&gt;2.3.16.3&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建 User 类 用于展现提取对象的数据package com.entity;public class User &#123;    private String username;    private String password;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;&#125;\n\n创建 LoginAction 类 代替以往的 servlet 层package com.action;import com.entity.User;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import java.util.Map;//继承 ActionSupport 用于实现 servlet层 数据校验public class LoginAction extends ActionSupport implements Action &#123;    //接收页面提交数据 属性名 为 input 标签 name 属性    private String username;    private String password;    //提供 get set 接收页面的数据 get 为提取 set 为接收    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    //实现Action 的方法 为 struts.xml action 标签 method=&quot;&quot;的默认方法入口 可以不写该属性    public String execute() throws Exception &#123;        return null;    &#125;    //用于实现 servlet层 数据校验    //在页面跳转到login 方法前会先进来这里面    @Override    public void validate() &#123;        if(username.length()==0 || password.length()==0)&#123;            //如果在validate 方法里面 调用addFieldError 则后面不进入 login 方法 并如同login 默认返回 Action 接口提供的INPUT常量字符串            addFieldError(&quot;username&quot;,&quot;用户名不能为空&quot;);            addFieldError(&quot;password&quot;,&quot;密码不能为空&quot;);        &#125;    &#125;    //自定义入口 login    public String login() &#123;        User user = new User();        user.setUsername(&quot;simon&quot;);        user.setPassword(&quot;simon&quot;);        //得到上下文对象        ActionContext context = ActionContext.getContext();        //得到request对象        Map&lt;String, Object&gt; request = (Map&lt;String, Object&gt;) context.get(&quot;request&quot;);        //得到session对象        Map&lt;String, Object&gt; session = context.getSession();        //得到application对象        Map&lt;String, Object&gt; application = context.getApplication();        if (user.getUsername().equals(getUsername()) &amp;&amp; user.getPassword().equals(getPassword())) &#123;            //登录成功存一个User对象            session.put(&quot;user&quot;, user);            //使用自定义字符串返回 success Action 接口提供的常量为 SUCCESS            return &quot;success&quot;;        &#125;        //定义errorinfo 错误信息到request        request.put(&quot;errorinfo&quot;, &quot;登录失败&quot;);        //使用Action 接口提供的常量字符串        return ERROR;    &#125;&#125;\n\n创建页面 index.jsp&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--从request里面找errorinfo的数据--%&gt;&lt;h1&gt;$&#123;requestScope.errorinfo&#125;&lt;/h1&gt;&lt;%--显示全部 fielderror 错误信息--%&gt;&lt;h1&gt;&lt;s:fielderror/&gt;&lt;/h1&gt;&lt;%--显示某个 fielderror 错误信息--%&gt;&lt;h1&gt;&lt;s:fielderror fieldName=&quot;password&quot;/&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;%--Login 为 struts.xml 定义 action name 的名称 .action 为 Struts 标识--%&gt;&lt;form action=&quot;Login.action&quot; method=&quot;post&quot;&gt;    &lt;%--name属性要和LoginAction对象的属性一致--%&gt;    用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;    密　码: &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n创建页面 success.jsp&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录成功&lt;/h1&gt;&lt;h2&gt;欢迎您，&lt;s:property value=&quot;username&quot;/&gt;&lt;/h2&gt;&lt;h1&gt;session对象的User对象数据&lt;/h1&gt;&lt;h2&gt;用户名: $&#123;sessionScope.user.username&#125;&lt;/h2&gt;&lt;h2&gt;密　码: $&#123;sessionScope.user.password&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;\n\n配置 web.xml 文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.4&quot;         xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;&lt;/web-app&gt;\n\n配置 struts.xml 文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;        &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt;    &lt;package name=&quot;default&quot; extends=&quot;struts-default&quot;&gt;        &lt;!--method 默认值为execute 也可以自定义login方法--&gt;        &lt;action name=&quot;Login&quot; class=&quot;com.action.LoginAction&quot; method=&quot;login&quot;&gt;            &lt;!--表示程序处理正常，并返回给用户成功后的结果--&gt;            &lt;result name=&quot;success&quot;&gt;success.jsp&lt;/result&gt;            &lt;!--表示处理结果失败--&gt;            &lt;result name=&quot;error&quot;&gt;index.jsp&lt;/result&gt;            &lt;!--表示数据校验处理失败--&gt;            &lt;result name=&quot;input&quot;&gt;index.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;\n\n参考网址Struts2官方文档","categories":["struts2","idea"],"tags":["idea","struts2","servlet"]},{"title":"Next主题个性化教程","url":"/2017/04/05/Theme-of-personalized/","content":"在右上角或者左上角实现fork me on github点击 GitHub Corners 或者 点击 GitHub Ribbons 挑选自己喜欢的样式，并复制代码。\n然后粘贴刚才复制的代码到 themes/Hexo主题文件夹/layout/导航栏定义文件 的文件中(代码放置位置自行调节)，例如 Next主题 位于 themes/next/layout/_layout.swig 并把href改为你的GitHub地址\n\n\n添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 Hexo 部署到仓库后，项目下是没有 README.md 文件的。\n在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml 将 skip_render 参数的值设置为\nskip_render: README.md\n\n侧边栏社交小图标设置打开主题配置文件 _config.yml 搜索 social_icons: 在图标库找自己喜欢的小图标，并将名字复制到对应的键值对\n在网站底部加上访问量打开 \\themes\\next\\layout\\_partials\\footer.swig 文件,在copyright前加上：\n&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;\n\n然后在合适的位置添加显示统计的代码\n&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;\n\n在这里有两中不同计算方式的统计代码pv的方式，单个用户连续点击n篇文章，记录n次访问量&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;\n\nuv的方式，单个用户连续点击n篇文章，只记录1次访客数&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;  本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;\n\n添加之后再执行 hexo d -g 然后再刷新页面就能看到效果\n网站底部字数统计切换到根目录下，然后运行如下代码\nnpm install hexo-wordcount --save\n\n然后在 /themes/next/layout/_partials/footer.swig 文件尾部加上：\n&lt;div class=&quot;theme-info&quot;&gt;  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt;\n\n实现统计功能在根目录下安装 hexo-wordcount 运行：\nnpm install hexo-wordcount --save\n\n然后在主题的配置文件中，配置如下：\n# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount:  item_text: true  wordcount: true  min2read: true\n\n每次 hexo new “My New Post” 生成默认的md文件格式在 /scaffolds/post.md 文件中修改默认格式\n隐藏网页底部powered By Hexo &#x2F; 强力驱动打开 themes/next/layout/_partials/footer.swig 使用 &lt;!-- --&gt; 隐藏之间的代码即可，或者直接删除\n文章加密访问打开 themes/next/layout/_partials/head.swig 文件，在以下位置插入这样一段代码：\n&lt;script&gt;    (function()&#123;        if(&#x27;&#123;&#123; page.password &#125;&#125;&#x27;)&#123;            if (prompt(&#x27;请输入访问密码&#x27;) !== &#x27;&#123;&#123; page.password &#125;&#125;&#x27;)&#123;                alert(&#x27;访问失败&#x27;);                history.back();            &#125;        &#125;    &#125;)();&lt;/script&gt;\n\n然后在文章上定义键值对密码\n---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:  - 标签category:  - 分类comments: truepassword: password---\n\n自定义鼠标样式打开 themes/next/source/css/_custom/custom.styl 在里面写下如下代码：\n// 鼠标样式  * &#123;      cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important  &#125;  :active &#123;      cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important  &#125;\n\n其中 url 里面必须是 ico 图片，ico 图片可以上传到网上\n点击爆炸效果首先在 themes/next/source/js/src 里面建一个叫 fireworks.js 的文件，代码如下：\n&quot;use strict&quot;;function updateCoords(e) &#123;    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123;    var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a;    return &#123;x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t)&#125;&#125;function createParticule(e, t) &#123;    var a = &#123;&#125;;    return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function () &#123;        ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill()    &#125;, a&#125;function createCircle(e, t) &#123;    var a = &#123;&#125;;    return a.x = e, a.y = t, a.color = &quot;#F00&quot;, a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function () &#123;        ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1    &#125;, a&#125;function renderParticule(e) &#123;    for (var t = 0; t &lt; e.animatables.length; t++) &#123;        e.animatables[t].target.draw()    &#125;&#125;function animateParticules(e, t) &#123;    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;        n.push(createParticule(e, t))    &#125;    anime.timeline().add(&#123;        targets: n, x: function (e) &#123;            return e.endPos.x        &#125;, y: function (e) &#123;            return e.endPos.y        &#125;, radius: 0.1, duration: anime.random(1200, 1800), easing: &quot;easeOutExpo&quot;, update: renderParticule    &#125;).add(&#123;        targets: a,        radius: anime.random(80, 160),        lineWidth: 0,        alpha: &#123;value: 0, easing: &quot;linear&quot;, duration: anime.random(600, 800)&#125;,        duration: anime.random(1200, 1800),        easing: &quot;easeOutExpo&quot;,        update: renderParticule,        offset: 0    &#125;)&#125;function debounce(e, t) &#123;    var a;    return function () &#123;        var n = this, i = arguments;        clearTimeout(a), a = setTimeout(function () &#123;            e.apply(n, i)        &#125;, t)    &#125;&#125;var canvasEl = document.querySelector(&quot;.fireworks&quot;);if (canvasEl) &#123;    var ctx = canvasEl.getContext(&quot;2d&quot;), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = &quot;mousedown&quot;, colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;], setCanvasSize = debounce(function () &#123;        canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + &quot;px&quot;, canvasEl.style.height = window.innerHeight + &quot;px&quot;, canvasEl.getContext(&quot;2d&quot;).scale(2, 2)    &#125;, 500), render = anime(&#123;        duration: 1 / 0, update: function () &#123;            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)        &#125;    &#125;);    document.addEventListener(tap, function (e) &#123;        &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))    &#125;, !1), setCanvasSize(), window.addEventListener(&quot;resize&quot;, setCanvasSize, !1)&#125;&quot;use strict&quot;;function updateCoords(e) &#123;    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123;    var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a;    return &#123;x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t)&#125;&#125;function createParticule(e, t) &#123;    var a = &#123;&#125;;    return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function () &#123;        ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill()    &#125;, a&#125;function createCircle(e, t) &#123;    var a = &#123;&#125;;    return a.x = e, a.y = t, a.color = &quot;#F00&quot;, a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function () &#123;        ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1    &#125;, a&#125;function renderParticule(e) &#123;    for (var t = 0; t &lt; e.animatables.length; t++) &#123;        e.animatables[t].target.draw()    &#125;&#125;function animateParticules(e, t) &#123;    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;        n.push(createParticule(e, t))    &#125;    anime.timeline().add(&#123;        targets: n, x: function (e) &#123;            return e.endPos.x        &#125;, y: function (e) &#123;            return e.endPos.y        &#125;, radius: 0.1, duration: anime.random(1200, 1800), easing: &quot;easeOutExpo&quot;, update: renderParticule    &#125;).add(&#123;        targets: a,        radius: anime.random(80, 160),        lineWidth: 0,        alpha: &#123;value: 0, easing: &quot;linear&quot;, duration: anime.random(600, 800)&#125;,        duration: anime.random(1200, 1800),        easing: &quot;easeOutExpo&quot;,        update: renderParticule,        offset: 0    &#125;)&#125;function debounce(e, t) &#123;    var a;    return function () &#123;        var n = this, i = arguments;        clearTimeout(a), a = setTimeout(function () &#123;            e.apply(n, i)        &#125;, t)    &#125;&#125;var canvasEl = document.querySelector(&quot;.fireworks&quot;);if (canvasEl) &#123;    var ctx = canvasEl.getContext(&quot;2d&quot;), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = &quot;mousedown&quot;, colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;], setCanvasSize = debounce(function () &#123;        canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + &quot;px&quot;, canvasEl.style.height = window.innerHeight + &quot;px&quot;, canvasEl.getContext(&quot;2d&quot;).scale(2, 2)    &#125;, 500), render = anime(&#123;        duration: 1 / 0, update: function () &#123;            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)        &#125;    &#125;);    document.addEventListener(tap, function (e) &#123;        &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))    &#125;, !1), setCanvasSize(), window.addEventListener(&quot;resize&quot;, setCanvasSize, !1)&#125;;\n\n打开 themes/next/layout/_layout.swig 在 &lt;/body&gt; 上面写下如下代码：\n&#123;% if theme.fireworks %&#125;   &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt;   &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt;   &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;\n\n打开主题配置文件，在里面最后写下：\n# Fireworksfireworks: true\n","categories":["hexo","next"],"tags":["hexo","搭建博客","next"]},{"title":"Ubuntu 设置MySQL远程访问权限","url":"/2018/11/30/Ubuntu-%E8%AE%BE%E7%BD%AEMySQL%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/","content":"第一步：修改配置文件的端口绑定打开的目录可能会根据MySQL的版本稍有不同，可以先尝试打开&#x2F;etc&#x2F;mysql&#x2F;my.cnf这个配置文件，若该文件不存在或文件内容为空，则尝试下面的文件路径。\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n\n\n\n在下面行的开头加上#，注释掉该行，然后保存退出vim(文本编辑器)\nbind-address = 127.0.0.1\n\n第二步：修改访问权限进入mysql,输入如下命令，输入密码，进入mysql命令行\nmysql -u root -p\n\n授权root用户访问权限，并刷新权限，此处的root可用其它MySQL用户替换，{password}部分需替换为该用户对应的密码\ngrant all privileges on *.* to root@&quot;%&quot; with grant option;flush privileges;exit;\n\n第三步：重启mysql服务重启mysql服务\nservice mysql restart\n启动mysql服务\nservice mysql start\n停止mysql服务\nservice mysql stop\n查看mysql服务状态\nservice mysql status\n\n第四步：关闭服务器防火墙关闭防火墙\nsudo ufw disable\n开启防火墙\nsudo ufw enable\n查看当前防火墙状态(inactive关闭状态 active开启状态)\nsudo ufw status\n\n第五步：添加安全组规则根据自己购买的ECS平台添加安全组规则","categories":["linux","ubuntu","mysql"],"tags":["linux","mysql","ubuntu"]},{"title":"Ubuntu重启/关机命令","url":"/2018/12/04/Ubuntu%E9%87%8D%E5%90%AF-%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4/","content":"重启命令\n\n\n命令\n内容\n\n\n\nreboot\n重启\n\n\nshutdown -r now\n立刻重启\n\n\nshutdown -r 7\n过7分钟自动重启\n\n\nshutdown -r 21:35\n在时间为21:35时候重启\n\n\n如果是通过shutdown命令设置重启的话，可以用 shutdown -c 命令取消重启\n\n\n关机命令\n\n\n命令\n内容\n\n\n\nhalt\n立刻关机（一般加-p 关闭电源）\n\n\npoweroff\n立刻关机\n\n\nshutdown -h now\n立刻关机\n\n\nshutdown -h 10\n10分钟后自动关机\n\n\n如果是通过shutdown命令设置重启的话，可以用 shutdown -c 命令取消重启\n","categories":["linux","ubuntu"],"tags":["linux","ubuntu"]},{"title":"centOS安装maven","url":"/2019/05/05/centOS%E5%AE%89%E8%A3%85maven/","content":"centOS安装mavenwget https://archive.apache.org/dist/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gztar zxf apache-maven-3.3.9-bin.tar.gzvim /etc/profile\n\n\n\n前提安装jdk8export JAVA_HOME=/usr/local/software/jdk8export MAVEN_HOME=/usr/local/software/apache-maven-3.3.9export JAVA_BIN=/usr/local/software/jdk8export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME MAVEN_HOME JAVA_BIN PATH CLASSPATH\n\n环境变量立即生效source /etc/profile\n\n查看版本号mvn -vApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)Maven home: /usr/local/software/apache-maven-3.3.9Java version: 1.8.0_141, vendor: Oracle CorporationJava home: /usr/local/software/jdk8/jreDefault locale: en_US, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;3.10.0-862.14.4.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;\n","categories":["linux","maven"],"tags":["linux","centOS","wget","maven"]},{"title":"idea agent 激活原理","url":"/2024/04/07/idea-agent-%E6%BF%80%E6%B4%BB%E5%8E%9F%E7%90%86/","content":"破解原理jetbrains提供了一个付费插件如何校验 License 的示例代码, 点击 CheckLicense.java 查看\n\n\n现在对代码进行分析,校验license的入口是isKeyValid方法\nprivate static boolean isKeyValid(String key) &#123;    String[] licenseParts = key.split(&quot;-&quot;);    if (licenseParts.length != 4) &#123;        return false;     &#125;    final String licenseId = licenseParts[0];    final String licensePartBase64 = licenseParts[1];    final String signatureBase64 = licenseParts[2];    final String certBase64 = licenseParts[3];    try &#123;        final Signature sig = Signature.getInstance(&quot;SHA1withRSA&quot;);        sig.initVerify(createCertificate(Base64.getMimeDecoder().decode(certBase64.getBytes(StandardCharsets.UTF_8)), Collections.emptySet(), false));        final byte[] licenseBytes = Base64.getMimeDecoder().decode(licensePartBase64.getBytes(StandardCharsets.UTF_8));        sig.update(licenseBytes);        if (!sig.verify(Base64.getMimeDecoder().decode(signatureBase64.getBytes(StandardCharsets.UTF_8)))) &#123;            return false;        &#125;        final String licenseData = new String(licenseBytes, StandardCharsets.UTF_8);        return licenseData.contains(&quot;\\&quot;licenseId\\&quot;:\\&quot;&quot; + licenseId + &quot;\\&quot;&quot;);    &#125; catch (Throwable e) &#123;        e.printStackTrace()    &#125;    return false;&#125;\n\n下面进行逐步分析:\nLicense的格式String[] licenseParts = key.split(&quot;-&quot;);if (licenseParts.length != 4) &#123;    return false; // invalid format&#125;final String licenseId = licenseParts[0];final String licensePartBase64 = licenseParts[1];final String signatureBase64 = licenseParts[2];final String certBase64 = licenseParts[3];\n\n透过这几行,我们可以发现License由4部分组成,这4部分用-拼接\nlicenseId\nlicenseId 没什么好解释的,大家写代码对一条数据会给他一个id标识,这里也是一样的\nlicensePartBase64\n既然是base64我们使用base64解码试试,先从网上找个license\n再写几行代码解码打印一下\n打印结果,下面是json格式化后的\n&#123;    &quot;licenseId&quot;: &quot;29VRVXKXEQ&quot;,    &quot;licenseeName&quot;: &quot;gurgles tumbles&quot;,    &quot;assigneeName&quot;: &quot;&quot;,    &quot;assigneeEmail&quot;: &quot;&quot;,    &quot;licenseRestriction&quot;: &quot;&quot;,    &quot;checkConcurrentUse&quot;: false,    &quot;products&quot;: [        &#123;            &quot;code&quot;: &quot;II&quot;,            &quot;fallbackDate&quot;: &quot;2026-09-14&quot;,            &quot;paidUpTo&quot;: &quot;2026-09-14&quot;,            &quot;extended&quot;: false        &#125;,        &#123;            &quot;code&quot;: &quot;PCWMP&quot;,            &quot;fallbackDate&quot;: &quot;2026-09-14&quot;,            &quot;paidUpTo&quot;: &quot;2026-09-14&quot;,            &quot;extended&quot;: true        &#125;,        &#123;            &quot;code&quot;: &quot;PSI&quot;,            &quot;fallbackDate&quot;: &quot;2026-09-14&quot;,            &quot;paidUpTo&quot;: &quot;2026-09-14&quot;,            &quot;extended&quot;: true        &#125;,        &#123;            &quot;code&quot;: &quot;PDB&quot;,            &quot;fallbackDate&quot;: &quot;2026-09-14&quot;,            &quot;paidUpTo&quot;: &quot;2026-09-14&quot;,            &quot;extended&quot;: true        &#125;    ],    &quot;metadata&quot;: &quot;0120230914PSAX000005&quot;,    &quot;hash&quot;: &quot;TRIAL:1649058719&quot;,    &quot;gracePeriodDays&quot;: 7,    &quot;autoProlongated&quot;: false,    &quot;isAutoProlongated&quot;: false&#125;\n\n可以看出,这个json存储了license的信息了,过期时间,产品编码,等等\nsignatureBase64\n这个虽然也是bash64编码的,但是不可读,从后续的代码中可以看到这个是licensePartBase64的签名(防止你修改licensePartBase64的内容)\ncertBase64\n这个从名字就可以知道,这是一个证书的base64,我们可以写几行代码试试将其转成X509Certificate打印结果\n[[  Version: V3  Subject: CN=prod2y-from-20201019  Signature Algorithm: SHA256withRSA, OID = 1.2.840.113549.1.1.11  Key:  Sun RSA public key, 2048 bits  params: null  modulus: 18757061644631641897871738039803297079222086307758970668007743391230210652175936091067273679967614176566958971386041386130847029810514259477478961428354871927476348879585595226079089482240396983201444402264034332735246934562349766525834026808529064015070873142427210769732272794189934622072446800676835238869578773294766180028559237543555831007850742231939840102022188112702553709667158412697383676208362494918482992433951964054476644792447772443724250800187136958875570841896406567118594736548490951814592975795053469752356231684777929851181510821765498304994721447237722500206967118619930964967974888609206437705281  public exponent: 65537  Validity: [From: Mon Oct 19 17:05:53 CST 2020,               To: Fri Oct 21 17:05:53 CST 2022]  Issuer: CN=JetProfile CA  SerialNumber: [    0d]Certificate Extensions: 5[1]: ObjectId: 2.5.29.35 Criticality=falseAuthorityKeyIdentifier [KeyIdentifier [0000: A3 9E B6 48 67 42 12 36   41 BD 6D E0 B9 B4 A0 52  ...HgB.6A.m....R0010: 8B 97 F1 B3                                        ....][CN=JetProfile CA]SerialNumber: [    d26cb183 b28379e1]][2]: ObjectId: 2.5.29.19 Criticality=falseBasicConstraints:[  CA:false  PathLen: undefined][3]: ObjectId: 2.5.29.37 Criticality=falseExtendedKeyUsages [  serverAuth][4]: ObjectId: 2.5.29.15 Criticality=falseKeyUsage [  DigitalSignature  Key_Encipherment][5]: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: 24 DA 11 22 96 F5 85 41   C0 93 47 E8 31 23 4C F4  $..&quot;...A..G.1#L.0010: C0 84 02 FF                                        ....]]]  Algorithm: [SHA256withRSA]  Signature:......]\n\n可以看出这个一个由JetProfile CA签名的子证书\n验证证书final Signature sig = Signature.getInstance(&quot;SHA1withRSA&quot;);// Here it is only important that the key was signed with an authentic JetBrains certificate.sig.initVerify(createCertificate(Base64.getMimeDecoder().decode(certBase64.getBytes(StandardCharsets.UTF_8)), Collections.emptySet(), false));\n\nHere it is only important that the key was signed with an authentic JetBrains certificate.翻译一下就是:这里唯一重要的是密钥是使用真实的 JetBrains 证书签名的\n说明了这段代码唯一的目的就是校验证书是JetBrains签名的,createCertificate核心代码如下\nfinal X509CertSelector selector = new X509CertSelector();selector.setCertificate(cert);final Set&lt;TrustAnchor&gt; trustAchors = new HashSet&lt;&gt;();for (String rc : ROOT_CERTIFICATES) &#123;    trustAchors.add(new TrustAnchor((X509Certificate) x509factory.generateCertificate(new ByteArrayInputStream(rc.getBytes(StandardCharsets.UTF_8))), null));&#125;final PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(trustAchors, selector);pkixParams.setRevocationEnabled(false);if (!checkValidityAtCurrentDate) &#123;    pkixParams.setDate(cert.getNotBefore());&#125;pkixParams.addCertStore(CertStore.getInstance(&quot;Collection&quot;, new CollectionCertStoreParameters(allCerts)));final CertPath path = CertPathBuilder.getInstance(&quot;PKIX&quot;).build(pkixParams).getCertPath();if (path != null) &#123;    CertPathValidator.getInstance(&quot;PKIX&quot;).validate(path, pkixParams);    return cert;&#125;\n\nROOT_CERTIFICATES 是内置的根证书,使用根证书来验证传入的证书是不是根证书签发的,后面的代码都是使用java的库进行证书链验证\n这里涉及到了证书链 证书签名\n证书包含的内容可以概述为三部分，用户的信息、用户的公钥、还有CA中心对该证书里面的信息的签名。我们在验证证书的有效性的时候，会逐级去寻找签发者的证书，直至根证书为结束，然后通过公钥一级一级验证数字签名的正确性。\n证书签名即使用上一级机构的私钥对证书里的信息进行hash再加密\n用户使用上一级的公钥对签名进行解密得到一个值\n用户使用证书里的信息进行hash的到一个值\n如果这两者相同,则说明证书是正确的\n验证licensePart验证完证书,还需要验证license中的信息是不是被修改过,\nfinal Signature sig = Signature.getInstance(&quot;SHA1withRSA&quot;);sig.initVerify(createCertificate(Base64.getMimeDecoder().decode(certBase64.getBytes(StandardCharsets.UTF_8)), Collections.emptySet(), false));final byte[] licenseBytes = Base64.getMimeDecoder().decode(licensePartBase64.getBytes(StandardCharsets.UTF_8));sig.update(licenseBytes);if (!sig.verify(Base64.getMimeDecoder().decode(signatureBase64.getBytes(StandardCharsets.UTF_8)))) &#123;    return false;&#125;\n\n其实就使用证书里包含的公钥与SHA1withRSA 算法进行验证\n破解的思路首先,我们需要一个证书, 还要有这个证书的私钥,网上找的license只能拿到证书,没有私钥,没有私钥就无法对licensePart进行签名\n如果我们自己签一个证书,那么验证证书时是无法通过的, 我们需要一点魔法来搞定这一点, Java agent 技术修改jdk的字节码, 使得校验我们的证书时总是通过\n有了证书后,使用证书的私钥对我们修改过的licensePart进行签名,最后拼接得到license\n为什么不直接改掉这个函数?\n上面的代码只是一个demo,并不代表实际软件里是这么实现的,并且idea的代码经过混淆加密,根本无法查看,无法定位到是那个方法校验的license\n破解的实现生成证书使用下面的python脚本即可\nimport datetimefrom cryptography import x509from cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import hashes, serializationfrom cryptography.hazmat.primitives.asymmetric import rsafrom cryptography.x509.oid import NameOIDone_day = datetime.timedelta(days=1)ten_day = datetime.timedelta(days=3650)today = datetime.datetime.today()yesterday = today - one_daytomorrow = today + ten_dayprivate_key = rsa.generate_private_key(    public_exponent=65537,    key_size=4096,    backend=default_backend())public_key = private_key.public_key()builder = x509.CertificateBuilder()builder = builder.subject_name(x509.Name([    x509.NameAttribute(NameOID.COMMON_NAME, &#x27;Novice-from-2024-01-19&#x27;),]))builder = builder.issuer_name(x509.Name([    x509.NameAttribute(NameOID.COMMON_NAME, &#x27;JetProfile CA&#x27;),]))builder = builder.not_valid_before(yesterday)builder = builder.not_valid_after(tomorrow)builder = builder.serial_number(x509.random_serial_number())builder = builder.public_key(public_key)certificate = builder.sign(    private_key=private_key, algorithm=hashes.SHA256(),    backend=default_backend())private_bytes = private_key.private_bytes(    encoding=serialization.Encoding.PEM,    format=serialization.PrivateFormat.TraditionalOpenSSL,    encryption_algorithm=serialization.NoEncryption())public_bytes = certificate.public_bytes(    encoding=serialization.Encoding.PEM)with open(&quot;ca.key&quot;, &quot;wb&quot;) as fout:    fout.write(private_bytes)with open(&quot;ca.crt&quot;, &quot;wb&quot;) as fout:    fout.write(public_bytes)\n\n执行这个脚本会生成保存一个证书ca.crt, 以及一个私钥ca.key\n使用证书和私钥生成licenseimport org.bouncycastle.jce.provider.BouncyCastleProvider;import org.bouncycastle.openssl.PEMKeyPair;import org.bouncycastle.openssl.PEMParser;import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;import java.io.FileInputStream;import java.io.FileReader;import java.nio.charset.StandardCharsets;import java.security.KeyPair;import java.security.PrivateKey;import java.security.Security;import java.security.Signature;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate;import java.util.Base64;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);        X509Certificate cert = (X509Certificate) certificateFactory.generateCertificate(new FileInputStream(&quot;ca.crt&quot;));        // 自己修改 license内容        // 注意licenseId要一致        // 里面的内容是激活webstorm        String licensePart = &quot;&#123;\\&quot;licenseId\\&quot;:\\&quot;MOUGH5FKDV\\&quot;,\\&quot;licenseeName\\&quot;:\\&quot;haha\\&quot;,\\&quot;assigneeName\\&quot;:\\&quot;novice.li\\&quot;,\\&quot;assigneeEmail\\&quot;:\\&quot;\\&quot;,\\&quot;licenseRestriction\\&quot;:\\&quot;\\&quot;,\\&quot;checkConcurrentUse\\&quot;:false,\\&quot;products\\&quot;:[&#123;\\&quot;code\\&quot;:\\&quot;PCWMP\\&quot;,\\&quot;fallbackDate\\&quot;:\\&quot;2026-09-14\\&quot;,\\&quot;paidUpTo\\&quot;:\\&quot;2026-09-14\\&quot;,\\&quot;extended\\&quot;:true&#125;,&#123;\\&quot;code\\&quot;:\\&quot;PSI\\&quot;,\\&quot;fallbackDate\\&quot;:\\&quot;2026-09-14\\&quot;,\\&quot;paidUpTo\\&quot;:\\&quot;2026-09-14\\&quot;,\\&quot;extended\\&quot;:true&#125;,&#123;\\&quot;code\\&quot;:\\&quot;WS\\&quot;,\\&quot;fallbackDate\\&quot;:\\&quot;2026-09-14\\&quot;,\\&quot;paidUpTo\\&quot;:\\&quot;2026-09-14\\&quot;,\\&quot;extended\\&quot;:false&#125;],\\&quot;metadata\\&quot;:\\&quot;0120230914PSAX000005\\&quot;,\\&quot;hash\\&quot;:\\&quot;TRIAL:-1920204289\\&quot;,\\&quot;gracePeriodDays\\&quot;:7,\\&quot;autoProlongated\\&quot;:false,\\&quot;isAutoProlongated\\&quot;:false&#125;&quot;;        String licenseId = &quot;MOUGH5FKDV&quot;;        byte[] licensePartBytes = licensePart.getBytes(StandardCharsets.UTF_8);        String licensePartBase64 = Base64.getEncoder().encodeToString(licensePartBytes);        PrivateKey privateKey = getPrivateKey();        Signature signature = Signature.getInstance(&quot;SHA1withRSA&quot;);        signature.initSign(privateKey);        signature.update(licensePartBytes);        byte[] signatureBytes = signature.sign();        String sigResultsBase64 = Base64.getEncoder().encodeToString(signatureBytes);//        verify//        Signature verifySignature = Signature.getInstance(&quot;SHA1withRSA&quot;);//        verifySignature.initVerify(cert.getPublicKey());//        verifySignature.update(Base64.getDecoder().decode(licensePartBase64));//        boolean verify = verifySignature.verify(Base64.getDecoder().decode(sigResultsBase64));//        System.out.println(verify);        // Combine results as needed        String result = licenseId + &quot;-&quot; + licensePartBase64 + &quot;-&quot; + sigResultsBase64 + &quot;-&quot; + Base64.getEncoder().encodeToString(cert.getEncoded());        System.out.println(result);    &#125;    static PrivateKey getPrivateKey() throws Exception &#123;        Security.addProvider(new BouncyCastleProvider());        PEMParser pemParser = new PEMParser(new FileReader(&quot;ca.key&quot;));        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(&quot;BC&quot;);        Object object = pemParser.readObject();        KeyPair kp = converter.getKeyPair((PEMKeyPair) object);        return kp.getPrivate();    &#125;&#125;\n\n这里需要一个第三方的库\n&lt;dependency&gt;    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;    &lt;artifactId&gt;bcpkix-jdk18on&lt;/artifactId&gt;    &lt;version&gt;1.72&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;    &lt;artifactId&gt;bcprov-jdk18on&lt;/artifactId&gt;    &lt;version&gt;1.72&lt;/version&gt;&lt;/dependency&gt;\n\n执行main方法,因该能得到类似以下内容, 证书不同, licensePart不同,所以内容每个人都不一样使用的jdk是OpenJdk17\nMOUGH5FKDV-eyJsaWNlbnNlSWQiOiJNT1VHSDVGS0RWIiwibGljZW5zZWVOYW1lIjoiaGFoYSIsImFzc2lnbmVlTmFtZSI6Im5vdmljZS5saSIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IlBDV01QIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0wOS0xNCIsInBhaWRVcFRvIjoiMjAyNi0wOS0xNCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU0kiLCJmYWxsYmFja0RhdGUiOiIyMDI2LTA5LTE0IiwicGFpZFVwVG8iOiIyMDI2LTA5LTE0IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IldTIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0wOS0xNCIsInBhaWRVcFRvIjoiMjAyNi0wOS0xNCIsImV4dGVuZGVkIjpmYWxzZX1dLCJtZXRhZGF0YSI6IjAxMjAyMzA5MTRQU0FYMDAwMDA1IiwiaGFzaCI6IlRSSUFMOi0xOTIwMjA0Mjg5IiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-EtkxIjIOL6nbRjpnwjn3xoS5ch3k/gMZMFZ8/oqxIqNhlwDsQajZw/UASlLpd3t6tWRqefL4kucMfpNyUEPbwe3jcA0cbE7bD7wj1O2UUCTBDpCTY3Hh57dgdkvYIizIaqdFFay7GtQf46ltXraYt3YUpiQfx0ferOR9tDdg1zgL2n0vxLtlChYAMvBo2yMnyMvAS490tQu4c5Oi87KNcTWmUihL6oiDIv1a2/DaMYpKY10PvAENwfq0wuQtWQqrb1azF1LIziratnBY0AfpMOb6HMIYf0iPGMCyYcwmyDfQ5nM5gKnip9V8gsyQFX+Ja4dzDbEoRt5AavvShbYJjYTB8RCXWuLW6uLhoaJJMKK5VWDNPwqd2iL4cRWmXLVOM6IDdtP0asLVjgfugbr7NYHZepfhQhgPCZrJR4MeLbYtdJakDwI+JBim7gSlYDJi8DNxXl5qvnzTL9oS66zwvx84E5KNCePC08MkUVallELohQpcs7pt8CfRPsqTJpSDMS/h3aTvhLOVLCY5zCXc2G1bmh6HdDYWPvbhU4uiGlWcqTiBVjUo324tO0085yU40VUk6S4QL+Q69HX1i13k43saaDg1OirnLY7pGq6bgW6fqALqVrrOgjy4Pkhwyzx/hJWTqxcY1kHFyqIFpWT/lWJ8shpU/Lp0NTQ6OIDe4Ag=-MIIExTCCAq2gAwIBAgIUONPn09E4/d2ARDMbTgtVdG78L5owDQYJKoZIhvcNAQELBQAwGDEWMBQGA1UEAwwNSmV0UHJvZmlsZSBDQTAeFw0yMzA5MjIxMjI3NTRaFw0zMzA5MjAxMjI3NTRaMCExHzAdBgNVBAMMFk1vWXVuby1mcm9tLTIwMjItMDctMjUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCgoO4tub6olCRbJ38I0K4kWr+suajcuwTDbrAvWqkNTt3U1SWArWQa7s6QJfKAAFVKEQpFW2eu861YLC8GUVKKZS4ol9dihVy+Zp7ThUuSkz64d9kwQ4/5JwKEAW51fWORHbjs3dhdShAq9tmuOGohi0KjBhkTzeKpTMa2k/TlxHD0pwdVDEQygQ02+ddCkSuozF/9/mzafG2RB6iYiKld7vUs68n2FVotktpN2eGrXv72nenuQLKVT7ecXNT0m6KzY6+aelAFqeSUhnyqVe9Zm0oPIPL9QAJXmjUpzyw6vu2ZYkCoJcGjtogs9uilqlOaKGFQc1OGxuoQhOerBOZm6n93YIobjr5RwRb0img6AtkknFsXoUKNHxAGu8iCFlRGykWU5K+h+/NRd7JAO2AAMv2Qa5CwG+wcc1YXZQejL7YkBTw70zUI3107on2n4KTbtNYpdwccqAjWcdycG4eekBMxGDGKS43aH1adT54ICQsm8jsq5/zTg/8PR4PBG/jXyUGR0JRlwy14aWyJwaLIdscDGU3S6nfM8f2mtchKnDySzkn17FucNkW9nXbV979WsxX+TPX3y/vNAQzM04z+6Vjfp/1AIFu+LC0VaOhbI1yqYZOvUdQX5XyhZ6N/rCFj6Hsv4fuCVCTMuSs/qGS83js6LVxd9ZygRlhcc8YL7wIDAQABMA0GCSqGSIb3DQEBCwUAA4ICAQAI3XgTh8LKomEU8T0Zd2fYjT7I/XdNgY3KvW/DzsdG6A0wRlijwA74aWcD7N/Rrrz9vObI1PUMUbJzUwwcHu6ZvlL0f23QRu4oXASEVuU34QYDIY5/1nMaFyjLKGrXfctz9+qXnn/admaiUVj81jroLKbHFoAga9I2i987fwaVnG1CwDOIkG54xwvCT34M3d7sxEUZwSI/+yMS3JVG19kOqf16KBar5WlZcSYA+rd01RfuBKW4ciu5VplAoKBfU6QOeh5SfQdoG8cxUHI5KBUWzhDUZo8TK5donK8ZQs5Pka5mWLCAWW6gq+9JzCeEFxyscr8pTMWegQpEQG6B8ULtMuT69DTx6RRQzwDe9oQAzZqqAjnuiLr87y6IKKwRaZe3zqsMkdqnEslDOMFuYZce4vGyYZr5vx5774kjIv3AvCowx8O6UMOhJgi7aDnEbTdF3AswUg3fGGsMwujKY6VLMzzIJ8i6P+X3Abdb51hr0hEimWnbBIi4Vdg9Ga6sLR+gAr4PAy/LX2tfxTfIryehcC12C5s2uMDtoHPi5MtQZ7ZLDj7F1opGd4RjEtdAuA81e+usCPbpc2A9DLEFTzqJCxmbhd4obzlj75Bb2ih83MeJwvlhNl3oLb89Ur05VyF/XF5vWdtFA7EOx7Tb/s5Vv4N5PptsDX8jjFNdTrbByA==\n\n实现agent不借助第三方库实现agent过于麻烦,这里使用了bytebuddy\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;        &lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;        &lt;version&gt;1.14.8&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;        &lt;artifactId&gt;byte-buddy-agent&lt;/artifactId&gt;        &lt;version&gt;1.14.8&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\nagent入口public class MyAgent &#123;    public static void premain(String agentArgs, Instrumentation inst) throws Exception &#123;        System.out.println(&quot;premain&quot;);        AgentBuilder agentBuilder = new AgentBuilder.Default()                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)                .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)                .ignore(ElementMatchers.nameStartsWith(&quot;net.bytebuddy.&quot;));//                .with(new MyAgentListener());        // 使得证书验证通过        agentBuilder.type(ElementMatchers.named(&quot;java.math.BigInteger&quot;))                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt; builder                        .visit(Advice.to(BigIntegerAdvice.class)                                .on(ElementMatchers.named(&quot;oddModPow&quot;))))                .installOn(inst);        // 使得软件无法联查询license是否有效        agentBuilder.type(ElementMatchers.named(&quot;sun.net.www.http.HttpClient&quot;))                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt; builder                        .visit(Advice.to(HttpClientAdvice.class)                                .on(ElementMatchers.named(&quot;openServer&quot;))))                .installOn(inst);    &#125;&#125;\n\nBigInteger字节码修改public class BigIntegerAdvice &#123;    @Advice.OnMethodExit    public static void intercept(            @Advice.This Object x,            @Advice.Argument(0) Object y,            @Advice.Argument(1) Object z,            @Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object result) &#123;        if (x.equals(new BigInteger(&quot;36166507575254258312547027941858871437580810141594337200634531192709271990549138017653139428637214469518776226512514369004499289847036817469920968543987282718805757210373621424125369064930654976403697173880331936585809803551274383021052688245707534952529753956318732372398693865515682072768749358719639235133806071855621596884699396908937096538670823305390763889445915414212661834406474645084286972757261296942320901075450730996142655451199555878429717483753245244508608163955616875622042555910407980521229778591975259177464788366985872288786334747203093703957973287632789434327641599787000549866966192526794523855683888490599956338743423054243358140301110599656608543763370035640069620948490016119875557306188027723775640833530499501378515276585419289699580465617070710428011530935063840014105253697311418321548680810054175037350220973183173395413388108134009666677350116213765976505112039029245857777643312281864634007579756549926726103948406693982258504228622481891671878799710903090844117319488904013303198514270837678342521608616094938912551751797776393327428080770304213598190322505916651401618610161692299082137461123669656196926798832696434348431060443898249477064062856464545081431225728688735741916845932153841685712257480&quot;)))&#123;            if (y.equals(new BigInteger(&quot;65537&quot;)))&#123;                if (z.equals(new BigInteger(&quot;860106576952879101192782278876319243486072481962999610484027161162448933268423045647258145695082284265933019120714643752088997312766689988016808929265129401027490891810902278465065056686129972085119605237470899952751915070244375173428976413406363879128531449407795115913715863867259163957682164040613505040314747660800424242248055421184038777878268502955477482203711835548014501087778959157112423823275878824729132393281517778742463067583320091009916141454657614089600126948087954465055321987012989937065785013284988096504657892738536613208311013047138019418152103262155848541574327484510025594166239784429845180875774012229784878903603491426732347994359380330103328705981064044872334790365894924494923595382470094461546336020961505275530597716457288511366082299255537762891238136381924520749228412559219346777184174219999640906007205260040707839706131662149325151230558316068068139406816080119906833578907759960298749494098180107991752250725928647349597506532778539709852254478061194098069801549845163358315116260915270480057699929968468068015735162890213859113563672040630687357054902747438421559817252127187138838514773245413540030800888215961904267348727206110582505606182944023582459006406137831940959195566364811905585377246353&quot;)))&#123;                    result = new BigInteger(&quot;31872219281407242025505148642475109331663948030010491344733687844358944945421064967310388547820970408352359213697487269225694990179009814674781374751323403257628081559561462351695605167675284372388551941279783515209238245831229026662363729380633136520288327292047232179909791526492877475417113579821717193807584807644097527647305469671333646868883650312280989663788656507661713409911267085806708237966730821529702498972114194166091819277582149433578383639532136271637219758962252614390071122773223025154710411681628917523557526099053858210363406122853294409830276270946292893988830514538950951686480580886602618927728470029090747400687617046511462665469446846624685614084264191213318074804549715573780408305977947238915527798680393538207482620648181504876534152430149355791756374642327623133843473947861771150672096834149014464956451480803326284417202116346454345929350148770746553056995922154382822307758515805142704373984019252210715650875853634697920708113806880196144197384637328982263167395073688501517286678083973976140696077590122053014085412828620051470085033364773099146103525313018873319293728800442101520384088109603555959893639842091339193908358622712857369348954116918063496396334792107628357445854420445133725500867&quot;);                &#125;            &#125;        &#125;    &#125;&#125;\n\n上面的几个大数字是由我们生成的证书计算来的,后面会给出计算代码,并作出解释\nHttpClient字节码修改public class HttpClientAdvice &#123;    @Advice.OnMethodExit    public static void intercept(@Advice.This Object x) throws Exception &#123;        if (x.toString().contains(&quot;validateKey.action&quot;))&#123;            throw new SocketTimeoutException();        &#125;    &#125;&#125;\n\nmaven打包配置记得修改pom的打包配置, 记得修改配置里的包名,改成你自己的\n&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;                &lt;descriptorRefs&gt;                    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;                &lt;/descriptorRefs&gt;                &lt;archive&gt;                    &lt;manifestEntries&gt;                        &lt;Premain-Class&gt;win.novice.li.MyAgent&lt;/Premain-Class&gt;                        &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;                        &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;                    &lt;/manifestEntries&gt;                &lt;/archive&gt;            &lt;/configuration&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;id&gt;make-assembly&lt;/id&gt;                    &lt;phase&gt;package&lt;/phase&gt;                    &lt;goals&gt;                        &lt;goal&gt;single&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n使用生成的激活码编辑打包\n给webstorm的jvm配置加上下面的参数\n--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED-javaagent:/home/novice/work/jetbrains/java/myagent/target/myagent-1.0.0.jar\n\n其中javaAgent的路径需要修改成你们自己打包后存放的路径,启动再输入生成的激活码\nBigIntegerAdvice 中的几个数字是如何生成,这段代码为什么是这样?对证书验证其实就是验证证书中携带的签名是否和jetbains计算的签名是否一致，jetbrains会使用其内置根证书z尝试对签名解密，即计算：x.modpow(y,z)（具体的签名验签原理可以看RSA加密&amp;签名），但是这里的证书不是由jetbrains签发，所以要替换计算的结果\nx：证书的签名密文\ny：证书指数 固定 65535\nz：内置根证书的公钥,文章最开始验证激活码的demo代码里硬编码的\nr : 对 DER 编码的证书信息(即来自该证书的tbsCertificate) 进行sha265摘要计算，计算的结果转换为ASN1格式数据，ASN1格式数据再进行填充得到的\n当检测到使用modpow方法解密我们证书的签名时,返回r,这样idea再对r做一些计算得到的值等于证书信息的sha265摘要,idea就会认为可信的证书,下面是sun.security.rsa.RSASignature的验签实现\nprotected boolean engineVerify(byte[] sigBytes) throws SignatureException &#123;    // sigBytes 即我们自己生成的证书的签名    if (publicKey == null) &#123; // 使用根证书的公钥进行解密        throw new SignatureException(&quot;Missing public key&quot;);    &#125;    try &#123;        if (sigBytes.length != RSACore.getByteLength(publicKey)) &#123;            throw new SignatureException(&quot;Signature length not correct: got &quot; +                    sigBytes.length + &quot; but was expecting &quot; +                    RSACore.getByteLength(publicKey));        &#125;        // 对 DER 编码的证书信息 进行 sha256 得到摘要        byte[] digest = getDigestValue();        // 使用公钥进行解密 底层使用了oddModPow 这也是我们修改的地方        byte[] decrypted = RSACore.rsa(sigBytes, publicKey);        // 去除补齐  所以在计算 r 的时候需要我们进行补齐        byte[] unpadded = padding.unpad(decrypted);        // 解码 DER-encoded 信息 得到摘要 所以在计算 r 的时候需要我们进行DER-encoded        byte[] decodedDigest = decodeSignature(digestOID, unpadded);        return MessageDigest.isEqual(digest, decodedDigest);    &#125; catch (javax.crypto.BadPaddingException e) &#123;        return false;    &#125; catch (IOException e) &#123;        throw new SignatureException(&quot;Signature encoding error&quot;, e);    &#125; finally &#123;        resetDigest();    &#125;&#125;\n\n下面是计算 x y z r 的代码\nimport java.io.ByteArrayInputStream;import java.io.FileInputStream;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate;import java.security.interfaces.RSAPublicKey;import java.util.*;public class XYZR &#123;    private static final String ROOT_CERTIFICATE = &quot;-----BEGIN CERTIFICATE-----\\n&quot; +            &quot;MIIFOzCCAyOgAwIBAgIJANJssYOyg3nhMA0GCSqGSIb3DQEBCwUAMBgxFjAUBgNV\\n&quot; +            &quot;BAMMDUpldFByb2ZpbGUgQ0EwHhcNMTUxMDAyMTEwMDU2WhcNNDUxMDI0MTEwMDU2\\n&quot; +            &quot;WjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMIICIjANBgkqhkiG9w0BAQEFAAOC\\n&quot; +            &quot;Ag8AMIICCgKCAgEA0tQuEA8784NabB1+T2XBhpB+2P1qjewHiSajAV8dfIeWJOYG\\n&quot; +            &quot;y+ShXiuedj8rL8VCdU+yH7Ux/6IvTcT3nwM/E/3rjJIgLnbZNerFm15Eez+XpWBl\\n&quot; +            &quot;m5fDBJhEGhPc89Y31GpTzW0vCLmhJ44XwvYPntWxYISUrqeR3zoUQrCEp1C6mXNX\\n&quot; +            &quot;EpqIGIVbJ6JVa/YI+pwbfuP51o0ZtF2rzvgfPzKtkpYQ7m7KgA8g8ktRXyNrz8bo\\n&quot; +            &quot;iwg7RRPeqs4uL/RK8d2KLpgLqcAB9WDpcEQzPWegbDrFO1F3z4UVNH6hrMfOLGVA\\n&quot; +            &quot;xoiQhNFhZj6RumBXlPS0rmCOCkUkWrDr3l6Z3spUVgoeea+QdX682j6t7JnakaOw\\n&quot; +            &quot;jzwY777SrZoi9mFFpLVhfb4haq4IWyKSHR3/0BlWXgcgI6w6LXm+V+ZgLVDON52F\\n&quot; +            &quot;LcxnfftaBJz2yclEwBohq38rYEpb+28+JBvHJYqcZRaldHYLjjmb8XXvf2MyFeXr\\n&quot; +            &quot;SopYkdzCvzmiEJAewrEbPUaTllogUQmnv7Rv9sZ9jfdJ/cEn8e7GSGjHIbnjV2ZM\\n&quot; +            &quot;Q9vTpWjvsT/cqatbxzdBo/iEg5i9yohOC9aBfpIHPXFw+fEj7VLvktxZY6qThYXR\\n&quot; +            &quot;Rus1WErPgxDzVpNp+4gXovAYOxsZak5oTV74ynv1aQ93HSndGkKUE/qA/JECAwEA\\n&quot; +            &quot;AaOBhzCBhDAdBgNVHQ4EFgQUo562SGdCEjZBvW3gubSgUouX8bMwSAYDVR0jBEEw\\n&quot; +            &quot;P4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2Zp\\n&quot; +            &quot;bGUgQ0GCCQDSbLGDsoN54TAMBgNVHRMEBTADAQH/MAsGA1UdDwQEAwIBBjANBgkq\\n&quot; +            &quot;hkiG9w0BAQsFAAOCAgEAjrPAZ4xC7sNiSSqh69s3KJD3Ti4etaxcrSnD7r9rJYpK\\n&quot; +            &quot;BMviCKZRKFbLv+iaF5JK5QWuWdlgA37ol7mLeoF7aIA9b60Ag2OpgRICRG79QY7o\\n&quot; +            &quot;uLviF/yRMqm6yno7NYkGLd61e5Huu+BfT459MWG9RVkG/DY0sGfkyTHJS5xrjBV6\\n&quot; +            &quot;hjLG0lf3orwqOlqSNRmhvn9sMzwAP3ILLM5VJC5jNF1zAk0jrqKz64vuA8PLJZlL\\n&quot; +            &quot;S9TZJIYwdesCGfnN2AETvzf3qxLcGTF038zKOHUMnjZuFW1ba/12fDK5GJ4i5y+n\\n&quot; +            &quot;fDWVZVUDYOPUixEZ1cwzmf9Tx3hR8tRjMWQmHixcNC8XEkVfztID5XeHtDeQ+uPk\\n&quot; +            &quot;X+jTDXbRb+77BP6n41briXhm57AwUI3TqqJFvoiFyx5JvVWG3ZqlVaeU/U9e0gxn\\n&quot; +            &quot;8qyR+ZA3BGbtUSDDs8LDnE67URzK+L+q0F2BC758lSPNB2qsJeQ63bYyzf0du3wB\\n&quot; +            &quot;/gb2+xJijAvscU3KgNpkxfGklvJD/oDUIqZQAnNcHe7QEf8iG2WqaMJIyXZlW3me\\n&quot; +            &quot;0rn+cgvxHPt6N4EBh5GgNZR4l0eaFEV+fxVsydOQYo1RIyFMXtafFBqQl6DDxujl\\n&quot; +            &quot;FeU3FZ+Bcp12t7dlM4E0/sS1XdL47CfGVj4Bp+/VbF862HmkAbd7shs7sDQkHbU=\\n&quot; +            &quot;-----END CERTIFICATE-----\\n&quot;;    public static void main(String[] args)  throws Exception&#123;        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);        X509Certificate cert =  (X509Certificate)certificateFactory.generateCertificate(new FileInputStream(&quot;ca.crt&quot;));        // x：证书的签名密文        System.out.println(&quot;x：证书的签名密文&quot;);        System.out.println(new BigInteger(cert.getSignature()));        System.out.println();        // y：证书指数 固定 65535        System.out.println(&quot;y：证书指数 固定65535&quot;);        System.out.println(new BigInteger(&quot;65535&quot;));        System.out.println();        // z：内置根证书的公钥        X509Certificate rootCertificate = (X509Certificate) certificateFactory.generateCertificate(new ByteArrayInputStream(ROOT_CERTIFICATE.getBytes(StandardCharsets.UTF_8)));        RSAPublicKey publicKey = (RSAPublicKey)rootCertificate.getPublicKey();        System.out.println(&quot;z：内置根证书的公钥&quot;);        System.out.println(publicKey.getModulus());        System.out.println();        // 对 DER 编码的证书信息(即来自该证书的tbsCertificate) 进行sha265摘要计算，计算的结果转换为ASN1格式数据，ASN1格式数据再进行填充得到的        int modBits = ((RSAPublicKey)cert.getPublicKey()).getModulus().bitLength();        int emLen = (modBits + 7) / 8;        // sha256 进行摘要        MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);        byte[] tbsCertificateBytes = cert.getTBSCertificate();        byte[] digestBytes = digest.digest(tbsCertificateBytes);        // DER-encoded        byte[] digestAlgo = new byte[]&#123;0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, (byte) 0x86, 0x48, 0x01, (byte) 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20&#125;;        byte[] digestInfo = new byte[digestAlgo.length + digestBytes.length];        System.arraycopy(digestAlgo, 0, digestInfo, 0, digestAlgo.length);        System.arraycopy(digestBytes, 0, digestInfo, digestAlgo.length, digestBytes.length);        // 补齐        byte[] ps = new byte[emLen - digestInfo.length - 3];        Arrays.fill(ps, (byte) 0xFF);        // 构造最终的结果        byte[] encoded = new byte[emLen];        encoded[0] = 0x00;        encoded[1] = 0x01;        System.arraycopy(ps, 0, encoded, 2, ps.length);        encoded[ps.length + 2] = 0x00;        System.arraycopy(digestInfo, 0, encoded, ps.length + 3, digestInfo.length);        System.out.println(&quot;r：对DER 编码的证书信息(即来自该证书的tbsCertificate) 进行sha265摘要计算，计算的结果转换为ASN1格式数据，ASN1格式数据再进行填充得到的&quot;);        System.out.println(new BigInteger(encoded));        System.out.println();    &#125;&#125;\n\n参考资料介绍一个”牛逼闪闪”开源库：ja-netfilter\nja-netfilter power插件原理\n注册码证书验证过程\n插件?插件的破解其实是一模一样的,当你配置好agent后,使用激活码生成工具,修改licensePart中的products.code为插件的code即可\nidea 所需 code&#123;    &quot;licenseeName&quot;: &quot;your licenseeName&quot;,    &quot;assigneeName&quot;: &quot;your assigneeName&quot;,    &quot;products&quot;: [        &#123;            &quot;code&quot;: &quot;II&quot;,            &quot;fallbackDate&quot;: &quot;2999-08-19&quot;,            &quot;paidUpTo&quot;: &quot;2999-08-19&quot;        &#125;,        &#123;            &quot;code&quot;: &quot;PSI&quot;,            &quot;fallbackDate&quot;: &quot;2999-08-19&quot;,            &quot;paidUpTo&quot;: &quot;2999-08-19&quot;        &#125;,        &#123;            &quot;code&quot;: &quot;PCWMP&quot;,            &quot;fallbackDate&quot;: &quot;2999-08-19&quot;,            &quot;paidUpTo&quot;: &quot;2999-08-19&quot;        &#125;    ]&#125;\n\njetbrains产品列表[    &#123;        &quot;code&quot;: &quot;RSCLT&quot;,        &quot;name&quot;: &quot;ReSharper Command Line Tools&quot;,        &quot;description&quot;: &quot;ReSharper Command Line Tools&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;YTWE&quot;,        &quot;name&quot;: &quot;Youtrack Workflow Editor&quot;,        &quot;description&quot;: &quot;Youtrack Workflow Editor&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DG&quot;,        &quot;name&quot;: &quot;DataGrip&quot;,        &quot;description&quot;: &quot;The IDE for databases and SQL&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;PS&quot;,        &quot;name&quot;: &quot;PhpStorm&quot;,        &quot;description&quot;: &quot;A smart IDE for PHP and Web&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;CLN&quot;,        &quot;name&quot;: &quot;CLion Nova&quot;,        &quot;description&quot;: &quot;CLion Nova preview, a faster IDE for C and C++&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RRD&quot;,        &quot;name&quot;: &quot;Rider Remote Debugger&quot;,        &quot;description&quot;: &quot;Tools for Remote Debugging in Rider&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;SPA&quot;,        &quot;name&quot;: &quot;Space Desktop&quot;,        &quot;description&quot;: &quot;A complete software development platform&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;CWMR&quot;,        &quot;name&quot;: &quot;Code With Me Relay&quot;,        &quot;description&quot;: &quot;Relay Server for Code With Me&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DL&quot;,        &quot;name&quot;: &quot;Datalore&quot;,        &quot;description&quot;: &quot;A collaborative data science platform&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;YTD&quot;,        &quot;name&quot;: &quot;YouTrack&quot;,        &quot;description&quot;: &quot;Issue tracker designed for development teams&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DM&quot;,        &quot;name&quot;: &quot;dotMemory&quot;,        &quot;description&quot;: &quot;.NET memory profiler&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;CWML&quot;,        &quot;name&quot;: &quot;Code With Me Lobby&quot;,        &quot;description&quot;: &quot;Lobby Server for Code With Me&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DP&quot;,        &quot;name&quot;: &quot;dotTrace&quot;,        &quot;description&quot;: &quot;.NET performance profiler&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DS&quot;,        &quot;name&quot;: &quot;DataSpell&quot;,        &quot;description&quot;: &quot;The IDE for data analysis&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QA&quot;,        &quot;name&quot;: &quot;Aqua&quot;,        &quot;description&quot;: &quot;A powerful IDE for test automation&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;EHS&quot;,        &quot;name&quot;: &quot;ETW Host Service&quot;,        &quot;description&quot;: &quot;Event Tracing for Windows&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;MPS&quot;,        &quot;name&quot;: &quot;MPS&quot;,        &quot;description&quot;: &quot;An IDE for DSL development&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;SPP&quot;,        &quot;name&quot;: &quot;Space On-Premises&quot;,        &quot;description&quot;: &quot;The integrated team environment&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;TBA&quot;,        &quot;name&quot;: &quot;Toolbox App&quot;,        &quot;description&quot;: &quot;A control panel for your tools and projects&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RDCPPP&quot;,        &quot;name&quot;: &quot;Rider for Unreal Engine&quot;,        &quot;description&quot;: &quot;Smart C++ and Blueprints support to craft the best games&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;MF&quot;,        &quot;name&quot;: &quot;Mono Font&quot;,        &quot;description&quot;: &quot;A free and open source typeface for developers&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDJVM&quot;,        &quot;name&quot;: &quot;Qodana for JVM&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DPCLT&quot;,        &quot;name&quot;: &quot;dotTrace Command Line Tools&quot;,        &quot;description&quot;: &quot;dotTrace Command Line Tools&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDCLD&quot;,        &quot;name&quot;: &quot;Qodana Cloud&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDGO&quot;,        &quot;name&quot;: &quot;Qodana for Go&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;US&quot;,        &quot;name&quot;: &quot;Upsource&quot;,        &quot;description&quot;: &quot;Code review and repository browsing&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDNET&quot;,        &quot;name&quot;: &quot;Qodana for .NET&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RFU&quot;,        &quot;name&quot;: &quot;RiderFlow for Unity&quot;,        &quot;description&quot;: &quot;A plugin for Unity Editor from JetBrains&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;AC&quot;,        &quot;name&quot;: &quot;AppCode&quot;,        &quot;description&quot;: &quot;A smart IDE for iOS and macOS&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;IIC&quot;,        &quot;name&quot;: &quot;IntelliJ IDEA Community Edition&quot;,        &quot;description&quot;: &quot;The IDE for Java and Kotlin enthusiasts&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;IIE&quot;,        &quot;name&quot;: &quot;IntelliJ IDEA Edu&quot;,        &quot;description&quot;: &quot;An educational IDE for coding&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;HCC&quot;,        &quot;name&quot;: &quot;HTTP Client CLI&quot;,        &quot;description&quot;: &quot;Run Requests and Tests on CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;JCD&quot;,        &quot;name&quot;: &quot;JetBrains Clients Downloader&quot;,        &quot;description&quot;: &quot;Download JetBrains Clients for Code With Me and Remote Development&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;IDES&quot;,        &quot;name&quot;: &quot;IDE Services&quot;,        &quot;description&quot;: &quot;A centralized way to provision IntelliJ-based IDEs to your developers’ machines, securely and consistently, across your entire organization.&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DPPS&quot;,        &quot;name&quot;: &quot;dotTrace Profiling SDK&quot;,        &quot;description&quot;: &quot;dotTrace Profiling SDK&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;PCC&quot;,        &quot;name&quot;: &quot;PyCharm Community Edition&quot;,        &quot;description&quot;: &quot;The pure Python IDE&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RC&quot;,        &quot;name&quot;: &quot;ReSharper C++&quot;,        &quot;description&quot;: &quot;Visual Studio extension for C++ developers&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RD&quot;,        &quot;name&quot;: &quot;Rider&quot;,        &quot;description&quot;: &quot;A cross-platform .NET IDE&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;PCE&quot;,        &quot;name&quot;: &quot;PyCharm Edu&quot;,        &quot;description&quot;: &quot;An educational IDE for Python&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;IIU&quot;,        &quot;name&quot;: &quot;IntelliJ IDEA Ultimate&quot;,        &quot;description&quot;: &quot;The Leading Java and Kotlin IDE&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RSU&quot;,        &quot;name&quot;: &quot;ReSharper Tools&quot;,        &quot;description&quot;: &quot;All individual .NET tools combined in one license&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;TCC&quot;,        &quot;name&quot;: &quot;TeamCity Cloud&quot;,        &quot;description&quot;: &quot;Powerful Continuous Integration out of the box&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RSCHB&quot;,        &quot;name&quot;: &quot;ReSharper Checked builds&quot;,        &quot;description&quot;: &quot;ReSharper Checked builds&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDJS&quot;,        &quot;name&quot;: &quot;Qodana for JS&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RM&quot;,        &quot;name&quot;: &quot;RubyMine&quot;,        &quot;description&quot;: &quot;A Ruby and Rails IDE&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DLE&quot;,        &quot;name&quot;: &quot;Datalore Enterprise&quot;,        &quot;description&quot;: &quot;Online Jupyter notebooks&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DMCLP&quot;,        &quot;name&quot;: &quot;dotMemory Command Line Profiler&quot;,        &quot;description&quot;: &quot;dotMemory Command Line Profiler&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;PCP&quot;,        &quot;name&quot;: &quot;PyCharm Professional Edition&quot;,        &quot;description&quot;: &quot;The full-stack Python IDE&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DPK&quot;,        &quot;name&quot;: &quot;dotPeek&quot;,        &quot;description&quot;: &quot;.NET decompiler&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RR&quot;,        &quot;name&quot;: &quot;RustRover&quot;,        &quot;description&quot;: &quot;A powerful IDE for Rust&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;RS&quot;,        &quot;name&quot;: &quot;ReSharper&quot;,        &quot;description&quot;: &quot;Visual Studio extensions&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;FL&quot;,        &quot;name&quot;: &quot;Fleet&quot;,        &quot;description&quot;: &quot;The next-generation IDE by JetBrains&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;FLIJ&quot;,        &quot;name&quot;: &quot;Fleet Backend&quot;,        &quot;description&quot;: &quot;Fleet Backend based on IntelliJ platform&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;FLL&quot;,        &quot;name&quot;: &quot;Fleet Launcher&quot;,        &quot;description&quot;: &quot;Launcher of Fleet workspace for remote use-cases&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;FLS&quot;,        &quot;name&quot;: &quot;Floating License Server&quot;,        &quot;description&quot;: &quot;Application to manage JetBrains product licenses within your company network&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;MPSIIP&quot;,        &quot;name&quot;: &quot;MPS IntelliJ IDEA plugin&quot;,        &quot;description&quot;: &quot;MPS IntelliJ IDEA plugin&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;WRS&quot;,        &quot;name&quot;: &quot;Writerside&quot;,        &quot;description&quot;: &quot;Documentation authoring IDE&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;WS&quot;,        &quot;name&quot;: &quot;WebStorm&quot;,        &quot;description&quot;: &quot;A JavaScript and TypeScript IDE&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;SP&quot;,        &quot;name&quot;: &quot;Space Cloud&quot;,        &quot;description&quot;: &quot;The integrated team environment&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;GO&quot;,        &quot;name&quot;: &quot;GoLand&quot;,        &quot;description&quot;: &quot;An IDE for Go and Web&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;CL&quot;,        &quot;name&quot;: &quot;CLion&quot;,        &quot;description&quot;: &quot;A cross-platform C and C++ IDE&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;KT&quot;,        &quot;name&quot;: &quot;Kotlin&quot;,        &quot;description&quot;: &quot;Statically typed programming language for the JVM, Android and the browser&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDANDC&quot;,        &quot;name&quot;: &quot;Qodana Community for Android&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDJVMC&quot;,        &quot;name&quot;: &quot;Qodana Community for JVM&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DMU&quot;,        &quot;name&quot;: &quot;dotMemory Unit&quot;,        &quot;description&quot;: &quot;Unit testing framework for monitoring .NET memory usage&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;TC&quot;,        &quot;name&quot;: &quot;TeamCity&quot;,        &quot;description&quot;: &quot;Powerful Continuous Integration out of the box&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;GW&quot;,        &quot;name&quot;: &quot;Gateway&quot;,        &quot;description&quot;: &quot;A remote development hub&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDPHP&quot;,        &quot;name&quot;: &quot;Qodana for PHP&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DCCLT&quot;,        &quot;name&quot;: &quot;dotCover Command Line Tools&quot;,        &quot;description&quot;: &quot;.NET unit test runner and code coverage tool&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDPYC&quot;,        &quot;name&quot;: &quot;Qodana Community for Python&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;QDPY&quot;,        &quot;name&quot;: &quot;Qodana for Python&quot;,        &quot;description&quot;: &quot;The code quality platform for your favorite CI&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;HB&quot;,        &quot;name&quot;: &quot;Hub&quot;,        &quot;description&quot;: &quot;JetBrains team tools, integrated&quot;    &#125;,    &#123;        &quot;code&quot;: &quot;DC&quot;,        &quot;name&quot;: &quot;dotCover&quot;,        &quot;description&quot;: &quot;.NET unit test runner and code coverage tool&quot;    &#125;]\n\n仅供学习交流使用以上仅供学习交流使用!!!\n以上仅供学习交流使用!!!\n以上仅供学习交流使用!!!\n","categories":["idea"],"tags":["idea"]},{"title":"hexo部署私人服务器","url":"/2019/10/15/hexo%E9%83%A8%E7%BD%B2%E7%A7%81%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"一、开始配置本地 node 环境\nnode下载 官网下载，可以的话推荐使用 nvm 安装\n\n安装记得把目录改到其他盘，这里我具体是在 D:\\programming\\nodejs\n\n\n\n\n\n\n打开cmd查看node安装情况\nnode -vnpm -v\n\n\n配置全局环境\n\n进入安装目录，创建文件夹node_global和node_cache 并执行\nnpm config set prefix &quot;D:\\programming\\nodejs\\node_global&quot;npm config set cache &quot;D:\\programming\\nodejs\\node_cache&quot;\n\n环境配置：新增环境变量NODE_PATH和添加Path，两个值都为 D:\\programming\\nodejs\\node_global\n\n\n\n\n\n安装hexo-cli\n\nnpm i hexo-cli -ghexo\n\n如果显示下面情况，恭喜你成功全局模块调用\n\n\n\n如果出现命令未找到，或不是可执行程序，别着急！先仔细重复 3-4 步，一般是能够给解决的，如果实在是不能解决，往后看\n\n随便找个地方初始化文件，执行如下命令：\n\n\nmkdir hexo-blogcd hexo-blog &amp;&amp; npm init -y\n\n现在有 3 种解决方法，任选其一\n\n法 1：检查全局目录是否的hexo模块，执行如下命令：\n\nD:\\programming\\nodejs\\node_global\\hexo\n\n\n法 2：如果觉得每次加前缀麻烦，使用link命令链接\n\nnpm link hexo\n\npackage.json 中新建脚本如下\nnpm run hexo\n\n\n\n\n法 3：你还可以直接在hexo-blog中下载\n\nnpm i hexo-cli# 还是要在package.json中新建脚本npm run hexo\n\n初始化hexo项目\n如果是按照上一节步骤 4 过来的，则在hexo-blog文件下初始化\n\nhexo init myblog &amp;&amp; cd myblognpm i\n\n\n下载主题\n\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n\n在本地配置文件中设置theme属性\n\n\n\n本地执行hexo项目，添加start脚本\n\nnpm start\n\n\n\n打开 http://localhost:4000 验证效果吧\ngit环境搭建\ngit安装：官网下载\n\n生成ssh认证，执行如下命令\n\n\ngit config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail@example.com&quot;ssh-keygen -t rsa -C &quot;youremail@example.com&quot;# 禁用自动转换，这个不设置后面上传时会出现警告git config --global core.autocrlf false\n\n\n\n最后获取到的ssh认证在C:\\Users\\yourname\\.ssh中\n\n三、服务器配置搭建远程Git私库\n登录到远程服务器，推荐使用Xshell 5\n\n安装 git\n\n\nCentOS\n# 如无，则安装git --versionyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y git\n\nUbuntu\n# 如无，则安装git --versionsudo apt-get updateapt install git\n\n\n创建用户并配置其仓库\n\nuseradd git# 设置密码passwd git# 这步很重要，不切换用户后面会很麻烦su gitcd /home/git/# 项目存在的真实目录mkdir -p projects/blogmkdir repos &amp;&amp; cd repos# 创建一个裸露的仓库git init --bare blog.gitcd blog.git/hooks# 创建 hook 钩子函数，输入了内容如下vi post-receive\n\n#!/bin/shgit --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f\n\n添加完毕后修改权限\nchmod +x post-receive# 退出到 root 登录exit# 添加权限chown -R git:git /home/git/repos/blog.git\n\n\n测试git仓库是否可用，另找空白文件夹\n\ngit clone git@&#123;server_ip&#125;:/home/git/repos/blog.git\n\n如果能把空仓库拉下来，就说明 git 仓库搭建成功了\n\n\n\n建立ssh信任关系，在本地电脑\n\nssh-copy-id -i C:/Users/&#123;yourname&#125;/.ssh/id_rsa.pub git@&#123;server_ip&#125;# 测试能否登录ssh git@&#123;server_ip&#125;\n\n注：此时的 ssh 登录 git 用户不需要密码！否则就有错，请仔细重复步骤 3-5\n\n为了安全起见禁用 git 用户的 shell 登录权限，从而只能用 git clone，git push 等登录\n\n# 查看 git-shell 是否在登录方式里面cat /etc/shells# 查看是否安装which git-shell# 添加上2步显示出来的路劲，通常在 /usr/bin/git-shellvi /etc/shells\n\n修改/etc/passwd中的权限\n# 将原来的git:x:1001:1001::/home/git:/bin/bash# 修改为git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n\n搭建nginx服务器\n下载并安装nginx\n\ncd /usr/local/srcwget http://nginx.org/download/nginx-1.15.2.tar.gztar xzvf nginx-1.15.2.tar.gzcd nginx-1.15.2\n\nUbuntu系统需要的依赖库\nsudo apt-get updatesudo apt-get install build-essentialsudo apt-get install libtoolsudo apt-get install libpcre3 libpcre3-devsudo apt-get install zlib1g-devsudo apt-get install opensslsudo apt-get install libssl-dev\n\n# 如果后面还想要配置 SSL 协议，就执行后面一句！./configure./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_modulemake &amp;&amp; make install# 为 nginx 取别名，后面可直接用。用户登出失效，可以修改新增到 `~/.bashrc` 文件alias nginx=&#x27;/usr/local/nginx/sbin/nginx&#x27;\n\n\nalias nginx=&#x27;/usr/local/nginx/sbin/nginx&#x27;\n\n执行文件\nsource ~/.bashrc\n\n\n配置nginx文件\n\n先启动是否安装成功\n# 直接来！浏览器查看 server_ip，默认是 80 端口nginx\n\n修改配置文件\nnginx -s stop // 先停止nginxcd /usr/local/nginx/confvi nginx.conf# 修改 root 解析路径，如下图# 同时将 user 改为 root 如下图，不然nginx无法访问 /home/git/projects/blognginx -s reload\n\nhttp配置\nuser  root;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server &#123;        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / &#123;            root   /home/git/projects/blog;            index  index.html index.htm;        &#125;        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \\.php$ &#123;        #    proxy_pass   http://127.0.0.1;        #&#125;        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \\.php$ &#123;        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #&#125;        # deny access to .htaccess files, if Apache&#x27;s document root        # concurs with nginx&#x27;s one        #        #location ~ /\\.ht &#123;        #    deny  all;        #&#125;    &#125;    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server &#123;    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / &#123;    #        root   html;    #        index  index.html index.htm;    #    &#125;    #&#125;    # HTTPS server    #    #server &#123;    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location / &#123;    #        root   html;    #        index  index.html index.htm;    #    &#125;    #&#125;&#125;\n\nhttps配置\nuser  root;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server &#123;        listen        80;        server_name   aliatry.com;\t\t        rewrite       ^/(.*) https://$host$1 permanent;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / &#123;            #root   /home/git/projects/blog;            index  index.html index.htm;        &#125;        error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \\.php$ &#123;        #    proxy_pass   http://127.0.0.1;        #&#125;        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \\.php$ &#123;        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #&#125;        # deny access to .htaccess files, if Apache&#x27;s document root        # concurs with nginx&#x27;s one        #        #location ~ /\\.ht &#123;        #    deny  all;        #&#125;    &#125;    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server &#123;    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / &#123;    #        root   html;    #        index  index.html index.htm;    #    &#125;    #&#125;    # HTTPS server    #    server &#123;        listen       443 ssl;        server_name  aliatry.com;        ssl_certificate      cert.pem;        ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;        ssl_session_timeout  5m;        ssl_ciphers  ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;        ssl_prefer_server_ciphers  on;        ssl_protocols     TLSv1 TLSv1.1 TLSv1.2;        location / &#123;            root   /home/git/projects/blog;            index  index.html index.htm;        &#125;    &#125;&#125;\n\n\n\n\n\n\n四、发布至此我们就把本地和服务器的环境全部搭建完成，现在利用 hexo 配置文件进行链接\n配置_config.yml文件\n编辑 _config.yml 的 deploy 属性\n\ndeploy:  type: git  branch: master  repository:     server: git@server_ip:/home/git/repos/blog.git\n\n\n\n在 package.json 中添加 npm 脚本\n\n&quot;scripts&quot;: &#123;  &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;,  &quot;start&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;&#125;,\n\n\n链接！这下在本地调试就用npm start，调试好了就上传到服务器，美滋滋~快通过你的服务器 ip 访问吧\n\nnpm run deploy\n","categories":["hexo","部署"],"tags":["hexo","部署","Nginx"]},{"title":"idea建立WebServlet遇到的问题","url":"/2017/06/06/idea%E5%BB%BA%E7%AB%8BWebServlet%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","content":"直接用idea建立的web项目，其自动生成的web.xml，这样建立servlet-name等标签会报错（不支持这种做法，更提倡用注解的办法），解决办法是将web-app标签替换成以下的3.0版本&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;         version=&quot;3.0&quot;&gt;\n\n\n\n随后创建 Java 类 继承 javax.servlet.http.HttpServletimport javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/hello&quot;)public class selectServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doPost(req, resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;Simon&quot;);    &#125;&#125;\n\n利用注解进行配置//在servlet类的上面写入注解@WebServlet(&quot;/hello&quot;)@WebServlet(&quot;/hello&quot;)\n\npom.xml 配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;chapter6d4&lt;/name&gt;    &lt;groupId&gt;com&lt;/groupId&gt;    &lt;artifactId&gt;chapter6d4&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;            &lt;version&gt;5.2.12.Final&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/com.hynnet/oracle-driver-ojdbc --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.oracle&lt;/groupId&gt;            &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;            &lt;version&gt;12.1.0.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n","categories":["idea","web.xml"],"tags":["idea","servlet","javaweb","web.xml"]},{"title":"linux下使用apt-get下载jdk8","url":"/2018/12/14/linux%E4%B8%8B%E4%BD%BF%E7%94%A8apt-get%E4%B8%8B%E8%BD%BDjdk8/","content":"Linux下使用apt-get下载jdk8apt-get更新到最新sudo apt-get update\n下载安装sudo apt install openjdk-8-jdk\n\n\n\n查看版本号java -version\n输出下面版本号则安装成功\nopenjdk version &quot;1.8.0_191&quot;OpenJDK Runtime Environment (build 1.8.0_191-8u191-b12-0ubuntu0.16.04.1-b12)OpenJDK 64-Bit Server VM (build 25.191-b12, mixed mode)\n","categories":["linux","jdk8"],"tags":["linux","apt-get","jdk8"]},{"title":"lsof Linux安装","url":"/2019/10/15/lsof-Linux%E5%AE%89%E8%A3%85/","content":"yum install lsof\n\n[root@aliatry ~]# yum install lsofLoaded plugins: fastestmirrorDetermining fastest mirrorsbase                                                                                                                                              | 3.6 kB  00:00:00     epel                                                                                                                                              | 5.3 kB  00:00:00     extras                                                                                                                                            | 2.9 kB  00:00:00     mysql-connectors-community                                                                                                                        | 2.5 kB  00:00:00     mysql-tools-community                                                                                                                             | 2.5 kB  00:00:00     mysql57-community                                                                                                                                 | 2.5 kB  00:00:00     updates                                                                                                                                           | 2.9 kB  00:00:00     (1/9): base/7/x86_64/group_gz                                                                                                                     | 165 kB  00:00:00     (2/9): extras/7/x86_64/primary_db                                                                                                                 | 152 kB  00:00:00     (3/9): epel/x86_64/updateinfo                                                                                                                     | 1.0 MB  00:00:00     (4/9): base/7/x86_64/primary_db                                                                                                                   | 6.0 MB  00:00:00     (5/9): updates/7/x86_64/primary_db                                                                                                                | 1.9 MB  00:00:00     (6/9): mysql-connectors-community/x86_64/primary_db                                                                                               |  48 kB  00:00:00     (7/9): epel/x86_64/primary_db                                                                                                                     | 6.9 MB  00:00:00     (8/9): mysql-tools-community/x86_64/primary_db                                                                                                    |  66 kB  00:00:00     (9/9): mysql57-community/x86_64/primary_db                                                                                                        | 190 kB  00:00:00     Resolving Dependencies--&gt; Running transaction check---&gt; Package lsof.x86_64 0:4.87-6.el7 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved========================================================================================================================================================================= Package                               Arch                                    Version                                       Repository                             Size=========================================================================================================================================================================Installing: lsof                                  x86_64                                  4.87-6.el7                                    base                                  331 kTransaction Summary=========================================================================================================================================================================Install  1 PackageTotal download size: 331 kInstalled size: 927 kIs this ok [y/d/N]: yDownloading packages:lsof-4.87-6.el7.x86_64.rpm                                                                                                                        | 331 kB  00:00:00     Running transaction checkRunning transaction testTransaction test succeededRunning transaction  Installing : lsof-4.87-6.el7.x86_64                                                                                                                                1/1  Verifying  : lsof-4.87-6.el7.x86_64                                                                                                                                1/1Installed:  lsof.x86_64 0:4.87-6.el7                                                                                                                                               Complete!\n","categories":["linux"],"tags":["linux"]},{"title":"nohup /dev/null 2>&1 含义详解","url":"/2018/12/07/nohup-dev-null-2-1-%E5%90%AB%E4%B9%89%E8%AF%A6%E8%A7%A3/","content":"nohup &#x2F;dev&#x2F;null 2&gt;&amp;1 含义详解nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户&#x2F;关闭终端之后继续运行相应的进程。nohup就是不挂起的意思(no hang up)。\n\n\n该命令的一般形式为：nohup command &amp;\nls xxx 1&gt;out.txt 2&gt;&amp;1nohup java -jar helloword.jar &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;对 于&amp; 1 更准确的说应该是文件描述符 1,而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO),其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了.其中0 表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到&#x2F;DEV&#x2F;NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。command &gt;out.file 2&gt;&amp;1 &amp;command &gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。 2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp; ， 是让该命令在后台执行。\n试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.\n你可以用ls 2&gt;1测试一下，不会报没有2文件的错误，但会输出一个空的文件1；ls xxx 2&gt;1测试，没有xxx这个文件的错误输出到了1中；ls xxx 2&gt;&amp;1测试，不会生成1这个文件了，不过错误跑到标准输出了；ls xxx &gt;out.txt 2&gt;&amp;1, 实际上可换成 ls xxx 1&gt;out.txt 2&gt;&amp;1；重定向符号&gt;默认是1,错误和输出都传到out.txt了。\n为何2&gt;&amp;1要写在后面？command &gt; file 2&gt;&amp;1首先是command &gt; file将标准输出重定向到file中， 2&gt;&amp;1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。command 2&gt;&amp;1 &gt;file2&gt;&amp;1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。&gt;file 后输出才被重定向到file，但标准错误仍然保持在终端。\n用strace可以看到：\n\ncommand &gt; file 2&gt;&amp;1这个命令中实现重定向的关键系统调用序列是：open(file) &#x3D;&#x3D; 3dup2(3,1)dup2(1,2)\n\ncommand 2&gt;&amp;1 &gt;file这个命令中实现重定向的关键系统调用序列是：dup2(1,2)open(file) &#x3D;&#x3D; 3dup2(3,1)\n\n\n为什么要用 &#x2F;dev&#x2F;null 2&gt;&amp;1 这样的写法.这条命令的意思是将标准输出和错误输出全部重定向到&#x2F;dev&#x2F;null中,也就是将产生的所有信息丢弃.下面我就为大家来说一下, command &gt; file 2&gt;file   与command &gt; file 2&gt;&amp;1 有什么不同的地方.首先~command &gt; file 2&gt;file 的意思是将命令所产生的标准输出信息,和错误的输出信息送到file 中.command   &gt; file 2&gt;file 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file 的管道.而command &gt;file 2&gt;&amp;1 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file 只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容.从IO效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写shell脚本的时候,较多的时候我们会用command &gt; file 2&gt;&amp;1 这样的写法.\n","categories":["linux","nohup"],"tags":["linux","nohup"]},{"title":"linux下使用wget下载jdk8","url":"/2018/12/04/linux%E4%B8%8B%E4%BD%BF%E7%94%A8wget%E4%B8%8B%E8%BD%BDjdk8/","content":"进到目录&#x2F;usr&#x2F;local&#x2F;softwarecd /usr/local/software\n\n下载jdk8到本地wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;\n\n\n\n解压文件夹tar -zxvf jdk-8u141-linux-x64.tar.gz jdk1.8.0_141/  \n\n修改解压后文件夹名为jdk8mv jdk1.8.0_141 jdk8\n\n配置环境变量vim /etc/profile\n\n加入\nexport JAVA_HOME=/usr/local/software/jdk8export JAVA_BIN=/usr/local/software/jdk8export PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME JAVA_BIN PATH CLASSPATH\n\n环境变量立即生效source /etc/profile\n\n查看Java版本号java -version\n\n输出结果java version &quot;1.8.0_141&quot;Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)\n","categories":["linux","wget","java","jdk8"],"tags":["linux","java","wget","jdk8"]},{"title":"spring 控制反转（IOC）与 面向切面编程 （AOP）示例","url":"/2018/05/16/spring-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IOC%EF%BC%89%E4%B8%8E-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-%EF%BC%88AOP%EF%BC%89%E7%A4%BA%E4%BE%8B/","content":"spring （由Rod Johnson创建的一个开源框架）Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源框架。\n\n\npom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com&lt;/groupId&gt;    &lt;artifactId&gt;springDemo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\nUserDao 接口类package com.dao;import com.pojo.User;public interface UserDao &#123;    User queryUser(String userName);&#125;\n\nUserService 接口类package com.service;import com.pojo.User;public interface UserService &#123;    User queryUser(String userName);&#125;\n\nApplicationContextUtil 工具类package com.util;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ApplicationContextUtil &#123;    public static ClassPathXmlApplicationContext context;    static &#123;        context = new ClassPathXmlApplicationContext(&quot;applicationContextAop.xml&quot;);    &#125;&#125;\n\nXML方式配置applicationContextAop.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--setter 设值注入--&gt;    &lt;bean name=&quot;peter&quot; class=&quot;com.pojo.User&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Peter&quot;/&gt;        &lt;property name=&quot;info&quot; value=&quot;Peter-info&quot;/&gt;    &lt;/bean&gt;    &lt;!--构造方法 构造注入--&gt;    &lt;bean name=&quot;simon&quot; class=&quot;com.pojo.User&quot;&gt;        &lt;constructor-arg index=&quot;0&quot; value=&quot;Simon&quot;/&gt;        &lt;constructor-arg index=&quot;1&quot; value=&quot;Simon-info&quot;/&gt;    &lt;/bean&gt;    &lt;!--setter p命名空间注入--&gt;    &lt;bean name=&quot;admin&quot; class=&quot;com.pojo.User&quot; p:name=&quot;admin&quot; p:info=&quot;admin-info&quot;/&gt;    &lt;bean name=&quot;userLog&quot; class=&quot;com.log.UserLog&quot;/&gt;    &lt;aop:config&gt;        &lt;!--定义切入点 expression 值 必须写到 execution() 里面--&gt;        &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.pojo..*.*(..))&quot;/&gt;        &lt;aop:pointcut id=&quot;pointAll&quot; expression=&quot;execution(* *.*(..))&quot;/&gt;        &lt;aop:aspect ref=&quot;userLog&quot;&gt;            &lt;!--method 指定 com.log.UserLog 里面的方法  pointcut-ref 为上面的定义切入点--&gt;            &lt;!--前置增强--&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;            &lt;!--后置增强--&gt;            &lt;aop:after-returning method=&quot;returning&quot; pointcut-ref=&quot;point&quot; returning=&quot;result&quot;/&gt;            &lt;!--环绕增强--&gt;            &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;point&quot;/&gt;            &lt;!--最终增强--&gt;            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;            &lt;!--异常抛出增强--&gt;            &lt;aop:after-throwing method=&quot;throwing&quot; pointcut-ref=&quot;pointAll&quot; throwing=&quot;e&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;    &lt;bean name=&quot;userDao&quot; class=&quot;com.dao.impl.UserDaoImpl&quot;/&gt;    &lt;bean name=&quot;userService&quot; class=&quot;com.service.impl.UserServiceImpl&quot;&gt;        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;    &lt;/bean&gt;    &lt;bean name=&quot;userServlet&quot; class=&quot;com.servlet.UserServlet&quot;&gt;        &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nUserLog 面向切面编程 （AOP）类package com.log;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import java.util.Arrays;public class UserLog &#123;    /**     * 前置增强     */    public void before(JoinPoint joinPoint) &#123;        System.out.println(&quot;调用前置增强 &quot; + joinPoint.getTarget() + &quot; 的 &quot; + joinPoint.getSignature().                getName() + &quot; 方法。方法入参: &quot; + Arrays.toString(joinPoint.getArgs()));    &#125;    /**     * 后置增强     */    public void returning(JoinPoint joinPoint, Object result) &#123;        System.out.println(&quot;调用后置增强 &quot; + joinPoint.getTarget() + &quot; 的 &quot; + joinPoint.getSignature().                getName() + &quot; 方法。方法返回值: &quot; + result);    &#125;    /**     * 环绕增强     */    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;        System.out.println(&quot;调用环绕增强 &quot; + pjp.getTarget() + &quot; 的 &quot; + pjp.getSignature().                getName() + &quot; 方法。方法入参: &quot; + Arrays.toString(pjp.getArgs()));//        异常必须抛出,不然异常抛出增强进不去        Object proceed = pjp.proceed();        System.out.println(&quot;调用环绕增强 &quot; + pjp.getTarget() + &quot; 的 &quot; + pjp.getSignature().                getName() + &quot; 方法。方法返回值: &quot; + proceed);        return proceed;    &#125;    /**     * 最终增强     */    public void after(JoinPoint joinPoint) &#123;        System.out.println(&quot;调用最终增强 &quot; + joinPoint.getSignature().getName() + &quot; 方法结束执行&quot;);    &#125;    /**     * 异常抛出增强     */    public void throwing(JoinPoint joinPoint, Exception e) &#123;        System.out.println(&quot;调用异常抛出增强 &quot; + joinPoint.getSignature().getName() + &quot; 方法发生异常: &quot; + e);    &#125;&#125;\n\nUserDaoImpl 实现类package com.dao.impl;import com.dao.UserDao;import com.pojo.User;import com.util.ApplicationContextUtil;public class UserDaoImpl implements UserDao &#123;    public User queryUser(String userName) &#123;        User user = ApplicationContextUtil.context.getBean(userName, User.class);        user.print();        return user;    &#125;&#125;\n\nUserServiceImpl 实现类package com.service.impl;import com.dao.UserDao;import com.pojo.User;import com.service.UserService;public class UserServiceImpl implements UserService &#123;    private UserDao userDao;    public User queryUser(String userName) &#123;        if (userName == null)            throw new RuntimeException(&quot;自定义异常触发&quot;);        return userDao.queryUser(userName);    &#125;    /**     * 提供设置UserDao的setter方法     */    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;&#125;\n\nUserServlet 实现类package com.servlet;import com.service.UserService;public class UserServlet &#123;    private UserService userService;    public void doGet(String userName) &#123;        userService.queryUser(userName);    &#125;    /**     * 提供设置UserService的setter方法     */    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;&#125;\n\n注解方式配置applicationContextAop.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--setter 设值注入--&gt;    &lt;bean name=&quot;peter&quot; class=&quot;com.pojo.User&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Peter&quot;/&gt;        &lt;property name=&quot;info&quot; value=&quot;Peter-info&quot;/&gt;    &lt;/bean&gt;    &lt;!--构造方法 构造注入--&gt;    &lt;bean name=&quot;simon&quot; class=&quot;com.pojo.User&quot;&gt;        &lt;constructor-arg index=&quot;0&quot; value=&quot;Simon&quot;/&gt;        &lt;constructor-arg index=&quot;1&quot; value=&quot;Simon-info&quot;/&gt;    &lt;/bean&gt;    &lt;!--setter p命名空间注入--&gt;    &lt;bean name=&quot;admin&quot; class=&quot;com.pojo.User&quot; p:name=&quot;admin&quot; p:info=&quot;admin-info&quot;/&gt;    &lt;!--扫描哪个包的注解--&gt;    &lt;context:component-scan base-package=&quot;com&quot;/&gt;    &lt;!--面向切面编程 （AOP）使用注解增强处理--&gt;    &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt;\n\nUserLog 面向切面编程 （AOP）类package com.log;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspectpublic class UserLog &#123;    /**     * 前置增强     */    @Before(value = &quot;execution(* com.pojo..*.*(..))&quot;)    public void before(JoinPoint joinPoint) &#123;        System.out.println(&quot;调用前置增强 &quot; + joinPoint.getTarget() + &quot; 的 &quot; + joinPoint.getSignature().                getName() + &quot; 方法。方法入参: &quot; + Arrays.toString(joinPoint.getArgs()));    &#125;    /**     * 后置增强     */    @AfterReturning(value = &quot;execution(* com.pojo..*.*(..))&quot;, returning = &quot;result&quot;)    public void returning(JoinPoint joinPoint, Object result) &#123;        System.out.println(&quot;调用后置增强 &quot; + joinPoint.getTarget() + &quot; 的 &quot; + joinPoint.getSignature().                getName() + &quot; 方法。方法返回值: &quot; + result);    &#125;    /**     * 环绕增强     */    @Around(value = &quot;execution(* com.pojo..*.*(..))&quot;)    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;        System.out.println(&quot;调用环绕增强 &quot; + pjp.getTarget() + &quot; 的 &quot; + pjp.getSignature().                getName() + &quot; 方法。方法入参: &quot; + Arrays.toString(pjp.getArgs()));//        异常必须抛出,不然异常抛出增强进不去        Object proceed = pjp.proceed();        System.out.println(&quot;调用环绕增强 &quot; + pjp.getTarget() + &quot; 的 &quot; + pjp.getSignature().                getName() + &quot; 方法。方法返回值: &quot; + proceed);        return proceed;    &#125;    /**     * 最终增强     */    @After(value = &quot;execution(* com.pojo..*.*(..))&quot;)    public void after(JoinPoint joinPoint) &#123;        System.out.println(&quot;调用最终增强 &quot; + joinPoint.getSignature().getName() + &quot; 方法结束执行&quot;);    &#125;    /**     * 异常抛出增强     */    @AfterThrowing(value = &quot;execution(* *.*(..))&quot;, throwing = &quot;e&quot;)    public void throwing(JoinPoint joinPoint, Exception e) &#123;        System.out.println(&quot;调用异常抛出增强 &quot; + joinPoint.getSignature().getName() + &quot; 方法发生异常: &quot; + e);    &#125;&#125;\n\nUserDaoImpl 实现类package com.dao.impl;import com.dao.UserDao;import com.pojo.User;import com.util.ApplicationContextUtil;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.stereotype.Component;import org.springframework.stereotype.Repository;//@Component(&quot;userDao&quot;)/** * Repository 等同 Component */@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123;    public User queryUser(String userName) &#123;        User user = ApplicationContextUtil.context.getBean(userName, User.class);        user.print();        return user;    &#125;&#125;\n\nUserServiceImpl 实现类package com.service.impl;import com.dao.UserDao;import com.pojo.User;import com.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;import javax.annotation.Resource;//@Component(&quot;userService&quot;)/** * Service 等同 Component */@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123;//    @Autowired//    @Qualifier(&quot;userDao&quot;)    /**     * Resource 等同 Autowired 与 Qualifier 的结合     */    @Resource(name = &quot;userDao&quot;)    private UserDao userDao;    public User queryUser(String userName) &#123;        if (userName == null)            throw new RuntimeException(&quot;自定义异常触发&quot;);        return userDao.queryUser(userName);    &#125;    /**     * 提供设置UserDao的setter方法     */    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;&#125;\n\nUserServlet 实现类package com.servlet;import com.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;import org.springframework.stereotype.Controller;import javax.annotation.Resource;//@Component(&quot;userServlet&quot;)/** * Controller 控制层等同Component */@Controller(&quot;userServlet&quot;)public class UserServlet &#123;//    @Autowired//    @Qualifier(&quot;userService&quot;)    /**     * Resource 不给值会自动匹配去找类型一致的UserService 等同 Autowired 与 Qualifier 的结合     */    @Resource    private UserService userService;    public void doGet(String userName) &#123;        userService.queryUser(userName);    &#125;    /**     * 提供设置UserService的setter方法     */    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;&#125;\n\nUser 实体类package com.pojo;public class User &#123;    private String name;    private String info;    public User() &#123;    &#125;    public User(String name, String info) &#123;        this.name = name;        this.info = info;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, info=&#x27;&quot; + info + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public void print() &#123;        System.out.println(toString());    &#125;    public void Runtime() &#123;        throw new RuntimeException(&quot;禁止输出&quot;);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getInfo() &#123;        return info;    &#125;    public void setInfo(String info) &#123;        this.info = info;    &#125;&#125;\n\nmain 测试类package com.test;import com.servlet.UserServlet;import com.util.ApplicationContextUtil;public class main &#123;    public static void main(String[] args) &#123;        UserServlet userServlet = ApplicationContextUtil.context.getBean(&quot;userServlet&quot;, UserServlet.class);        System.out.println(&quot;控制反转（IOC）输出测试--------------------------------------------&quot;);        userServlet.doGet(&quot;simon&quot;);        userServlet.doGet(&quot;admin&quot;);        userServlet.doGet(&quot;peter&quot;);        System.out.println(&quot;面向切面编程（AOP）测试--------------------------------------------&quot;);        userServlet.doGet(&quot;admin&quot;);        System.out.println(&quot;面向切面编程（AOP）异常抛出增强测试----------------------------------&quot;);        userServlet.doGet(null);    &#125;&#125;\n\nXML方式配置 控制台输出控制反转（IOC）输出测试--------------------------------------------调用前置增强 User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125; 的 print 方法。方法入参: []调用环绕增强 User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125; 的 print 方法。方法入参: []User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125;调用最终增强 print 方法结束执行调用环绕增强 User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125; 的 print 方法。方法返回值: null调用后置增强 User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125; 的 print 方法。方法返回值: null调用前置增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法入参: []调用环绕增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法入参: []User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125;调用最终增强 print 方法结束执行调用环绕增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法返回值: null调用后置增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法返回值: null调用前置增强 User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125; 的 print 方法。方法入参: []调用环绕增强 User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125; 的 print 方法。方法入参: []User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125;调用最终增强 print 方法结束执行调用环绕增强 User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125; 的 print 方法。方法返回值: null调用后置增强 User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125; 的 print 方法。方法返回值: null面向切面编程（AOP）测试--------------------------------------------调用前置增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法入参: []调用环绕增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法入参: []User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125;调用最终增强 print 方法结束执行调用环绕增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法返回值: null调用后置增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法返回值: null面向切面编程（AOP）异常抛出增强测试----------------------------------调用异常抛出增强 queryUser 方法发生异常: java.lang.RuntimeException: 自定义异常触发调用异常抛出增强 doGet 方法发生异常: java.lang.RuntimeException: 自定义异常触发\n\n注解方式配置 控制台输出控制反转（IOC）输出测试--------------------------------------------调用环绕增强 User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125; 的 print 方法。方法入参: []调用前置增强 User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125; 的 print 方法。方法入参: []User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125;调用环绕增强 User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125; 的 print 方法。方法返回值: null调用最终增强 print 方法结束执行调用后置增强 User&#123;name=&#x27;Simon&#x27;, info=&#x27;Simon-info&#x27;&#125; 的 print 方法。方法返回值: null调用环绕增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法入参: []调用前置增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法入参: []User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125;调用环绕增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法返回值: null调用最终增强 print 方法结束执行调用后置增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法返回值: null调用环绕增强 User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125; 的 print 方法。方法入参: []调用前置增强 User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125; 的 print 方法。方法入参: []User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125;调用环绕增强 User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125; 的 print 方法。方法返回值: null调用最终增强 print 方法结束执行调用后置增强 User&#123;name=&#x27;Peter&#x27;, info=&#x27;Peter-info&#x27;&#125; 的 print 方法。方法返回值: null面向切面编程（AOP）测试--------------------------------------------调用环绕增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法入参: []调用前置增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法入参: []User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125;调用环绕增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法返回值: null调用最终增强 print 方法结束执行调用后置增强 User&#123;name=&#x27;admin&#x27;, info=&#x27;admin-info&#x27;&#125; 的 print 方法。方法返回值: null面向切面编程（AOP）异常抛出增强测试----------------------------------调用异常抛出增强 queryUser 方法发生异常: java.lang.RuntimeException: 自定义异常触发调用异常抛出增强 doGet 方法发生异常: java.lang.RuntimeException: 自定义异常触发\n","categories":["spring","配置"],"tags":["spring","控制反转","面向切面编程","IOC","AOP","xml","注解"]},{"title":"springMVC REST风格 以及 利用ajax返回JSON数据 中文乱码 返回方式 SSM框架示例","url":"/2018/07/26/springMVC-REST%E9%A3%8E%E6%A0%BC-%E4%BB%A5%E5%8F%8A-%E5%88%A9%E7%94%A8ajax%E8%BF%94%E5%9B%9EJSON%E6%95%B0%E6%8D%AE-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81-%E8%BF%94%E5%9B%9E%E6%96%B9%E5%BC%8F-SSM%E6%A1%86%E6%9E%B6%E7%A4%BA%E4%BE%8B/","content":"springMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2(一般老项目使用)等。\n\n\npom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;SSM-school&lt;/name&gt;    &lt;groupId&gt;com&lt;/groupId&gt;    &lt;artifactId&gt;SSM-school&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!--spring AOP就是用aspectj来实现的，是依赖关系--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.8.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring-webmvc --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--事务--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--初始化会话工厂--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis框架--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis与spring对接的jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql 数据库--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.44&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--数据源--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--JSP 标准标签库 (JSTL)--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--json转换工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.47&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n数据库DROP DATABASE IF EXISTS `school`;CREATE DATABASE `school`;USE `school`;CREATE TABLE `classes`(\t`id` INT PRIMARY KEY AUTO_INCREMENT,\t`name` VARCHAR(50))CHARSET=utf8;CREATE TABLE `student`(\t`id` INT PRIMARY KEY AUTO_INCREMENT,\t`name` VARCHAR(50) NOT NULL,\t`age` INT NOT NULL,\t`gender` VARCHAR(2) NOT NULL,\t`telephone` VARCHAR(20) NOT NULL,\t`email` VARCHAR(50) NOT NULL,\t`classId` INT)CHARSET=utf8;INSERT INTO classes VALUES(DEFAULT,&#x27;one&#x27;),(DEFAULT,&#x27;two&#x27;),(DEFAULT,&#x27;three&#x27;);INSERT INTO student VALUES(DEFAULT,&#x27;张三&#x27;,14,&#x27;男&#x27;,&#x27;10086&#x27;,&#x27;admin@icloud.com&#x27;,1);INSERT INTO student VALUES(DEFAULT,&#x27;李四&#x27;,15,&#x27;女&#x27;,&#x27;10086&#x27;,&#x27;admin@icloud.com&#x27;,2);INSERT INTO student VALUES(DEFAULT,&#x27;王五&#x27;,16,&#x27;男&#x27;,&#x27;10086&#x27;,&#x27;admin@icloud.com&#x27;,3);SELECT * FROM `classes`;SELECT s.*,c.`id` &#x27;classes.id&#x27;,c.`name` &#x27;classes.name&#x27; FROM `student` s,`classes` c WHERE s.`classId`=c.`id`;\n\ndatabase.properties 数据库配置文件db_url=jdbc:mysql://localhost:3306/schooldb_driver=com.mysql.jdbc.Driverdb_username=rootdb_password=simon\n\n实体类 pojoStudent 学生类package com.pojo;public class Student &#123;    private Integer id;    private String name;    private Integer age;    private String gender;    private String telephone;    private String email;    private Classes classes;    //省略getter和setter&#125;\n\nClasses 年级类package com.pojo;public class Classes &#123;    private Integer id;    private String name;    //省略getter和setter&#125;\n\nDAO层StudentDao DAO层package com.dao;import com.pojo.Student;import org.apache.ibatis.annotations.Param;import java.util.List;public interface StudentDao &#123;    List&lt;Student&gt; getStudents();    Student getStudent(@Param(&quot;id&quot;) Integer id);    Integer addStudent(Student student);&#125;\n\nClassesDao DAO层package com.dao;import com.pojo.Classes;import java.util.List;public interface ClassesDao &#123;    List&lt;Classes&gt; getClasses();&#125;\n\nservice层ClassesBizpackage com.biz;import com.pojo.Classes;import java.util.List;public interface ClassesBiz &#123;    List&lt;Classes&gt; getClasses();&#125;\n\nStudentBizpackage com.biz;import com.pojo.Student;import java.util.List;public interface StudentBiz &#123;    List&lt;Student&gt; getStudents();    Student getStudent(Integer id);    Integer addStudent(Student student);&#125;\nserviceImpl实现层ClassesBizImplpackage com.biz.impl;import com.biz.ClassesBiz;import com.dao.ClassesDao;import com.pojo.Classes;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class ClassesBizImpl implements ClassesBiz &#123;    @Resource    private ClassesDao classesDao;    public List&lt;Classes&gt; getClasses() &#123;        return classesDao.getClasses();    &#125;&#125;\n\nStudentBizImplpackage com.biz.impl;import com.biz.StudentBiz;import com.dao.StudentDao;import com.pojo.Student;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class StudentBizImpl implements StudentBiz &#123;    @Resource    private StudentDao studentDao;    public List&lt;Student&gt; getStudents() &#123;        return studentDao.getStudents();    &#125;    public Student getStudent(Integer id) &#123;        return studentDao.getStudent(id);    &#125;    public Integer addStudent(Student student) &#123;        return studentDao.addStudent(student);    &#125;&#125;\nservlet层StudentControllerpackage com.controller;import com.alibaba.fastjson.JSON;import com.biz.ClassesBiz;import com.biz.StudentBiz;import com.pojo.Student;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.annotation.Resource;@Controllerpublic class StudentController &#123;    @Resource    private StudentBiz studentBiz;    @Resource    private ClassesBiz classesBiz;    @RequestMapping(&quot;/showStudents&quot;)    public String showStudents(Model model) &#123;        model.addAttribute(&quot;students&quot;, studentBiz.getStudents());        return &quot;list&quot;;    &#125;    @RequestMapping(&quot;/toAdd&quot;)    public ModelAndView toAdd() &#123;        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;classes&quot;, classesBiz.getClasses());        modelAndView.setViewName(&quot;add&quot;);        return modelAndView;    &#125;    @RequestMapping(&quot;/addStudent&quot;)    public String addStudent(Student student, Model model) &#123;        studentBiz.addStudent(student);        return showStudents(model);    &#125;    /**     * rest风格     * 原地址栏 /view?id=7     * rest风格 /view/7     */    @RequestMapping(&quot;/view/&#123;id&#125;&quot;)    public ModelAndView view(@PathVariable(&quot;id&quot;) Integer id) &#123;        ModelAndView modelAndView = new ModelAndView();        Student student = studentBiz.getStudent(id);        modelAndView.addObject(&quot;student&quot;, student);        modelAndView.setViewName(&quot;view&quot;);        return modelAndView;    &#125;    //局部编码格式配置 produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;    //springMVC.xml JSON全局编码格式已设置    //@ResponseBody 返回JSON注解    @RequestMapping(value = &quot;/stringJson/&#123;id&#125;&quot;)    @ResponseBody    public String stringJson(@PathVariable(&quot;id&quot;) Integer id) &#123;        Student student = studentBiz.getStudent(id);        return JSON.toJSONString(student);    &#125;    //局部编码格式配置 produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;    //springMVC.xml JSON全局编码格式已设置    //@ResponseBody 返回JSON注解    @RequestMapping(value = &quot;/objectJson/&#123;id&#125;&quot;)    @ResponseBody    public Object objectJson(@PathVariable(&quot;id&quot;) Integer id) &#123;        Student student = studentBiz.getStudent(id);        return student;    &#125;&#125;\n\nmybatis-config.xml mybatis配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!-- 打印查询语句 --&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;        &lt;!--达到 自动映射行为 : 全部FULL 局部的PARTIAL 禁止自动匹配NONE--&gt;        &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt;    &lt;/settings&gt;&lt;/configuration&gt;\nXXXMapper配置文件ClassesMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.dao.ClassesDao&quot;&gt;    &lt;select id=&quot;getClasses&quot; resultType=&quot;Classes&quot;&gt;        select * from classes    &lt;/select&gt;&lt;/mapper&gt;\n\nStudentMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.dao.StudentDao&quot;&gt;    &lt;select id=&quot;getStudents&quot; resultType=&quot;Student&quot;&gt;        SELECT s.*,c.`id` &#x27;classes.id&#x27;,c.`name` &#x27;classes.name&#x27;        FROM `student` s,`classes` c        WHERE s.`classId`=c.`id`    &lt;/select&gt;    &lt;insert id=&quot;addStudent&quot;&gt;        INSERT INTO student        VALUES(DEFAULT,#&#123;name&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;telephone&#125;,#&#123;email&#125;,#&#123;classes.id&#125;)    &lt;/insert&gt;    &lt;select id=&quot;getStudent&quot; resultType=&quot;Student&quot;&gt;        SELECT s.*,c.`id` &#x27;classes.id&#x27;,c.`name` &#x27;classes.name&#x27;        FROM `student` s,`classes` c        WHERE s.`classId`=c.`id` and s.id = #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;\n\nspringMVC.xml springMVC配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;       default-autowire=&quot;byName&quot;&gt;    &lt;!--扫描注解的Bean--&gt;    &lt;context:component-scan base-package=&quot;com.controller,com.biz&quot;/&gt;    &lt;!--begin  该事务声明在 application-context.xml 没有任何效果--&gt;    &lt;!--声明式事务--&gt;    &lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; name=&quot;transactionManager&quot;/&gt;    &lt;!--声明式事务管理--&gt;    &lt;!--已配置 default-autowire=&quot;byName&quot; 根据名字自动注入 可不配置属性 transaction-manager=&quot;transactionManager&quot;--&gt;    &lt;tx:advice id=&quot;interceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;!--配置拦截属性--&gt;        &lt;tx:attributes&gt;            &lt;!--REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。--&gt;            &lt;!--SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。--&gt;            &lt;!--MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。--&gt;            &lt;!--REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。--&gt;            &lt;!--NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。--&gt;            &lt;!--NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。--&gt;            &lt;!--NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。--&gt;            &lt;tx:method name=&quot;add*&quot;/&gt;            &lt;tx:method name=&quot;update*&quot;/&gt;            &lt;tx:method name=&quot;del*&quot;/&gt;            &lt;!--配置 get前缀的方法 只读并不支持--&gt;            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; propagation=&quot;NOT_SUPPORTED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--配置面向切面--&gt;    &lt;aop:config&gt;        &lt;!--声明一个切入点--&gt;        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.biz..*.*(..))&quot;/&gt;        &lt;!--定义切面--&gt;        &lt;aop:advisor advice-ref=&quot;interceptor&quot; pointcut-ref=&quot;pointcut&quot;/&gt;    &lt;/aop:config&gt;    &lt;!--end  该事务声明在 application-context.xml 没有任何效果--&gt;    &lt;!--内部资源视图解析器--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!--前缀解析--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!--后缀解析--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!--使 @Controller 注解生效--&gt;    &lt;!--使 @ResponseBody 返回 object 时 利用 alibaba.fastjson 工具 转换--&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters&gt;            &lt;!--解决springmvc返回的json中文问题  --&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                &lt;constructor-arg value=&quot;utf-8&quot;/&gt;            &lt;/bean&gt;            &lt;!--解决springMVC返回的json为object 时进行转换--&gt;            &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;                &lt;property name=&quot;supportedMediaTypes&quot;&gt;                    &lt;list&gt;                        &lt;value&gt;application/json&lt;/value&gt;                    &lt;/list&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;    &lt;!--配置静态文件资源的访问--&gt;    &lt;!--否则 WEB-INF 下的 css 等资源文件访问不到--&gt;    &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/WEB-INF/css/&quot;/&gt;&lt;/beans&gt;\n\napplication-context.xml spring 配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;       default-autowire=&quot;byName&quot;&gt;    &lt;!--default-autowire 配置默认自动注入--&gt;    &lt;!--加载数据库配置文件 database.properties--&gt;    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;        &lt;property name=&quot;location&quot; value=&quot;classpath:database.properties&quot;/&gt;    &lt;/bean&gt;    &lt;!--数据源配置--&gt;    &lt;!--scope 作用域、生存空间 singleton 单例--&gt;    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; name=&quot;dataSource&quot; scope=&quot;singleton&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;db_url&#125;&quot;/&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;db_driver&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;db_username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;db_password&#125;&quot;/&gt;        &lt;!--配置最大连接池数量--&gt;        &lt;!--&lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt;--&gt;        &lt;!--配置获取连接等待超时的时间 单位/毫秒--&gt;        &lt;!--&lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;/&gt;--&gt;    &lt;/bean&gt;    &lt;!--配置会话工厂--&gt;    &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; name=&quot;sessionFactory&quot;&gt;        &lt;!--已配置 default-autowire=&quot;byName&quot; 通过名字自动匹配 可以忽略--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;!--指定类型别名包 XXXMapper.xml 使用--&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.pojo&quot;/&gt;        &lt;!--配置映射器位置--&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mybatis/mapping/xml/*.xml&quot;/&gt;        &lt;!--指定外部配置文件位置 (控制台显示SQL语句)--&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/mybatis-config.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!--Mapper扫描器配置--&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!--扫描所有的dao接口--&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.dao&quot;/&gt;        &lt;!--会话工厂Bean名 默认找键值 sqlSessionFactory 的map --&gt;        &lt;!--所以不用 ref 用value 且会话工厂名字定义为 sessionFactory 因此要多此配置--&gt;        &lt;!--会话工厂配置 name 为 sqlSessionFactory 则不需要配置 sqlSessionFactoryBeanName--&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\nweb.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.4&quot;         xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;    &lt;!--加载spring配置--&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:application-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!--配置监听 (加载spring配置没效果)--&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!--配置spring 作用域可以使用 request 和 session 值--&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!--加载springMVC--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--配置加载的springMVC.xml 默认为 servlet-name 的值 XXX-servlet.xml--&gt;        &lt;!--DispatcherServlet-servlet.xml--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!--配置springMVC加载顺序--&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!--防止中文乱码--&gt;    &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\njsp页面index.jsp&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=showStudents&quot;/&gt;&lt;/body&gt;&lt;/html&gt;\n\nlist.jsp 学生列表页面&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;toAdd&quot;&gt;添加学员&lt;/a&gt;&lt;table border=&quot;1&quot; width=&quot;80%&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;td&gt;编号&lt;/td&gt;        &lt;td&gt;姓名&lt;/td&gt;        &lt;td&gt;性别&lt;/td&gt;        &lt;td&gt;年龄&lt;/td&gt;        &lt;td&gt;电话&lt;/td&gt;        &lt;td&gt;email&lt;/td&gt;        &lt;td&gt;班级&lt;/td&gt;        &lt;td&gt;JSON&lt;/td&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;c:forEach items=&quot;$&#123;students&#125;&quot; var=&quot;student&quot;&gt;        &lt;tr&gt;            &lt;td&gt;$&#123;student.id&#125;&lt;/td&gt;            &lt;td&gt;&lt;a href=&quot;/view/$&#123;student.id&#125;&quot;&gt;$&#123;student.name&#125;&lt;/a&gt;&lt;/td&gt;            &lt;td&gt;$&#123;student.gender&#125;&lt;/td&gt;            &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt;            &lt;td&gt;$&#123;student.telephone&#125;&lt;/td&gt;            &lt;td&gt;$&#123;student.email&#125;&lt;/td&gt;            &lt;td&gt;$&#123;student.classes.name&#125;&lt;/td&gt;            &lt;td&gt;                &lt;a href=&quot;/stringJson/$&#123;student.id&#125;&quot;&gt;stringJson&lt;/a&gt;                &lt;br&gt;                &lt;a href=&quot;/objectJson/$&#123;student.id&#125;&quot;&gt;objectJson&lt;/a&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/c:forEach&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\nadd.jsp 新增学生页面&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;addStudent&quot; method=&quot;post&quot;&gt;    &lt;table border=&quot;1&quot; width=&quot;50%&quot;&gt;        &lt;tr&gt;            &lt;td&gt;姓名&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;性别&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;gender&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;年龄&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;电话&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;telephone&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;email&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;班级&lt;/td&gt;            &lt;td&gt;                &lt;select name=&quot;classes.id&quot;&gt;                    &lt;c:forEach items=&quot;$&#123;classes&#125;&quot; var=&quot;clazz&quot;&gt;                        &lt;option value=&quot;$&#123;clazz.id&#125;&quot;&gt;$&#123;clazz.name&#125;&lt;/option&gt;                    &lt;/c:forEach&gt;                &lt;/select&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=&quot;2&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;增加&quot;/&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\nview.jsp 学生详情页面&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot; width=&quot;80%&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;td&gt;编号&lt;/td&gt;        &lt;td&gt;姓名&lt;/td&gt;        &lt;td&gt;性别&lt;/td&gt;        &lt;td&gt;年龄&lt;/td&gt;        &lt;td&gt;电话&lt;/td&gt;        &lt;td&gt;email&lt;/td&gt;        &lt;td&gt;班级&lt;/td&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr&gt;        &lt;td&gt;$&#123;student.id&#125;&lt;/td&gt;        &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt;        &lt;td&gt;$&#123;student.gender&#125;&lt;/td&gt;        &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt;        &lt;td&gt;$&#123;student.telephone&#125;&lt;/td&gt;        &lt;td&gt;$&#123;student.email&#125;&lt;/td&gt;        &lt;td&gt;$&#123;student.classes.name&#125;&lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\n示例下载 密码: sfgt","categories":["SSM"],"tags":["springMVC","maven","mybatis","JSON","ajax","spring","REST风格","中文乱码"]},{"title":"springcloud feign 多文件上传","url":"/2019/06/05/springcloud-feign-%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"应用场景第三方调用的我的接口,上传若干个文件,我用 MultiPartFile[] 数组接收,之后我调用其他服务的接口,把文件发送过去,统一保存\n目前存在的问题就是,当你使用 feign 传递 MultipartFile 对象时,接收方无法解析,所以需要重写 feign 的 Encoder ,让它支持 MultipartFile 类型以及 MultipartFile[] 数组类型\n\n\n异常输出com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class java.io.FileDescriptor and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile[0]-&gt;org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile[&quot;inputStream&quot;]-&gt;java.io.FileInputStream[&quot;fd&quot;])\n\nMaven引入jar包&lt;!-- 支持feign传递MultipartFile --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;    &lt;artifactId&gt;feign-form&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;    &lt;artifactId&gt;feign-form-spring&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;\n\nSpringMultipartEncoder 类 - 重写 FormEncoder 使得 feign 可以支持文件传输import feign.RequestTemplate;import feign.codec.EncodeException;import feign.codec.Encoder;import feign.form.ContentType;import feign.form.FormEncoder;import feign.form.MultipartFormContentProcessor;import feign.form.spring.SpringManyMultipartFilesWriter;import feign.form.spring.SpringSingleMultipartFileWriter;import org.springframework.web.multipart.MultipartFile;import java.lang.reflect.Type;import java.util.Collections;import java.util.Map;/** * 支持feign传递MultipartFile */public class SpringMultipartEncoder extends FormEncoder &#123;    /**     * Constructor with the default Feign&#x27;s encoder as a delegate.     */    public SpringMultipartEncoder() &#123;        this(new Default());    &#125;    /**     * Constructor with specified delegate encoder.     *     * @param delegate delegate encoder, if this encoder couldn&#x27;t encode object.     */    public SpringMultipartEncoder(Encoder delegate) &#123;        super(delegate);        MultipartFormContentProcessor processor = (MultipartFormContentProcessor) getContentProcessor(ContentType.MULTIPART);        processor.addWriter(new SpringSingleMultipartFileWriter());        processor.addWriter(new SpringManyMultipartFilesWriter());    &#125;    @Override    public void encode(Object object, Type bodyType, RequestTemplate template) throws EncodeException &#123;        // 单MultipartFile判断        if (bodyType.equals(MultipartFile.class)) &#123;            MultipartFile file = (MultipartFile) object;            Map data = Collections.singletonMap(file.getName(), object);            super.encode(data, MAP_STRING_WILDCARD, template);            return;        &#125; else if (bodyType.equals(MultipartFile[].class)) &#123;            // MultipartFile数组处理            MultipartFile[] file = (MultipartFile[]) object;            if (file != null) &#123;                Map data = Collections.singletonMap(file.length == 0 ? &quot;&quot; : file[0].getName(), object);                super.encode(data, MAP_STRING_WILDCARD, template);                return;            &#125;        &#125;        // 其他类型调用父类默认处理方法        super.encode(object, bodyType, template);    &#125;&#125;\n\nFeignMultipartSupportConfig 类 - 配置 Encoder 注入 messageConvertersimport feign.codec.Encoder;import org.springframework.beans.factory.ObjectFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.http.HttpMessageConverters;import org.springframework.cloud.openfeign.support.SpringEncoder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FeignMultipartSupportConfig &#123;//    @Bean//    public Encoder feignEncoder(ObjectFactory&lt;HttpMessageConverters&gt; messageConverters) &#123;//        return new SpringMultipartEncoder(new SpringEncoder(messageConverters));//    &#125;    @Autowired    private ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;    @Bean    public Encoder feignEncoder() &#123;        return new SpringMultipartEncoder(new SpringEncoder(messageConverters));    &#125;&#125;\n消费者的文件服务客户端 FileClient 类 - FeignClient/** * 文件存储客户端 */@FeignClient(name = &quot;file-service&quot;, configuration = SpringMultipartEncoder.class)public interface FileClient &#123;    /**     * 上传文件存储对象     *     * @param files     * @param firstKey     * @return     */    @PostMapping(value = &quot;/api/file/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)    List&lt;String&gt; upload(@RequestPart(value = &quot;files&quot;) MultipartFile[] files, @RequestParam(&quot;firstKey&quot;) String firstKey);&#125;\n\n上面有个 SpringMultipartEncoder 类,这个是我们重写刚才导入jar包中的 FormEncoder ,以支持任意数量文件上传,同时这里用 @RequestPart ,注意不能用 @RequestParam,如果用 @RequestParam ,被调用的服务方会出现如下错误Caused by: org.apache.commons.fileupload.FileUploadException: the request was rejected because no multipart boundary was found\n\n@RequestParam 适用于 name-valueString 类型的请求域\n@RequestPart 适用于复杂的请求域 (JSON,XML)\n\n消费者的文件服务控制层@Autowiredprivate FileClient fileClient;  // 消费者的文件服务客户端/** * 上传文件存储对象 * * @param files * @param firstKey * @return */@PostMapping(&quot;file/v1/upload&quot;)public List&lt;String&gt; fileUpload(@RequestParam(&quot;files&quot;) MultipartFile[] files, String firstKey) &#123;    List&lt;String&gt; strings = fileClient.upload(files, firstKey);    return strings;&#125;\n\n生产者的文件服务控制层/** * 上传文件存储对象 * * @param files * @param firstKey * @return */@PostMapping(&quot;/api/file/upload&quot;)public List&lt;String&gt; upload(@RequestParam(&quot;files&quot;) MultipartFile[] files, @RequestParam(&quot;firstKey&quot;) String firstKey) &#123;    return new LinkedList&lt;&gt;();&#125;\n","categories":["springcloud","feign","MultiPartFile"],"tags":["springcloud","feign","MultiPartFile"]},{"title":"springboot跨域配置","url":"/2018/12/05/springboot%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/","content":"springboot跨域配置@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowedMethods(&quot;POST&quot;, &quot;GET&quot;, &quot;PUT&quot;, &quot;OPTIONS&quot;, &quot;DELETE&quot;)                .allowCredentials(true).maxAge(3600);    &#125;&#125;\n\n\n\nmaxAge(3600)用于设置跨许信息有效期Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期间，不用发出另一条预检请求。就是在这段时间内不用再发options请求\n","categories":["springboot","跨域配置"],"tags":["springboot","跨域配置"]},{"title":"使用工具类管理SessionFactory和Session","url":"/2017/06/06/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%AE%A1%E7%90%86SessionFactory%E5%92%8CSession/","content":"使用工具类管理SessionFactory和Session\n\nimport org.hibernate.HibernateException;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123;    private static Configuration configuration;    private final static SessionFactory sessionFactory;    //初始化Configuration和SessionFactory    static &#123;        try &#123;            //配置文件名，来源resources 根目录            configuration = new Configuration().configure(&quot;hibernate.cfg.xml&quot;);            sessionFactory = configuration.buildSessionFactory();        &#125; catch (HibernateException e) &#123;            throw new ExceptionInInitializerError(e);        &#125;    &#125;    //获取Session对象    public static Session currentSesstion() &#123;        return sessionFactory.getCurrentSession();    &#125;&#125;\n","categories":["hibernate"],"tags":["hibernate","session","SessionFactory"]},{"title":"单例模式 饿汉模式 懒汉模式 示例","url":"/2018/04/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8B/","content":"单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例\n简介单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。\n\n\n动机对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。 [3]如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。\n要点显然单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n示例读取数据库配置文件 只读取一次\ndatabase.properties 配置文件username=rootpassword=simon\n\nConfigManagerHungry 工具类 单例饿汉模式类初始化自行实例化,不存在线程不安全。不具备延迟加载特性\npackage com.util;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * 单例 饿汉模式 * 类初始化自行实例化,不存在线程不安全 * 不具备延迟加载特性 */public class ConfigManagerHungry &#123;    //类加载自行进行初始化操作    private static ConfigManagerHungry configManagerHungry = new ConfigManagerHungry();    private static Properties properties;    //私有构造器 读取数据库配置文件    private ConfigManagerHungry() &#123;        System.out.println(&quot;饿汉模式 ConfigManagerHungry ------&gt;&gt;&gt;&gt; 创建&quot;);        String configFile = &quot;database.properties&quot;;        properties = new Properties();        InputStream is = ConfigManagerHungry.class.getClassLoader().getResourceAsStream(configFile);        try &#123;            properties.load(is);            is.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //全局访问点    public static ConfigManagerHungry getConfigManagerHungry() &#123;        return configManagerHungry;    &#125;    public String getValue(String key) &#123;        return properties.getProperty(key);    &#125;&#125;\n\nConfigManagerIdler 工具类 单例懒汉模式具备延迟加载特性。线程不安全\n\n\npackage com.util;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * 单例 懒汉模式 * 具备延迟加载特性 * 线程不安全 */public class ConfigManagerIdler &#123;    private static ConfigManagerIdler configManagerIdler;    private static Properties properties;    //私有构造器 读取数据库配置文件    private ConfigManagerIdler() &#123;        String configFile = &quot;database.properties&quot;;        properties = new Properties();        InputStream is = ConfigManagerIdler.class.getClassLoader().getResourceAsStream(configFile);        try &#123;            properties.load(is);            is.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //全局访问点    public static ConfigManagerIdler getConfigManagerIdler() &#123;        if (null == configManagerIdler) &#123;            System.out.println(&quot;懒汉模式 ConfigManagerIdler ------&gt;&gt;&gt;&gt; 创建&quot;);            configManagerIdler = new ConfigManagerIdler();        &#125;        return configManagerIdler;    &#125;    public String getValue(String key) &#123;        return properties.getProperty(key);    &#125;&#125;\n\nConfigManager 工具类 单例模式结合饿汉模式与懒汉模式的特性。及具有延迟加载特性并线程安全\npackage com.util;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * 单例模式 * 结合饿汉模式与懒汉模式的特性 * 及具有延迟加载特性并线程安全 */public class ConfigManager &#123;    private static ConfigManager configManager;    private static Properties properties;    //私有构造器 读取数据库配置文件    private ConfigManager() &#123;        String configFile = &quot;database.properties&quot;;        properties = new Properties();        InputStream is = ConfigManager.class.getClassLoader().getResourceAsStream(configFile);        try &#123;            properties.load(is);            is.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //使用内部静态类    public static class ConfigManagerHelper &#123;        private static final ConfigManager INSTANCE = new ConfigManager();    &#125;    //全局访问点    public static ConfigManager getConfigManager() &#123;        if (null == configManager) &#123;            System.out.println(&quot;单例模式 ConfigManager ------&gt;&gt;&gt;&gt; 创建&quot;);            configManager = ConfigManagerHelper.INSTANCE;        &#125;        return configManager;    &#125;    public String getValue(String key) &#123;        return properties.getProperty(key);    &#125;&#125;\n\nTest 测试类package com.test;import com.util.ConfigManager;import com.util.ConfigManagerHungry;import com.util.ConfigManagerIdler;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;one  -----------------&quot;);        System.out.println(getConfigManager());        System.out.println(getConfigManagerHungry());        System.out.println(getConfigManagerIdler());        System.out.println(&quot;two  -----------------&quot;);        System.out.println(getConfigManager());        System.out.println(getConfigManagerHungry());        System.out.println(getConfigManagerIdler());    &#125;    /**     * 单例模式     */    public static String getConfigManager() &#123;        StringBuffer stringBuffer = new StringBuffer();        stringBuffer.append(&quot;username : &quot; + ConfigManager.getConfigManager().getValue(&quot;username&quot;) + &quot;\\n&quot;);        stringBuffer.append(&quot;password : &quot; + ConfigManager.getConfigManager().getValue(&quot;password&quot;) + &quot;\\n&quot;);        return stringBuffer.toString();    &#125;    /**     * 饿汉模式     */    public static String getConfigManagerHungry() &#123;        StringBuffer stringBuffer = new StringBuffer();        stringBuffer.append(&quot;username : &quot; + ConfigManagerHungry.getConfigManagerHungry().getValue(&quot;username&quot;) + &quot;\\n&quot;);        stringBuffer.append(&quot;password : &quot; + ConfigManagerHungry.getConfigManagerHungry().getValue(&quot;password&quot;) + &quot;\\n&quot;);        return stringBuffer.toString();    &#125;    /**     * 懒汉模式     */    public static String getConfigManagerIdler() &#123;        StringBuffer stringBuffer = new StringBuffer();        stringBuffer.append(&quot;username : &quot; + ConfigManagerIdler.getConfigManagerIdler().getValue(&quot;username&quot;) + &quot;\\n&quot;);        stringBuffer.append(&quot;password : &quot; + ConfigManagerIdler.getConfigManagerIdler().getValue(&quot;password&quot;) + &quot;\\n&quot;);        return stringBuffer.toString();    &#125;&#125;\n\n控制台输出结果one  -----------------单例模式 ConfigManager ------&gt;&gt;&gt;&gt; 创建username : rootpassword : simon饿汉模式 ConfigManagerHungry ------&gt;&gt;&gt;&gt; 创建username : rootpassword : simon懒汉模式 ConfigManagerIdler ------&gt;&gt;&gt;&gt; 创建username : rootpassword : simontwo  -----------------username : rootpassword : simonusername : rootpassword : simonusername : rootpassword : simon\n\n控制台输出可以看到，三个工具类的通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例\n示例下载","categories":["设计模式"],"tags":["设计模式","单例模式","饿汉模式","懒汉模式"]},{"title":"多内部资源视图解析器 配合 @XmlRootElement 返回 XML、JSON、HTML 以及 @ResponseBody注解 JSON 返回 object 处理","url":"/2018/07/27/%E5%A4%9A%E5%86%85%E9%83%A8%E8%B5%84%E6%BA%90%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8-%E9%85%8D%E5%90%88-XmlRootElement-%E8%BF%94%E5%9B%9E-XML%E3%80%81JSON%E3%80%81HTML-%E4%BB%A5%E5%8F%8A-ResponseBody%E6%B3%A8%E8%A7%A3-JSON-%E8%BF%94%E5%9B%9E-object-%E5%A4%84%E7%90%86/","content":"SSM（Spring+SpringMVC+MyBatis）框架集由Spring、SpringMVC、MyBatis三个开源框架整合而成，常作为数据源较简单的web项目的框架。其中spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。SpringMVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。\n\n\npom.xml SSM框架集-jar包&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;name&gt;SSM-school&lt;/name&gt;    &lt;groupId&gt;com&lt;/groupId&gt;    &lt;artifactId&gt;SSM-school&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;spring.version&gt;4.3.12.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--spring AOP就是用aspectj来实现的，是依赖关系--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.8.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring-webmvc --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--实现多内部资源视图解析器 生成xml--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--事务--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--初始化会话工厂--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis框架--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis与spring对接的jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql 数据库--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.44&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--数据源--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--JSP 标准标签库 (JSTL)--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--json转换工具包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.47&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\nStudentController servlet层 多视图解析/** * 多视图解析 不需要加 @ResponseBody 注解 * 并实现一个方法做到下面三个方法的效果 * view?id=7 或 view.html?id=7 返回 HTML 页面 * view.json?id=7 返回 JSON 字符串参数 * view.xml?id=7 返回 XML */@RequestMapping(&quot;/view&quot;)public ModelAndView view(Integer id) &#123;    ModelAndView modelAndView = new ModelAndView();    Student student = studentBiz.getStudent(id);    modelAndView.addObject(&quot;student&quot;, student);    modelAndView.setViewName(&quot;view&quot;);    return modelAndView;&#125;/** * rest风格 * 依赖 @PathVariable注解 指定参数 * 原地址栏 /view?id=7 * rest风格 /view/7 */@RequestMapping(&quot;/view/&#123;id&#125;&quot;)public ModelAndView view(@PathVariable(&quot;id&quot;) Integer id) &#123;    ModelAndView modelAndView = new ModelAndView();    Student student = studentBiz.getStudent(id);    modelAndView.addObject(&quot;student&quot;, student);    modelAndView.setViewName(&quot;view&quot;);    return modelAndView;&#125;//局部编码格式配置 produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;//springMVC.xml JSON全局编码格式已设置//@ResponseBody 返回JSON注解@RequestMapping(value = &quot;/stringJson/&#123;id&#125;&quot;)@ResponseBodypublic String stringJson(@PathVariable(&quot;id&quot;) Integer id) &#123;    Student student = studentBiz.getStudent(id);    return JSON.toJSONString(student);&#125;//局部编码格式配置 produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;//springMVC.xml JSON全局编码格式已设置//@ResponseBody 返回JSON注解@RequestMapping(value = &quot;/objectJson/&#123;id&#125;&quot;)@ResponseBodypublic Object objectJson(@PathVariable(&quot;id&quot;) Integer id) &#123;    Student student = studentBiz.getStudent(id);    return student;&#125;\n\nspringMVC.xml springMVC配置文件&lt;!--扫描注解的Bean--&gt;&lt;context:component-scan base-package=&quot;com.controller,com.biz&quot;/&gt;&lt;!-- 多内部资源视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;    &lt;!-- 指定json 用什么工具解析  xml 用什么工具解析 --&gt;    &lt;property name=&quot;defaultViews&quot;&gt;        &lt;list&gt;            &lt;!--定义json 编码格式--&gt;            &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonJsonView&quot;&gt;                &lt;property name=&quot;charset&quot; value=&quot;UTF-8&quot;/&gt;            &lt;/bean&gt;            &lt;!--定义xml 用oxm解析--&gt;            &lt;bean class=&quot;org.springframework.web.servlet.view.xml.MarshallingView&quot;&gt;                &lt;constructor-arg&gt;                    &lt;bean class=&quot;org.springframework.oxm.jaxb.Jaxb2Marshaller&quot;&gt;                        &lt;property name=&quot;classesToBeBound&quot;&gt;                            &lt;list&gt;                                &lt;value&gt;com.pojo.Student&lt;/value&gt;                                &lt;value&gt;com.pojo.Classes&lt;/value&gt;                            &lt;/list&gt;                        &lt;/property&gt;                    &lt;/bean&gt;                &lt;/constructor-arg&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!-- 指定 jsp解析器 --&gt;    &lt;property name=&quot;viewResolvers&quot;&gt;        &lt;list&gt;            &lt;!--内部资源视图解析器--&gt;            &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;                &lt;!--前缀解析--&gt;                &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;                &lt;!--后缀解析--&gt;                &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!--使 @Controller 注解生效--&gt;&lt;!--使 @ResponseBody 返回 object 时 利用 alibaba.fastjson 工具 转换--&gt;&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters&gt;        &lt;!--解决springmvc返回的json中文问题  --&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;constructor-arg value=&quot;utf-8&quot;/&gt;        &lt;/bean&gt;        &lt;!--解决springMVC返回的json为object 时进行转换--&gt;        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot;&gt;                &lt;list&gt;                    &lt;value&gt;application/json&lt;/value&gt;                &lt;/list&gt;            &lt;/property&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;\n\n示例下载 密码: nihp","categories":["springMVC","多内部资源视图解析器","内部资源视图解析器"],"tags":["JSON","xml","多内部资源视图解析器","XmlRootElement","ResponseBody","html"]},{"title":"如何使用 Docker 构建一个代理服务器","url":"/2023/07/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Docker-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"演示如何使用 Docker 构建一个代理服务器，将请求代理到 https://api.openai.com/ 并使用 HTTPS 进行通信。\n\n\n\n在与 Dockerfile 相同的目录中创建一个名为 nginx.conf 的文件，并将以下内容复制到文件中：\n\nevents &#123;  worker_connections 1024;&#125;http &#123;  server &#123;    listen 443 ssl;    ssl_certificate /etc/nginx/cert.pem;    ssl_certificate_key /etc/nginx/cert.key;    ssl_session_cache shared:le_nginx_SSL:1m;    ssl_session_timeout 1440m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;    ssl_prefer_server_ciphers on;    ssl_ciphers TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-128-CCM-8-SHA256:TLS13-AES-128-CCM-SHA256:EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+ECDSA+AES128:EECDH+aRSA+AES128:RSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:RSA+AES256:EECDH+ECDSA+3DES:EECDH+aRSA+3DES:RSA+3DES:!MD5;    location / &#123;      proxy_pass https://api.openai.com/;      proxy_ssl_server_name on;      proxy_set_header Host api.openai.com;      proxy_set_header Connection &#x27;&#x27;;      proxy_http_version 1.1;      chunked_transfer_encoding off;      proxy_buffering off;      proxy_cache off;    &#125;  &#125;&#125;\n请确保将 cert.pem 和 cert.key 替换为您自己的 SSL 证书文件路径。\n\n在与 Dockerfile 相同的目录中，将您的 SSL 证书文件（包括 cert.pem 和 cert.key）放置在该目录下。\n\n创建一个名为 Dockerfile 的文件，并将以下内容复制到文件中：\n\n\nFROM nginx:latestCOPY nginx.conf /etc/nginx/nginx.confCOPY cert.pem /etc/nginx/cert.pemCOPY cert.key /etc/nginx/cert.keyEXPOSE 443\n\n\n打开终端，切换到包含 Dockerfile 和 nginx.conf 文件的目录。\n\n运行以下命令来构建 Docker 镜像：\n\n\ndocker build -t openai-proxy .\n\n\n构建完成后，运行以下命令来启动代理服务器容器：\n\ndocker run -d -p 8443:443 openai-proxy\n这将在后台启动一个名为 openai-proxy 的容器，并将容器内的 443 端口映射到主机的 8443 端口。\n现在，您可以通过访问 https://localhost:8443 来访问代理服务器，并通过代理服务器访问 https://api.openai.com/。请注意，这只是一个简单的示例，您可能需要根据需要进行更改和调整，以满足您的具体需求和环境配置。同时，使用自签名证书时，您的浏览器可能会显示安全警告，因为证书不是由受信任的颁发机构签发。\n","categories":["Nginx","代理服务器"],"tags":["Nginx","代理服务器"]},{"title":"如何解决JavaScript中0.1+0.2不等于0.3","url":"/2016/10/22/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3JavaScript%E4%B8%AD0-1-0-2%E4%B8%8D%E7%AD%89%E4%BA%8E0-3/","content":"如何解决JavaScript中0.1+0.2不等于0.3console.log(0.1+0.2===0.3);    //true or false?\n\n在正常的数学逻辑思维中，0.1+0.2&#x3D;0.3这个逻辑是正确的，但是在JavaScript中0.1+0.2!&#x3D;&#x3D;0.3，这是为什么呢？这个问题也会偶尔被用来当做面试题来考查面试者对JavaScript的数值的理解程度\n在JavaScript中的二进制的浮点数0.1和0.2并不是十分精确，在他们相加的结果并非正好等于0.3，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为 false\n\n\n那么应该怎样来解决0.1+0.2等于0.3呢? 最好的方法是设置一个误差范围值，通常称为”机器精度“，而对于 JavaScript 来说，这个值通常是2^-52,而在 ES6 中，已经为我们提供了这样一个属性：Number.EPSILON，而这个值正等于2^-52。这个值非常非常小，在底层计算机已经帮我们运算好，并且无限接近0，但不等于0,。这个时候我们只要判断(0.1+0.2)-0.3小于Number.EPSILON，在这个误差的范围内就可以判定0.1+0.2&#x3D;&#x3D;&#x3D;0.3为true\nfunction numbersEqual(a,b)&#123;    return Math.abs(a-b)&lt;Number.EPSILON;  &#125;  var a=0.1+0.2， b=0.3;  console.log(numbersEqual(a,b));    //true  \n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"微信提现-企业付款到零钱","url":"/2019/05/17/%E5%BE%AE%E4%BF%A1%E6%8F%90%E7%8E%B0-%E4%BC%81%E4%B8%9A%E4%BB%98%E6%AC%BE%E5%88%B0%E9%9B%B6%E9%92%B1/","content":"微信提现-企业付款到零钱p12证书下载\n企业付款到零钱API\n\napiclient_cert.p12证书:微信商户平台 – 账户设置 – API安全 – 证书中下载\n\n\n\n\n开发环境&#x2F;参数准备\nSpringBoot2.0框架 （仅限本例，其他框架自行解决，原理相同）\n\nAPP_ID （公众账号appid）\n\nMCH_ID（商户号）\n\nAPI_SECRET（API密钥）\n\n\npom.xml相关jar包&#x2F;插件引入\nxml相关jar包引入（微信接口要求以xml格式传参）\n\n&lt;dependencies&gt;  &lt;!-- xml --&gt;  &lt;dependency&gt;      &lt;groupId&gt;net.sf.kxml&lt;/groupId&gt;      &lt;artifactId&gt;kxml2&lt;/artifactId&gt;      &lt;version&gt;2.3.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;xmlpull&lt;/groupId&gt;      &lt;artifactId&gt;xmlpull&lt;/artifactId&gt;      &lt;version&gt;1.1.3.1&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\nmaven过滤证书转码\n\n&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;!-- 过滤后缀为p12/crt/pem/pfx不需要转码的证书文件 --&gt;                &lt;nonFilteredFileExtensions&gt;                    &lt;nonFilteredFileExtension&gt;p12&lt;/nonFilteredFileExtension&gt;                    &lt;nonFilteredFileExtension&gt;crt&lt;/nonFilteredFileExtension&gt;                    &lt;nonFilteredFileExtension&gt;pem&lt;/nonFilteredFileExtension&gt;                    &lt;nonFilteredFileExtension&gt;pfx&lt;/nonFilteredFileExtension&gt;                &lt;/nonFilteredFileExtensions&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n将下载好的证书放在 src/main/resources\n\n代码实现\nHttpUtils（企业付款http请求工具）\n\npackage com.zero.aliatry.utils.withdrawal;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.ssl.SSLContexts;import org.apache.http.util.EntityUtils;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import javax.net.ssl.SSLContext;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.security.KeyStore;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Map.Entry;/** * 企业付款http请求工具 */public class HttpUtils &#123;\tprivate static final String DEFAULT_CHARSET = &quot;UTF-8&quot;;\tprivate static final int CONNECT_TIME_OUT = 5000; //链接超时时间3秒\tprivate static final RequestConfig REQUEST_CONFIG = RequestConfig.custom().setConnectTimeout(CONNECT_TIME_OUT).build();\tprivate static SSLContext wx_ssl_context = null; //微信支付ssl证书\tprivate static final String MCH_ID  = &quot;1000000000&quot;;//证书密码默认是商户号\tstatic&#123;\t\tResource resource = new ClassPathResource(&quot;apiclient_cert.p12&quot;);//该证书名字最好改为别人猜不到的\t\ttry &#123;\t\t\tKeyStore keystore = KeyStore.getInstance(&quot;PKCS12&quot;);\t\t\tchar[] keyPassword = MCH_ID.toCharArray(); //证书密码\t\t\tkeystore.load(resource.getInputStream(), keyPassword);\t\t\twx_ssl_context = SSLContexts.custom().loadKeyMaterial(keystore, keyPassword).build();\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t/**\t * @description 功能描述: get 请求\t * @param url 请求地址\t * @param params 参数\t * @param headers headers参数\t * @return 请求失败返回null\t */\tpublic static String get(String url, Map&lt;String, String&gt; params, Map&lt;String, String&gt; headers) &#123;\t\tCloseableHttpClient httpClient = null;\t\tif (params != null &amp;&amp; !params.isEmpty()) &#123;\t\t\tStringBuffer param = new StringBuffer();\t\t\tboolean flag = true; // 是否开始\t\t\tfor (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;\t\t\t\tif (flag) &#123;\t\t\t\t\tparam.append(&quot;?&quot;);\t\t\t\t\tflag = false;\t\t\t\t&#125; else &#123;\t\t\t\t\tparam.append(&quot;&amp;&quot;);\t\t\t\t&#125;\t\t\t\tparam.append(entry.getKey()).append(&quot;=&quot;);\t\t\t\ttry &#123;\t\t\t\t\tparam.append(URLEncoder.encode(entry.getValue(), DEFAULT_CHARSET));\t\t\t\t&#125; catch (UnsupportedEncodingException e) &#123;\t\t\t\t\t//编码失败\t\t\t\t&#125;\t\t\t&#125;\t\t\turl += param.toString();\t\t&#125;\t\tString body = null;\t\tCloseableHttpResponse response = null;\t\ttry &#123;\t\t\thttpClient = HttpClients.custom().setDefaultRequestConfig(REQUEST_CONFIG).build();\t\t\tHttpGet httpGet = new HttpGet(url);\t\t\tresponse = httpClient.execute(httpGet);\t\t\tbody = EntityUtils.toString(response.getEntity(), DEFAULT_CHARSET);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tif (response != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\tresponse.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (httpClient != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\thttpClient.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\treturn body;\t&#125;\t/**\t * @description 功能描述: get 请求\t * @param url 请求地址\t * @return 请求失败返回null\t */\tpublic static String get(String url) &#123;\t\treturn get(url, null);\t&#125;\t/**\t * @description 功能描述: get 请求\t * @param url 请求地址\t * @param params 参数\t * @return 请求失败返回null\t */\tpublic static String get(String url, Map&lt;String, String&gt; params) &#123;\t\treturn get(url, params, null);\t&#125;\t/**\t * @description 功能描述: post 请求\t * @param url 请求地址\t * @param params 参数\t * @return 请求失败返回null\t */\tpublic static String post(String url, Map&lt;String, String&gt; params) &#123;\t\tCloseableHttpClient httpClient = null;\t\tHttpPost httpPost = new HttpPost(url);\t\tList&lt;NameValuePair&gt; nameValuePairs = new ArrayList&lt;&gt;();\t\tif (params != null &amp;&amp; !params.isEmpty()) &#123;\t\t\tfor (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;\t\t\t\tnameValuePairs.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));\t\t\t&#125;\t\t&#125;\t\tString body = null;\t\tCloseableHttpResponse response = null;\t\ttry &#123;\t\t\thttpClient = HttpClients.custom().setDefaultRequestConfig(REQUEST_CONFIG).build();\t\t\thttpPost.setEntity(new UrlEncodedFormEntity(nameValuePairs, DEFAULT_CHARSET));\t\t\tresponse = httpClient.execute(httpPost);\t\t\tbody = EntityUtils.toString(response.getEntity(), DEFAULT_CHARSET);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tif (response != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\tresponse.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (httpClient != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\thttpClient.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\treturn body;\t&#125;\t/**\t * @description 功能描述: post 请求\t * @param url 请求地址\t * @param s 参数xml\t * @return 请求失败返回null\t */\tpublic static String post(String url, String s) &#123;\t\tCloseableHttpClient httpClient = null;\t\tHttpPost httpPost = new HttpPost(url);\t\tString body = null;\t\tCloseableHttpResponse response = null;\t\ttry &#123;\t\t\thttpClient = HttpClients.custom().setDefaultRequestConfig(REQUEST_CONFIG).build();\t\t\thttpPost.setEntity(new StringEntity(s, DEFAULT_CHARSET));\t\t\tresponse = httpClient.execute(httpPost);\t\t\tbody = EntityUtils.toString(response.getEntity(), DEFAULT_CHARSET);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tif (response != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\tresponse.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (httpClient != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\thttpClient.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\treturn body;\t&#125;\t/**\t * @description 功能描述: post https请求，服务器双向证书验证\t * @param url 请求地址\t * @param params 参数\t * @return 请求失败返回null\t */\t public static String posts(String url, Map&lt;String, String&gt; params) &#123;\t\tCloseableHttpClient httpClient = null;\t\tHttpPost httpPost = new HttpPost(url);\t\tList&lt;NameValuePair&gt; nameValuePairs = new ArrayList&lt;&gt;();\t\tif (params != null &amp;&amp; !params.isEmpty()) &#123;\t\t\tfor (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;\t\t\t\tnameValuePairs.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));\t\t\t&#125;\t\t&#125;\t\tString body = null;\t\tCloseableHttpResponse response = null;\t\ttry &#123;\t\t\thttpClient = HttpClients.custom().setDefaultRequestConfig(REQUEST_CONFIG).setSSLSocketFactory(getSSLConnectionSocket()).build();\t\t\thttpPost.setEntity(new UrlEncodedFormEntity(nameValuePairs, DEFAULT_CHARSET));\t\t\tresponse = httpClient.execute(httpPost);\t\t\tbody = EntityUtils.toString(response.getEntity(), DEFAULT_CHARSET);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tif (response != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\tresponse.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (httpClient != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\thttpClient.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\treturn body;\t&#125;\t/**\t * @description 功能描述: post https请求，服务器双向证书验证\t * @param url 请求地址\t * @param s 参数xml\t * @return 请求失败返回null\t */\tpublic static String posts(String url, String s) &#123;\t\tCloseableHttpClient httpClient = null;\t\tHttpPost httpPost = new HttpPost(url);\t\tString body = null;\t\tCloseableHttpResponse response = null;\t\ttry &#123;\t\t\thttpClient = HttpClients.custom().setDefaultRequestConfig(REQUEST_CONFIG).setSSLSocketFactory(getSSLConnectionSocket()).build();\t\t\thttpPost.setEntity(new StringEntity(s, DEFAULT_CHARSET));\t\t\tresponse = httpClient.execute(httpPost);\t\t\tbody = EntityUtils.toString(response.getEntity(), DEFAULT_CHARSET);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tif (response != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\tresponse.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif (httpClient != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\thttpClient.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\treturn body;\t&#125;\t//获取ssl connection链接\tprivate static SSLConnectionSocketFactory getSSLConnectionSocket() &#123;\t\treturn new SSLConnectionSocketFactory(wx_ssl_context, new String[] &#123;&quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;&#125;, null, SSLConnectionSocketFactory.getDefaultHostnameVerifier());\t&#125;&#125;\n\n\nXmlUtil （xml、map转换工具）\n\npackage com.zero.aliatry.utils.withdrawal;import com.github.pagehelper.util.StringUtil;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserException;import org.xmlpull.v1.XmlPullParserFactory;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;/** * xml、map转换工具 */public class XmlUtil &#123;\tprivate static final String PREFIX_XML = &quot;&lt;xml&gt;&quot;;\tprivate static final String SUFFIX_XML = &quot;&lt;/xml&gt;&quot;;\tprivate static final String PREFIX_CDATA = &quot;&lt;![CDATA[&quot;;\tprivate static final String SUFFIX_CDATA = &quot;]]&gt;&quot;;\t/**\t * 转化成xml, 单层无嵌套\t *\t * @param parm\t * @param isAddCDATA\t * @return\t */\tpublic static String xmlFormat(Map&lt;String, String&gt; parm, boolean isAddCDATA) &#123;\t\tStringBuffer strbuff = new StringBuffer(PREFIX_XML);\t\tif (CollectionUtil.isNotEmpty(parm)) &#123;\t\t\tfor (Entry&lt;String, String&gt; entry : parm.entrySet()) &#123;\t\t\t\tstrbuff.append(&quot;&lt;&quot;).append(entry.getKey()).append(&quot;&gt;&quot;);\t\t\t\tif (isAddCDATA) &#123;\t\t\t\t\tstrbuff.append(PREFIX_CDATA);\t\t\t\t\tif (StringUtil.isNotEmpty(entry.getValue())) &#123;\t\t\t\t\t\tstrbuff.append(entry.getValue());\t\t\t\t\t&#125;\t\t\t\t\tstrbuff.append(SUFFIX_CDATA);\t\t\t\t&#125; else &#123;\t\t\t\t\tif (StringUtil.isNotEmpty(entry.getValue())) &#123;\t\t\t\t\t\tstrbuff.append(entry.getValue());\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tstrbuff.append(&quot;&lt;/&quot;).append(entry.getKey()).append(&quot;&gt;&quot;);\t\t\t&#125;\t\t&#125;\t\treturn strbuff.append(SUFFIX_XML).toString();\t&#125;\t/**\t * 解析xml\t *\t * @param xml\t * @return\t * @throws XmlPullParserException\t * @throws IOException\t */\tpublic static Map&lt;String, String&gt; xmlParse(String xml) throws XmlPullParserException, IOException &#123;\t\tMap&lt;String, String&gt; map = null;\t\tif (StringUtil.isNotEmpty(xml)) &#123;\t\t\tInputStream inputStream = new ByteArrayInputStream(xml.getBytes());\t\t\tXmlPullParser pullParser = XmlPullParserFactory.newInstance().newPullParser();\t\t\tpullParser.setInput(inputStream, &quot;UTF-8&quot;); // 为xml设置要解析的xml数据\t\t\tint eventType = pullParser.getEventType();\t\t\twhile (eventType != XmlPullParser.END_DOCUMENT) &#123;\t\t\t\tswitch (eventType) &#123;\t\t\t\tcase XmlPullParser.START_DOCUMENT:\t\t\t\t\tmap = new HashMap&lt;String, String&gt;();\t\t\t\t\tbreak;\t\t\t\tcase XmlPullParser.START_TAG:\t\t\t\t\tString key = pullParser.getName();\t\t\t\t\tif (key.equals(&quot;xml&quot;))\t\t\t\t\t\tbreak;\t\t\t\t\tString value = pullParser.nextText().trim();\t\t\t\t\tmap.put(key, value);\t\t\t\t\tbreak;\t\t\t\tcase XmlPullParser.END_TAG:\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\teventType = pullParser.next();\t\t\t&#125;\t\t&#125;\t\treturn map;\t&#125;&#125;\n\n\nPayUtil\n\npackage com.zero.aliatry.utils.withdrawal;import com.github.pagehelper.util.StringUtil;import com.zero.aliatry.utils.ChineseCharToEnUtil;import com.zero.aliatry.utils.DateUtil;import com.zero.aliatry.utils.Encrypt;import javax.servlet.http.HttpServletRequest;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.util.Arrays;import java.util.Date;import java.util.Map;import java.util.Set;public class PayUtil &#123;\t/**\t * 生成订单号\t *\t * @return\t */\tpublic static String getTradeNo() &#123;\t\t// 自增8位数 00000001\t\treturn &quot;TNO&quot; + DateUtil.formatDate(new Date(), DateUtil.TIME_STAMP_PATTERN) + &quot;00000001&quot;;\t&#125;\t/**\t * 退款单号\t *\t * @return\t */\tpublic static String getRefundNo() &#123;\t\t// 自增8位数 00000001\t\treturn &quot;RNO&quot; + DateUtil.formatDate(new Date(), DateUtil.TIME_STAMP_PATTERN) + &quot;00000001&quot;;\t&#125;\t/**\t * 退款单号\t *\t * @return\t */\tpublic static String getTransferNo() &#123;\t\t// 自增8位数 00000001\t\treturn &quot;TNO&quot; + DateUtil.formatDate(new Date(), DateUtil.TIME_STAMP_PATTERN) + &quot;00000001&quot;;\t&#125;\t/**\t * 返回客户端ip\t *\t * @param request\t * @return\t */\tpublic static String getRemoteAddrIp(HttpServletRequest request) &#123;\t\tString ip = request.getHeader(&quot;X-Forwarded-For&quot;);\t\tif (StringUtil.isNotEmpty(ip) &amp;&amp; !&quot;unKnown&quot;.equalsIgnoreCase(ip)) &#123;\t\t\t// 多次反向代理后会有多个ip值，第一个ip才是真实ip\t\t\tint index = ip.indexOf(&quot;,&quot;);\t\t\tif (index != -1) &#123;\t\t\t\treturn ip.substring(0, index);\t\t\t&#125; else &#123;\t\t\t\treturn ip;\t\t\t&#125;\t\t&#125;\t\tip = request.getHeader(&quot;X-Real-IP&quot;);\t\tif (StringUtil.isNotEmpty(ip) &amp;&amp; !&quot;unKnown&quot;.equalsIgnoreCase(ip)) &#123;\t\t\treturn ip;\t\t&#125;\t\treturn request.getRemoteAddr();\t&#125;\t/**\t * 获取服务器的ip地址\t *\t * @param request\t * @return\t */\tpublic static String getLocalIp(HttpServletRequest request) &#123;\t\treturn request.getLocalAddr();\t&#125;\tpublic static String getSign(Map&lt;String, String&gt; params, String paternerKey) throws UnsupportedEncodingException &#123;\t\treturn Encrypt.getMD5(createSign(params, false) + &quot;&amp;key=&quot; + paternerKey).toUpperCase();\t&#125;\t/**\t * 构造签名\t *\t * @param params\t * @param encode\t * @return\t * @throws UnsupportedEncodingException\t */\tpublic static String createSign(Map&lt;String, String&gt; params, boolean encode) throws UnsupportedEncodingException &#123;\t\tSet&lt;String&gt; keysSet = params.keySet();\t\tObject[] keys = keysSet.toArray();\t\tArrays.sort(keys);\t\tStringBuffer temp = new StringBuffer();\t\tboolean first = true;\t\tfor (Object key : keys) &#123;\t\t\tif (key == null || StringUtil.isEmpty(params.get(key))) // 参数为空不参与签名\t\t\t\tcontinue;\t\t\tif (first) &#123;\t\t\t\tfirst = false;\t\t\t&#125; else &#123;\t\t\t\ttemp.append(&quot;&amp;&quot;);\t\t\t&#125;\t\t\ttemp.append(key).append(&quot;=&quot;);\t\t\tObject value = params.get(key);\t\t\tString valueStr = &quot;&quot;;\t\t\tif (null != value) &#123;\t\t\t\tvalueStr = value.toString();\t\t\t&#125;\t\t\tif (encode) &#123;\t\t\t\ttemp.append(URLEncoder.encode(valueStr, &quot;UTF-8&quot;));\t\t\t&#125; else &#123;\t\t\t\ttemp.append(valueStr);\t\t\t&#125;\t\t&#125;\t\treturn temp.toString();\t&#125;\t/**\t * 创建支付随机字符串\t * @return\t */\tpublic static String getNonceStr()&#123;\t\treturn ChineseCharToEnUtil.randomString(ChineseCharToEnUtil.LETTER_NUMBER_CHAR, 32);\t&#125;\t/**\t * 支付时间戳\t * @return\t */\tpublic static String payTimestamp() &#123;\t\treturn Long.toString(System.currentTimeMillis() / 1000);\t&#125;&#125;\n\n\nCollectionUtil\n\npackage com.zero.aliatry.utils.withdrawal;import java.util.ArrayList;import java.util.Collection;import java.util.List;import java.util.Map;/** * 集合类工具 */public class CollectionUtil &#123;\tprivate CollectionUtil() &#123;\t\tsuper();\t&#125;\t// 判断一个集合是否为空\tpublic static &lt;T&gt; boolean isEmpty(Collection&lt;T&gt; col) &#123;\t\tif (col == null || col.isEmpty()) &#123;\t\t\treturn true;\t\t&#125;\t\treturn false;\t&#125;\t// 判断一个集合是否不为空\tpublic static &lt;T&gt; boolean isNotEmpty(Collection&lt;T&gt; col) &#123;\t\treturn !isEmpty(col);\t&#125;\t// 判断Map是否为空\tpublic static &lt;K, V&gt; boolean isEmpty(Map&lt;K, V&gt; map) &#123;\t\tif (map == null || map.isEmpty()) &#123;\t\t\treturn true;\t\t&#125;\t\treturn false;\t&#125;\t// 判断Map是否不为空为空\tpublic static &lt;K, V&gt; boolean isNotEmpty(Map&lt;K, V&gt; map) &#123;\t\treturn !isEmpty(map);\t&#125;\t// 去除list中的重复数据\tpublic static &lt;T&gt; List&lt;T&gt; removeRepeat(List&lt;T&gt; list) &#123;\t\tif (isEmpty(list)) &#123;\t\t\treturn list;\t\t&#125;\t\tList&lt;T&gt; result = new ArrayList&lt;T&gt;();\t\tfor (T e : list) &#123;\t\t\tif (!result.contains(e)) &#123;\t\t\t\tresult.add(e);\t\t\t&#125;\t\t&#125;\t\treturn result;\t&#125;\t// 将集合转换为String数组\tpublic static &lt;T&gt; String[] toArray(List&lt;T&gt; list) &#123;\t\tif (isEmpty(list)) &#123;\t\t\treturn null;\t\t&#125;\t\tString[] result = new String[list.size()];\t\tfor (int i = 0; i &lt; list.size(); i++) &#123;\t\t\tresult[i] = String.valueOf(list.get(i));\t\t&#125;\t\treturn result;\t&#125;&#125;\n\n\nTransferController（提现相关接口）\n\npackage com.zero.aliatry.controller;import com.alibaba.fastjson.JSONObject;import com.github.pagehelper.util.StringUtil;import com.zero.aliatry.entity.WithdrawalRecord;import com.zero.aliatry.service.WithdrawalRecord.WithdrawalRecordService;import com.zero.aliatry.service.appUser.AppUserService;import com.zero.aliatry.service.sysUser.SysUserService;import com.zero.aliatry.utils.CheckParamsUtil;import com.zero.aliatry.utils.DateUtil;import com.zero.aliatry.utils.IpAddrUtil;import com.zero.aliatry.utils.exception.ErrorEnum;import com.zero.aliatry.utils.exception.Result;import com.zero.aliatry.utils.exception.ResultUtil;import com.zero.aliatry.utils.withdrawal.CollectionUtil;import com.zero.aliatry.utils.withdrawal.HttpUtils;import com.zero.aliatry.utils.withdrawal.PayUtil;import com.zero.aliatry.utils.withdrawal.XmlUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.UUID;/** * 提现相关接口 */@RestController@RequestMapping(&quot;/transfer&quot;)public class TransferController &#123;    @Autowired    SysUserService sysUserService;    @Autowired    AppUserService appUserService;    @Autowired    WithdrawalRecordService withdrawalRecordService;    private static final Logger logger = LoggerFactory.getLogger(TransferController.class);    private static final String TRANSFERS_PAY = &quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers&quot;; // 企业付款API    private static final String TRANSFERS_PAY_QUERY = &quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/gettransferinfo&quot;; // 企业付款查询API    private static final String APP_ID = &quot;APP_ID&quot;  ;//公众账号appid    private static final String MCH_ID = &quot;MCH_ID&quot;;//商户号    private static final String API_SECRET = &quot;API_SECRET&quot;;//API密钥    /**     * 企业向个人支付转账     * @param request     * @param params     */    @PostMapping(value = &quot;/pay&quot;)    @ResponseBody    @Transactional    public Result transferPay(@RequestBody String params,HttpServletRequest request) &#123;        /** =============================================接口参数校验================================================*/        JSONObject jsonObject = JSONObject.parseObject(params);//解析json        //校验参数是否为空        if(CheckParamsUtil.isBlank(jsonObject,&quot;userId&quot;,&quot;amount&quot;,&quot;userType&quot;))&#123;            return ResultUtil.fail(ErrorEnum.ERROR_PARAM_ISBLANK);        &#125;        /**==============================================设置局部变量=================================================*/        String userId = jsonObject.getString(&quot;userId&quot;);//用户id        String openid = &quot;&quot;;//用户openid        Float applyMoney = jsonObject.getFloat(&quot;amount&quot;);//用户申请提现金额 0.3-5000        int userType = jsonObject.getInteger(&quot;userType&quot;);//用户类型        String amount;//企业付款金额        Float poundage = 0f;//手续费        String desc;//企业付款描述信息        String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);//提现记录表id        if(applyMoney&lt;0.3||applyMoney&gt;5000)&#123;            return ResultUtil.fail(&quot;00000001&quot;,&quot;申请提现金额不符:低于最小金额0.30元或高于5000.00元&quot;);        &#125;        /** ======================================业务判断 1.userId是否有收款资格=====================================*/        if(userType == 1)&#123;            openid = sysUserService.getOpenidBySysUserId(userId);        &#125;        if(userType == 2)&#123;            openid = appUserService.getOpenidByAppUserId(userId);        &#125;        if(openid==null||openid.equals(&quot;&quot;))&#123;            return ResultUtil.fail(&quot;00000001&quot;,&quot;该用户不可提现&quot;);        &#125;        /** ======================================业务判断 2.openid可提现金额校验=====================================*/        /** userType==1 商家身份*/        if(userType == 1)&#123;            //校验用户提现金额            //1.提现金额&lt;=可提现金额 15%的抽成        &#125;        Float account = 0f;        /** userType==2 用户身份*/        if(userType == 2)&#123;            //校验用户提现金额            //1.提现金额&lt;=可提现金额            account = appUserService.getAccount(userId);            if(applyMoney&gt;account)&#123;                return ResultUtil.fail(&quot;00000001&quot;,&quot;非法操作：申请提现金额大于可提现金额&quot;);            &#125;        &#125;        /** =================================业务判断 3.userId当天提现次数及当天提现金额限制==================================*/        //当日提现次数 首次免手续费        List&lt;WithdrawalRecord&gt; withdrawalRecords = withdrawalRecordService.selectWithdrawalRecordOfToday(userId,openid,userType);        //当日非初次提现        if(withdrawalRecords.size()&gt;0&amp;&amp;withdrawalRecords.size()&lt;=10)&#123;            poundage = 2f;//当日非初次提现，手续费为2元            desc = &quot;申请提现金额：&quot;+applyMoney+&quot;元，当天已提现&quot;+withdrawalRecords.size()+&quot;次，需扣除2元手续费&quot;;            //此处对用户当天累计提现金额可做限制//            Float withdrawalAmountRequested = 0f;//用户今日累计已申请的提现额度//            for(int i = 0;i &lt; withdrawalRecords.size();i++)&#123;//                withdrawalAmountRequested = (withdrawalAmountRequested*1000+withdrawalRecords.get(i).getActualMoney()*1000)/1000;//            &#125;        &#125;else if(withdrawalRecords.size()&gt;10)&#123;            return ResultUtil.fail(&quot;00000001&quot;,&quot;该用户当天提现次数上限：微信企业付款每天最多可向同一个用户付款10次&quot;);        &#125;else&#123;            desc = &quot;申请提现金额：&quot;+applyMoney+&quot;元，当天首次提现免手续费&quot;;        &#125;        /** =================================业务判断 4.一个商户同一日付款总额限额10万元==================================*/        Float amountWithdrawn = withdrawalRecordService.selectAllWithdrawalRecordNumOfToday();//商户同一日付款总额        if(amountWithdrawn&gt;100000)&#123;            return ResultUtil.fail(&quot;00000001&quot;,&quot;今日商户付款总额限额，请明天再试&quot;);        &#125;        /** ========================校验实际提现金额是否在微信企业付款实际允许的提现（0.3-5000）范围内=========================*/        Float actualMoney = (applyMoney*1000-poundage*1000)/1000;//实际提现金额        if(actualMoney&lt;0.3||actualMoney&gt;5000)&#123;            return ResultUtil.fail(&quot;00000001&quot;,&quot;扣除手续费后的实际提现金额不符:&quot;+actualMoney+&quot;元:低于最小金额0.30元或高于5000.00元&quot;);        &#125;        amount = Integer.parseInt((int)((actualMoney)*10)+&quot;&quot;)*10+&quot;&quot;;//微信企业付款金额 30-500000        /** ==================================================================================================================*/        /** ================================================== 封装提现所需参数 ================================================*/        /** ==================================================================================================================*/        Map&lt;String, String&gt; restmap = null;        try &#123;            Map&lt;String, String&gt; parm = new HashMap&lt;String, String&gt;();            parm.put(&quot;mch_appid&quot;, APP_ID); //公众账号appid            parm.put(&quot;mchid&quot;, MCH_ID); //商户号            parm.put(&quot;nonce_str&quot;, PayUtil.getNonceStr()); //随机字符串            parm.put(&quot;partner_trade_no&quot;, PayUtil.getTransferNo()); //商户订单号            parm.put(&quot;openid&quot;, openid); //用户openid oCVr20N2YLH9VQztnkZTaCj2aYYY            parm.put(&quot;check_name&quot;, &quot;NO_CHECK&quot;); //校验用户姓名选项 OPTION_CHECK            //parm.put(&quot;re_user_name&quot;, &quot;安迪&quot;); //check_name设置为FORCE_CHECK或OPTION_CHECK，则必填            parm.put(&quot;amount&quot;,amount); //转账金额            parm.put(&quot;desc&quot;, desc); //企业付款描述信息            parm.put(&quot;spbill_create_ip&quot;, IpAddrUtil.getIpAddr(request)); //Ip地址            parm.put(&quot;sign&quot;, PayUtil.getSign(parm, API_SECRET));            String restxml = HttpUtils.posts(TRANSFERS_PAY, XmlUtil.xmlFormat(parm, false));            restmap = XmlUtil.xmlParse(restxml);        &#125; catch (Exception e) &#123;            logger.error(e.getMessage(), e);            return ResultUtil.fail(&quot;00000001&quot;,&quot;转账发生异常&quot;);        &#125;        /** =================================================== 提现结果处理 ===================================================*/        /** ============================================ 生成提现及流水记录/改变余额 ============================================*/        if (CollectionUtil.isNotEmpty(restmap) &amp;&amp; &quot;SUCCESS&quot;.equals(restmap.get(&quot;result_code&quot;))) &#123;            logger.info(&quot;转账成功&quot;);            Map&lt;String, String&gt; transferMap = new HashMap&lt;&gt;();            transferMap.put(&quot;partnerTradeNo&quot;, restmap.get(&quot;partner_trade_no&quot;));//商户转账订单号            transferMap.put(&quot;paymentNo&quot;, restmap.get(&quot;payment_no&quot;)); //微信订单号            transferMap.put(&quot;paymentTime&quot;, restmap.get(&quot;payment_time&quot;)); //微信支付成功时间            //生成提现记录            withdrawalRecordService.insert(new WithdrawalRecord(id,userType,userId,applyMoney,poundage,actualMoney,1,restmap.get(&quot;partner_trade_no&quot;),restmap.get(&quot;payment_no&quot;),                    restmap.get(&quot;payment_time&quot;)==null?null:DateUtil.strToDate(restmap.get(&quot;payment_time&quot;),&quot;yyyy-MM-dd HH:mm:ss&quot;),openid,desc,restmap.get(&quot;spbill_create_ip&quot;),&quot;0&quot;));            //生成流水表            String waterId = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);            Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();            map.put(&quot;id&quot;,waterId);//编号            map.put(&quot;userId&quot;,userId);//用户id            map.put(&quot;title&quot;,&quot;提现&quot;);//该流水的标题            map.put(&quot;waterType&quot;,2);//商家流水类型1.场地收入 2.提现    用户流水类型1.分销收入 2.提现 3.预订场地            map.put(&quot;incomeExpense&quot;,1);//收入还是支出 0.收入 1.支出            map.put(&quot;applyMoney&quot;,applyMoney);//申请提现金额            map.put(&quot;poundage&quot;,poundage);//手续费            map.put(&quot;actualMoney&quot;,actualMoney);//实际金额            map.put(&quot;whetherToAccount&quot;,1);//是否到账0.未到账1.已到账            if(userType==1)&#123;                sysUserService.insertUserWater(map);                //改变用户可提现余额            &#125;            if(userType==2)&#123;                appUserService.insertUserWater1(map);                //改变用户可提现余额                appUserService.updateUserAccount(userId,(account*1000-applyMoney*1000)/1000);//float精度问题            &#125;            return ResultUtil.success(transferMap);        &#125;        /** =================================================3.转账失败========================================================*/        else &#123;            if (CollectionUtil.isNotEmpty(restmap)) &#123;                logger.info(&quot;转账失败：&quot; + restmap.get(&quot;err_code&quot;) + &quot;:&quot; + restmap.get(&quot;err_code_des&quot;));            &#125;            return ResultUtil.fail(&quot;00000001&quot;,&quot;转账失败&quot;+restmap.get(&quot;err_code_des&quot;));        &#125;    &#125;    /**     * 企业向个人转账查询     * @param request     * @param response     * @param tradeno 商户转账订单号     * @param callback     */    @PostMapping(value = &quot;/pay/query&quot;)    public Result orderPayQuery(HttpServletRequest request, HttpServletResponse response, String tradeno,                              String callback) &#123;        if (StringUtil.isEmpty(tradeno)) &#123;            return ResultUtil.fail(&quot;00000001&quot;,&quot;转账订单号不能为空&quot;);        &#125;        Map&lt;String, String&gt; restmap = null;        try &#123;            Map&lt;String, String&gt; parm = new HashMap&lt;String, String&gt;();            parm.put(&quot;appid&quot;, APP_ID);            parm.put(&quot;mch_id&quot;, MCH_ID);            parm.put(&quot;partner_trade_no&quot;, tradeno);            parm.put(&quot;nonce_str&quot;, PayUtil.getNonceStr());            parm.put(&quot;sign&quot;, PayUtil.getSign(parm, API_SECRET));            String restxml = HttpUtils.posts(TRANSFERS_PAY_QUERY, XmlUtil.xmlFormat(parm, true));            restmap = XmlUtil.xmlParse(restxml);        &#125; catch (Exception e) &#123;            logger.error(e.getMessage(), e);        &#125;        if (CollectionUtil.isNotEmpty(restmap) &amp;&amp; &quot;SUCCESS&quot;.equals(restmap.get(&quot;result_code&quot;))) &#123;            // 订单查询成功 处理业务逻辑            logger.info(&quot;订单查询：订单&quot; + restmap.get(&quot;partner_trade_no&quot;) + &quot;支付成功&quot;);            Map&lt;String, String&gt; transferMap = new HashMap&lt;&gt;();            transferMap.put(&quot;partnerTradeNo&quot;, restmap.get(&quot;partner_trade_no&quot;));//商户转账订单号            transferMap.put(&quot;openid&quot;, restmap.get(&quot;openid&quot;)); //收款微信号            transferMap.put(&quot;paymentAmount&quot;, restmap.get(&quot;payment_amount&quot;)); //转账金额            transferMap.put(&quot;transferTime&quot;, restmap.get(&quot;transfer_time&quot;)); //转账时间            transferMap.put(&quot;desc&quot;, restmap.get(&quot;desc&quot;)); //转账描述            return ResultUtil.success(transferMap);        &#125;else &#123;            if (CollectionUtil.isNotEmpty(restmap)) &#123;                logger.info(&quot;订单转账失败：&quot; + restmap.get(&quot;err_code&quot;) + &quot;:&quot; + restmap.get(&quot;err_code_des&quot;));            &#125;            return ResultUtil.fail(&quot;00000001&quot;,&quot;订单转账失败&quot;);        &#125;    &#125;&#125;\n","categories":["WeChat"],"tags":["WeChat"]},{"title":"微服务Docker打包插件配置","url":"/2021/12/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1Docker%E6%89%93%E5%8C%85%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/","content":"SpringBoot打包插件配置聚合工程 pom.xml 添加全局变量\n镜像前缀: image-prefix 自行修改\n\n&lt;properties&gt;    &lt;docker.image.prefix&gt;image-prefix&lt;/docker.image.prefix&gt;&lt;/properties&gt;\n\n\n\n子模块 pom.xml 添加配置\n打包名称: alibaba-cloud-finalName 自行修改\n\n&lt;build&gt;    &lt;finalName&gt;alibaba-cloud-finalName&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;!--需要加这个, 不然打包镜像找不到启动文件--&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;goals&gt;                        &lt;goal&gt;repackage&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;                &lt;addResources&gt;true&lt;/addResources&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;        &lt;plugin&gt;            &lt;groupId&gt;com.spotify&lt;/groupId&gt;            &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;repository&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/repository&gt;                &lt;buildArgs&gt;                    &lt;JAR_FILE&gt;target/$&#123;project.build.finalName&#125;.jar&lt;/JAR_FILE&gt;                &lt;/buildArgs&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n子模块 pom.xml 同级添加 Dockerfile 配置文件FROM adoptopenjdk/openjdk11:ubiVOLUME /tmpARG JAR_FILECOPY $&#123;JAR_FILE&#125; app.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]\n\ndocker镜像过大\n在 Dockerfile 中, 每一条指令都会创建一个镜像层, 会增加整体镜像的大小. 合并多个指令串起来执行, Dockerfile 中的 RUN 指令通过 &amp;&amp; 和 / 支持将命令串联在一起, 可以省不少镜像层\n\n选用更小的基础镜像, 比如运行 SpringCloud 项目，不必用 jdk , 直接选用 jre 镜像即可, 可以节省50%的内存甚至更多\n\n\n优化后的 DockerfileFROM adoptopenjdk/openjdk11:jre11u-nightlyVOLUME /tmpARG JAR_FILECOPY $&#123;JAR_FILE&#125; app.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]\n\n执行 console 控制台 maven 指令打包配置编码格式 pom.xml&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;    &lt;configuration&gt;        &lt;source&gt;11&lt;/source&gt;        &lt;target&gt;11&lt;/target&gt;        &lt;encoding&gt;utf8&lt;/encoding&gt;    &lt;/configuration&gt;&lt;/plugin&gt;\n\n&lt;properties&gt;    &lt;java.version&gt;11&lt;/java.version&gt;    &lt;!--使用utf8构建, 不要用系统编码方式构建--&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;&lt;/properties&gt;\n\n父模块执行 mvnmvn clean install\n\n子模块执行 mvnmvn install &#x27;-Dmaven.test.skip=true&#x27; dockerfile:build\n","categories":["springboot","docker"],"tags":["docker","springboot"]},{"title":"微服务注册中心Docker容器化部署Nacos","url":"/2021/11/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Docker%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2Nacos/","content":"Nacos 文档欢迎来到 Nacos 的世界！\nNacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。\nNacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。\n\n\n常用属性配置\n\n\nname\ndescription\noption\n\n\n\nMODE\ncluster模式&#x2F;standalone模式\ncluster&#x2F;standalone default cluster\n\n\nNACOS_SERVERS\nnacos cluster地址\neg. ip1,ip2,ip3\n\n\nPREFER_HOST_MODE\n是否支持hostname\nhostname&#x2F;ip default ip\n\n\nNACOS_SERVER_PORT\nnacos服务器端口\ndefault 8848\n\n\nNACOS_SERVER_IP\n多网卡下的自定义nacos服务器IP\n\n\n\nSPRING_DATASOURCE_PLATFORM\nstandalone 支持 mysql\nmysql &#x2F; empty default empty\n\n\nMYSQL_MASTER_SERVICE_HOST\nmysql 主节点host\n\n\n\nMYSQL_MASTER_SERVICE_PORT\nmysql 主节点端口\ndefault : 3306\n\n\nMYSQL_MASTER_SERVICE_DB_NAME\nmysql 主节点数据库\n\n\n\nMYSQL_MASTER_SERVICE_USER\n数据库用户名\n\n\n\nMYSQL_MASTER_SERVICE_PASSWORD\n数据库密码\n\n\n\nMYSQL_SLAVE_SERVICE_HOST\nmysql从节点host\n\n\n\nMYSQL_SLAVE_SERVICE_PORT\nmysql从节点端口\ndefault :3306\n\n\nMYSQL_DATABASE_NUM\n数据库数量\ndefault :2\n\n\nJVM_XMS\n-Xms\ndefault :2g\n\n\nJVM_XMX\n-Xmx\ndefault :2g\n\n\nJVM_XMN\n-Xmn\ndefault :1g\n\n\nJVM_MS\n-XX:MetaspaceSize\ndefault :128m\n\n\nJVM_MMS\n-XX:MaxMetaspaceSize\ndefault :320m\n\n\nNACOS_DEBUG\n开启远程调试\ny&#x2F;n default :n\n\n\nTOMCAT_ACCESSLOG_ENABLED\nserver.tomcat.accesslog.enabled\ndefault :false\n\n\ndocker拉取镜像docker pull nacos/nacos-server\n\n查看镜像docker images\n\n启动Nacosdocker run --env MODE=standalone --name nacos -d -p 8848:8848  nacos/nacos-server\n\n列出容器docker ps\n\n查看日志docker logs -f $&#123;CONTAINER ID&#125;\n\n访问Nacos记得开放阿里云的网络安全组\nhttp://localhost:8848/nacos\n\n默认登录密码nacos/nacos\n\nNacos注册中心配置mysql持久化nacos数据库脚本(nacos_config.sql)# ************************************************************# Sequel Pro SQL dump# Version 4541## http://www.sequelpro.com/# https://github.com/sequelpro/sequelpro## Host: 127.0.0.1 (MySQL 5.7.32)# Database: nacos_config# Generation Time: 2021-02-22 11:00:00 +0000# ************************************************************/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;/*!40101 SET NAMES utf8 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;# Dump of table config_info# ------------------------------------------------------------CREATE TABLE `config_info` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,  `group_id` varchar(255) COLLATE utf8_bin DEFAULT NULL,  `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;,  `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;,  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,  `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;,  `src_ip` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;,  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL,  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,  `c_desc` varchar(256) COLLATE utf8_bin DEFAULT NULL,  `c_use` varchar(64) COLLATE utf8_bin DEFAULT NULL,  `effect` varchar(64) COLLATE utf8_bin DEFAULT NULL,  `type` varchar(64) COLLATE utf8_bin DEFAULT NULL,  `c_schema` text COLLATE utf8_bin,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;# Dump of table config_info_aggr# ------------------------------------------------------------CREATE TABLE `config_info_aggr` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,  `group_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;,  `datum_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;datum_id&#x27;,  `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;内容&#x27;,  `gmt_modified` datetime NOT NULL COMMENT &#x27;修改时间&#x27;,  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL,  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;;# Dump of table config_info_beta# ------------------------------------------------------------CREATE TABLE `config_info_beta` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,  `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;,  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;,  `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;,  `beta_ips` varchar(1024) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;betaIps&#x27;,  `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;,  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,  `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;,  `src_ip` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;,  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;;# Dump of table config_info_tag# ------------------------------------------------------------CREATE TABLE `config_info_tag` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,  `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;,  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,  `tag_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;tag_id&#x27;,  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;,  `content` longtext COLLATE utf8_bin NOT NULL COMMENT &#x27;content&#x27;,  `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;md5&#x27;,  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,  `src_user` text COLLATE utf8_bin COMMENT &#x27;source user&#x27;,  `src_ip` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;source ip&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;;# Dump of table config_tags_relation# ------------------------------------------------------------CREATE TABLE `config_tags_relation` (  `id` bigint(20) NOT NULL COMMENT &#x27;id&#x27;,  `tag_name` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;tag_name&#x27;,  `tag_type` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;tag_type&#x27;,  `data_id` varchar(255) COLLATE utf8_bin NOT NULL COMMENT &#x27;data_id&#x27;,  `group_id` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;group_id&#x27;,  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,  `nid` bigint(20) NOT NULL AUTO_INCREMENT,  PRIMARY KEY (`nid`),  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),  KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;;# Dump of table group_capacity# ------------------------------------------------------------CREATE TABLE `group_capacity` (  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,  `group_id` varchar(128) COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;,  `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,  `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,  `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;,  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;;# Dump of table his_config_info# ------------------------------------------------------------CREATE TABLE `his_config_info` (  `id` bigint(64) unsigned NOT NULL,  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT,  `data_id` varchar(255) COLLATE utf8_bin NOT NULL,  `group_id` varchar(128) COLLATE utf8_bin NOT NULL,  `app_name` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;app_name&#x27;,  `content` longtext COLLATE utf8_bin NOT NULL,  `md5` varchar(32) COLLATE utf8_bin DEFAULT NULL,  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,  `src_user` text COLLATE utf8_bin,  `src_ip` varchar(20) COLLATE utf8_bin DEFAULT NULL,  `op_type` char(10) COLLATE utf8_bin DEFAULT NULL,  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,  PRIMARY KEY (`nid`),  KEY `idx_gmt_create` (`gmt_create`),  KEY `idx_gmt_modified` (`gmt_modified`),  KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;;# Dump of table permissions# ------------------------------------------------------------CREATE TABLE `permissions` (  `role` varchar(50) NOT NULL,  `resource` varchar(255) NOT NULL,  `action` varchar(8) NOT NULL,  UNIQUE KEY `uk_role_permission` (`role`,`resource`,`action`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;# Dump of table roles# ------------------------------------------------------------CREATE TABLE `roles` (  `username` varchar(50) NOT NULL,  `role` varchar(50) NOT NULL,  UNIQUE KEY `idx_user_role` (`username`,`role`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;# Dump of table tenant_capacity# ------------------------------------------------------------CREATE TABLE `tenant_capacity` (  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,  `tenant_id` varchar(128) COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;,  `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,  `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,  `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;,  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;;# Dump of table tenant_info# ------------------------------------------------------------CREATE TABLE `tenant_info` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,  `kp` varchar(128) COLLATE utf8_bin NOT NULL COMMENT &#x27;kp&#x27;,  `tenant_id` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,  `tenant_name` varchar(128) COLLATE utf8_bin DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;,  `tenant_desc` varchar(256) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;,  `create_source` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;create_source&#x27;,  `gmt_create` bigint(20) NOT NULL COMMENT &#x27;创建时间&#x27;,  `gmt_modified` bigint(20) NOT NULL COMMENT &#x27;修改时间&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),  KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;;# Dump of table users# ------------------------------------------------------------CREATE TABLE `users` (  `username` varchar(50) NOT NULL,  `password` varchar(500) NOT NULL,  `enabled` tinyint(1) NOT NULL,  PRIMARY KEY (`username`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n\n新增一个用户 nacos&#x2F;nacosINSERT INTO `users` (`username`, `password`, `enabled`)VALUES (&#x27;nacos&#x27;,&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;,1);\n\n持久化启动命令docker run -d \\-e MODE=standalone \\-e SPRING_DATASOURCE_PLATFORM=mysql \\-e MYSQL_SERVICE_HOST=172.27.111.100 \\-e MYSQL_SERVICE_PORT=3306 \\-e MYSQL_SERVICE_USER=root \\-e MYSQL_SERVICE_PASSWORD=123456 \\-e MYSQL_SERVICE_DB_NAME=nacos_config \\-p 8848:8848 \\--restart=always \\--name nacos \\nacos/nacos-server","tags":["linux","centOS","docker","nacos"]},{"title":"快速部署Kibana 并配置外网可以访问","url":"/2018/12/14/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2Kibana-%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%A4%96%E7%BD%91%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE/","content":"阿里云服务器部署kibana下载wget https://artifacts.elastic.co/downloads/kibana/kibana-6.5.3-linux-x86_64.tar.gz\n\n\n\n解压tar -zxvf kibana-6.5.3-linux-x86_64.tar.gz\n\n阿里云外网访问开放端口,修改配置文件 confing目录下的kibana.yml\nserver.host: &quot;0.0.0.0&quot;\n守护进程后台启动nohup  XXX  &amp;\n","categories":["Kibana"],"tags":["wget","Kibana"]},{"title":"源码安装RocketMQ4.X可视化控制台","url":"/2019/05/06/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85RocketMQ4-X%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8E%A7%E5%88%B6%E5%8F%B0/","content":"RocketMQ可视化控制台中文文档下载源码wget https://github.com/apache/rocketmq-externals/archive/master.zip\n\n\n\n解压unzip master.zipcd rocketmq-externals-master/rocketmq-console/\n编译打包mvn clean package -Dmaven.test.skip=true\n\ntarget目录 通过java -jar的方式运行 启动后是8080端口nohup java -jar ./target/rocketmq-console-ng-1.0.1.jar &amp;\n","categories":["RocketMQ","可视化控制台"],"tags":["RocketMQ","可视化控制台"]},{"title":"源码编译安装Redis4.X","url":"/2018/12/04/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Redis4-X/","content":"下载wget http://download.redis.io/releases/redis-4.0.9.tar.gz\n解压tar xzf redis-4.0.9.tar.gz\n\n\n\n进入文件夹cd redis-4.0.9\n编译依赖 GCCgcc -vyum install gcc-c++\n编译make\n启动启动服务端：src/redis-server启动客户端：src/redis-cli\n默认是本地访问的，需要开放外网访问打开redis.conf文件在NETWORK部分修改注释掉bind 127.0.0.1可以使所有的ip访问redis修改 protected-mode，值改为no\n\nWARNING 解决方案WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.在 /etc/rc.local 目录下新增以下代码\necho 511 &gt; /proc/sys/net/core/somaxconn\n\nWARNING: overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory &#x3D; 1’ to&#x2F;etc&#x2F;sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory&#x3D;1’ for this to take effect.在 /etc/sysctl.conf 目录下新增以下代码\nvm.overcommit_memory = 1\n\nWARNING: you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix thisissue run the command ‘echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled’ as root, and add it to your &#x2F;etc&#x2F;rc.local in order to retain thesetting after a reboot. Redis must be restarted after THP is disabled.在 /etc/rc.local 目录下新增以下代码\necho never &gt; /sys/kernel/mm/transparent_hugepage/enabled\n\n内核立即生效sudo sysctl -p\n设置密码$redis-cliconfig set requirepass &#123;password&#125;","categories":["linux","Redis"],"tags":["Redis","wget"]},{"title":"热部署在Eclipse和IDEA里面的使用","url":"/2019/01/14/%E7%83%AD%E9%83%A8%E7%BD%B2%E5%9C%A8Eclipse%E5%92%8CIDEA%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"热部署在Eclipse和IDEA里面的使用简介：讲解热部署的使用注意事项，在eclipse里面默认开启，在IDE里面默认关闭\n增加依赖&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;  &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n\n\n\neclipse热部署默认自动开启idea里面要设置相关偏好里开启自动编译File &gt;&gt;&gt; Settings &gt;&gt;&gt; Build,Execution,Deployment &gt;&gt;&gt; Compiler\n勾选 Build project automatically\nShift+Ctrl+Alt+&#x2F;，选择Registry勾选 compiler.automake.allow.when.app.running\n参考链接","categories":["热部署"],"tags":["idea","热部署","eclipse"]},{"title":"邮件传输协议","url":"/2021/10/26/%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/","content":"SMTP协议全称为 Simple Mail Transfer Protocol，简单邮件传输协议。它定义了邮件客户端软件和SMTP邮件服务器之间，以及两台SMTP邮件服务器之间的通信规则\n\n\nPOP3协议全称为 Post Office Protocol，邮局协议。它定义了邮件客户端软件和POP3邮件服务器的通信规则\nIMAP协议全称为 Internet Message Access Protocol,Internet消息访问协议，它是对POP3协议一种扩展，也是定义了邮件客户端软件和IMAP邮件服务器的通信规则\n","tags":["mail"]},{"title":"阿里云对象存储服务 springcloud服务接口","url":"/2018/12/27/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1-springcloud%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3/","content":"阿里云对象存储服务 springcloud服务接口本文章提供的是阿里云对象存储的核心示例代码 , 具体springcloud接口服务于最下面查看 示例下载\n\n\n/** * 示例说明 * * HelloOSS是OSS Java SDK的示例程序，您可以修改endpoint、accessKeyId、accessKeySecret、bucketName后直接运行。 * 运行方法请参考README。 * * 本示例中的并不包括OSS Java SDK的所有功能，详细功能及使用方法，请参看“SDK手册 &gt; Java-SDK”， * 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/preface.html?spm=5176.docoss/sdk/java-sdk/。 * * 调用OSS Java SDK的方法时，抛出异常表示有错误发生；没有抛出异常表示成功执行。 * 当错误发生时，OSS Java SDK的方法会抛出异常，异常中包括错误码、错误信息，详细请参看“SDK手册 &gt; Java-SDK &gt; 异常处理”， * 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/exception.html?spm=5176.docoss/api-reference/error-response。 * * OSS控制台可以直观的看到您调用OSS Java SDK的结果，OSS控制台地址是：https://oss.console.aliyun.com/index#/。 * OSS控制台使用方法请参看文档中心的“控制台用户指南”， 指南的来链接地址是：https://help.aliyun.com/document_detail/oss/getting-started/get-started.html?spm=5176.docoss/user_guide。 * * OSS的文档中心地址是：https://help.aliyun.com/document_detail/oss/user_guide/overview.html。 * OSS Java SDK的文档地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/install.html?spm=5176.docoss/sdk/java-sdk。 * */package com.aliyun.oss.demo;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.File;import java.io.InputStream;import java.io.InputStreamReader;import java.util.List;import com.aliyun.oss.ClientException;import com.aliyun.oss.OSSClient;import com.aliyun.oss.OSSException;import com.aliyun.oss.model.BucketInfo;import com.aliyun.oss.model.OSSObject;import com.aliyun.oss.model.OSSObjectSummary;import com.aliyun.oss.model.ObjectListing;import org.apache.log4j.Logger;import org.apache.log4j.PropertyConfigurator;public class HelloOSS &#123;    static Logger logger = Logger.getLogger(HelloOSS.class);    // endpoint是访问OSS的域名。如果您已经在OSS的控制台上 创建了Bucket，请在控制台上查看域名。    // 如果您还没有创建Bucket，endpoint选择请参看文档中心的“开发人员指南 &gt; 基本概念 &gt; 访问域名”，    // 链接地址是：https://help.aliyun.com/document_detail/oss/user_guide/oss_concept/endpoint.html?spm=5176.docoss/user_guide/endpoint_region    // endpoint的格式形如“http://oss-cn-hangzhou.aliyuncs.com/”，注意http://后不带bucket名称，    // 比如“http://bucket-name.oss-cn-hangzhou.aliyuncs.com”，是错误的endpoint，请去掉其中的“bucket-name”。    private static String endpoint = &quot;http://oss-cn-hangzhou.aliyuncs.com&quot;;    // accessKeyId和accessKeySecret是OSS的访问密钥，您可以在控制台上创建和查看，    // 创建和查看访问密钥的链接地址是：https://ak-console.aliyun.com/#/。    // 注意：accessKeyId和accessKeySecret前后都没有空格，从控制台复制时请检查并去除多余的空格。    private static String accessKeyId = &quot;&lt;yourAccessKeyId&gt;&quot;;    private static String accessKeySecret = &quot;&lt;yourAccessKeySecret&gt;&quot;;    // Bucket用来管理所存储Object的存储空间，详细描述请参看“开发人员指南 &gt; 基本概念 &gt; OSS基本概念介绍”。    // Bucket命名规范如下：只能包括小写字母，数字和短横线（-），必须以小写字母或者数字开头，长度必须在3-63字节之间。    private static String bucketName = &quot;&lt;yourBucketName&gt;&quot;;    // Object是OSS存储数据的基本单元，称为OSS的对象，也被称为OSS的文件。详细描述请参看“开发人员指南 &gt; 基本概念 &gt; OSS基本概念介绍”。    // Object命名规范如下：使用UTF-8编码，长度必须在1-1023字节之间，不能以“/”或者“\\”字符开头。    private static String firstKey = &quot;my-first-key&quot;;    public static void main(String[] args) &#123;        // 日志配置，OSS Java SDK使用log4j记录错误信息。示例程序会在工程目录下生成“oss-demo.log”日志文件，默认日志级别是INFO。        // 日志的配置文件是“conf/log4j.properties”，如果您不需要日志，可以没有日志配置文件和下面的日志配置。        PropertyConfigurator.configure(&quot;conf/log4j.properties&quot;);        logger.info(&quot;Started&quot;);        // 生成OSSClient，您可以指定一些参数，详见“SDK手册 &gt; Java-SDK &gt; 初始化”，        // 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/init.html?spm=5176.docoss/sdk/java-sdk/get-start        OSSClient ossClient = new OSSClient(endpoint, accessKeyId, accessKeySecret);        try &#123;            // 判断Bucket是否存在。详细请参看“SDK手册 &gt; Java-SDK &gt; 管理Bucket”。            // 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/manage_bucket.html?spm=5176.docoss/sdk/java-sdk/init            if (ossClient.doesBucketExist(bucketName)) &#123;                System.out.println(&quot;您已经创建Bucket：&quot; + bucketName + &quot;。&quot;);            &#125; else &#123;                System.out.println(&quot;您的Bucket不存在，创建Bucket：&quot; + bucketName + &quot;。&quot;);                // 创建Bucket。详细请参看“SDK手册 &gt; Java-SDK &gt; 管理Bucket”。                // 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/manage_bucket.html?spm=5176.docoss/sdk/java-sdk/init                ossClient.createBucket(bucketName);            &#125;            // 查看Bucket信息。详细请参看“SDK手册 &gt; Java-SDK &gt; 管理Bucket”。            // 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/manage_bucket.html?spm=5176.docoss/sdk/java-sdk/init            BucketInfo info = ossClient.getBucketInfo(bucketName);            System.out.println(&quot;Bucket &quot; + bucketName + &quot;的信息如下：&quot;);            System.out.println(&quot;\\t数据中心：&quot; + info.getBucket().getLocation());            System.out.println(&quot;\\t创建时间：&quot; + info.getBucket().getCreationDate());            System.out.println(&quot;\\t用户标志：&quot; + info.getBucket().getOwner());            // 把字符串存入OSS，Object的名称为firstKey。详细请参看“SDK手册 &gt; Java-SDK &gt; 上传文件”。            // 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/upload_object.html?spm=5176.docoss/user_guide/upload_object            InputStream is = new ByteArrayInputStream(&quot;Hello OSS&quot;.getBytes());            ossClient.putObject(bucketName, firstKey, is);            System.out.println(&quot;Object：&quot; + firstKey + &quot;存入OSS成功。&quot;);            // 下载文件。详细请参看“SDK手册 &gt; Java-SDK &gt; 下载文件”。            // 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/download_object.html?spm=5176.docoss/sdk/java-sdk/manage_object            OSSObject ossObject = ossClient.getObject(bucketName, firstKey);            InputStream inputStream = ossObject.getObjectContent();            StringBuilder objectContent = new StringBuilder();            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));            while (true) &#123;                String line = reader.readLine();                if (line == null)                    break;                objectContent.append(line);            &#125;            inputStream.close();            System.out.println(&quot;Object：&quot; + firstKey + &quot;的内容是：&quot; + objectContent);            // 文件存储入OSS，Object的名称为fileKey。详细请参看“SDK手册 &gt; Java-SDK &gt; 上传文件”。            // 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/upload_object.html?spm=5176.docoss/user_guide/upload_object            String fileKey = &quot;README.md&quot;;            ossClient.putObject(bucketName, fileKey, new File(&quot;README.md&quot;));            System.out.println(&quot;Object：&quot; + fileKey + &quot;存入OSS成功。&quot;);            // 查看Bucket中的Object。详细请参看“SDK手册 &gt; Java-SDK &gt; 管理文件”。            // 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/manage_object.html?spm=5176.docoss/sdk/java-sdk/manage_bucket            ObjectListing objectListing = ossClient.listObjects(bucketName);            List&lt;OSSObjectSummary&gt; objectSummary = objectListing.getObjectSummaries();            System.out.println(&quot;您有以下Object：&quot;);            for (OSSObjectSummary object : objectSummary) &#123;                System.out.println(&quot;\\t&quot; + object.getKey());            &#125;            // 删除Object。详细请参看“SDK手册 &gt; Java-SDK &gt; 管理文件”。            // 链接地址是：https://help.aliyun.com/document_detail/oss/sdk/java-sdk/manage_object.html?spm=5176.docoss/sdk/java-sdk/manage_bucket            ossClient.deleteObject(bucketName, firstKey);            System.out.println(&quot;删除Object：&quot; + firstKey + &quot;成功。&quot;);            ossClient.deleteObject(bucketName, fileKey);            System.out.println(&quot;删除Object：&quot; + fileKey + &quot;成功。&quot;);        &#125; catch (OSSException oe) &#123;            oe.printStackTrace();        &#125; catch (ClientException ce) &#123;            ce.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            ossClient.shutdown();        &#125;        logger.info(&quot;Completed&quot;);    &#125;&#125;\n\n示例下载","categories":["阿里云","oss"],"tags":["springcloud","阿里云","oss","对象存储"]},{"title":"阿里云服务器 快速安装ElasticSearch","url":"/2018/12/14/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85ElasticSearch/","content":"使用wget 下载elasticsearch安装包wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.13.tar.gz\n解压tar -zxvf elasticsearch-5.6.13.tar.gz\n\n\n\n外网访问配置config目录下面elasticsearch.yml修改为 network.host: 0.0.0.0\n常见配置问题资料此版本配合 spring-boot 对应版本 2.0.7.RELEASE 使用&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.7.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;\n\nspring-boot 使用依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;\n\nIK中文分词GitHub下载网站版本查看使用wget 下载IK中文分词器wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.6.13/elasticsearch-analysis-ik-5.6.13.zip\n\n插件下载到ES根目录下的plugins文件夹中 : ./elasticsearch-5.6.13/plugins/\n解压unzip elasticsearch-analysis-ik-5.6.13.zip\n删除压缩包rm elasticsearch-analysis-ik-5.6.13.zip\n\n当我们在使用elasticsearch的时候，如果是以root权限来执行elasticsearch./elasticsearch\n\n\n\n则会有以下报错[2018-12-04T10:24:21,751][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [] uncaught exception in thread [main]org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root        at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:125) ~[elasticsearch-6.2.2.jar:6.2.2]        at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:112) ~[elasticsearch-6.2.2.jar:6.2.2]        at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.2.2.jar:6.2.2]        at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.2.2.jar:6.2.2]        at org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-cli-6.2.2.jar:6.2.2]        at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:92) ~[elasticsearch-6.2.2.jar:6.2.2]        at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:85) ~[elasticsearch-6.2.2.jar:6.2.2]Caused by: java.lang.RuntimeException: can not run elasticsearch as root        at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:105) ~[elasticsearch-6.2.2.jar:6.2.2]        at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:172) ~[elasticsearch-6.2.2.jar:6.2.2]        at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:323) ~[elasticsearch-6.2.2.jar:6.2.2]        at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:121) ~[elasticsearch-6.2.2.jar:6.2.2]\n\n这是出于系统安全考虑设置的条件。由于ElasticSearch可以接收用户输入的脚本并且执行，为了系统安全考虑，建议创建一个单独的用户用来运行ElasticSearch\n创建elsearch用户组及elsearch用户groupadd elsearchuseradd elsearch -g elsearch -p elasticsearch\n\n更改elasticsearch文件夹及内部文件的所属用户及组为elsearch:elsearchchown -R elsearch:elsearch $&#123;elasticsearch&#125;\n\n${elasticsearch}为你elasticsearch的目录路径\n切换到elsearch用户再启动su elsearch #切换账户cd elasticsearch/bin #进入你的elasticsearch目录下的bin目录./elasticsearch\n\n启动后会打印正常启动日志信息如下[2018-12-04T10:48:10,218][INFO ][o.e.n.Node               ] [] initializing ...[2018-12-04T10:48:10,387][INFO ][o.e.e.NodeEnvironment    ] [5tOgySS] using [1] data paths, mounts [[/ (/dev/vda1)]], net usable_space [34.2gb], net total_space [39.2gb], types [ext4][2018-12-04T10:48:10,387][INFO ][o.e.e.NodeEnvironment    ] [5tOgySS] heap size [990.7mb], compressed ordinary object pointers [true][2018-12-04T10:48:10,388][INFO ][o.e.n.Node               ] node name [5tOgySS] derived from node ID [5tOgySSsTVyh-aqzPrZrZQ]; set [node.name] to override[2018-12-04T10:48:10,389][INFO ][o.e.n.Node               ] version[6.2.2], pid[2211], build[10b1edd/2018-02-16T19:01:30.685723Z], OS[Linux/4.4.0-117-generic/amd64], JVM[Oracle Corporation/OpenJDK 64-Bit Server VM/1.8.0_191/25.191-b12][2018-12-04T10:48:10,389][INFO ][o.e.n.Node               ] JVM arguments [-Xms1g, -Xmx1g, -XX:+UseConcMarkSweepGC, -XX:CMSInitiatingOccupancyFraction=75, -XX:+UseCMSInitiatingOccupancyOnly, -XX:+AlwaysPreTouch, -Xss1m, -Djava.awt.headless=true, -Dfile.encoding=UTF-8, -Djna.nosys=true, -XX:-OmitStackTraceInFastThrow, -Dio.netty.noUnsafe=true, -Dio.netty.noKeySetOptimization=true, -Dio.netty.recycler.maxCapacityPerThread=0, -Dlog4j.shutdownHookEnabled=false, -Dlog4j2.disable.jmx=true, -Djava.io.tmpdir=/tmp/elasticsearch.UJf6TjBC, -XX:+HeapDumpOnOutOfMemoryError, -XX:+PrintGCDetails, -XX:+PrintGCDateStamps, -XX:+PrintTenuringDistribution, -XX:+PrintGCApplicationStoppedTime, -Xloggc:logs/gc.log, -XX:+UseGCLogFileRotation, -XX:NumberOfGCLogFiles=32, -XX:GCLogFileSize=64m, -Des.path.home=/usr/local/lib/elasticsearch-6.2.2, -Des.path.conf=/usr/local/lib/elasticsearch-6.2.2/config][2018-12-04T10:48:11,432][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [aggs-matrix-stats][2018-12-04T10:48:11,432][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [analysis-common][2018-12-04T10:48:11,433][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [ingest-common][2018-12-04T10:48:11,433][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [lang-expression][2018-12-04T10:48:11,433][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [lang-mustache][2018-12-04T10:48:11,433][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [lang-painless][2018-12-04T10:48:11,433][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [mapper-extras][2018-12-04T10:48:11,433][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [parent-join][2018-12-04T10:48:11,434][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [percolator][2018-12-04T10:48:11,434][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [rank-eval][2018-12-04T10:48:11,434][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [reindex][2018-12-04T10:48:11,434][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [repository-url][2018-12-04T10:48:11,434][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [transport-netty4][2018-12-04T10:48:11,434][INFO ][o.e.p.PluginsService     ] [5tOgySS] loaded module [tribe][2018-12-04T10:48:11,435][INFO ][o.e.p.PluginsService     ] [5tOgySS] no plugins loaded[2018-12-04T10:48:14,742][INFO ][o.e.d.DiscoveryModule    ] [5tOgySS] using discovery type [zen][2018-12-04T10:48:15,172][INFO ][o.e.n.Node               ] initialized[2018-12-04T10:48:15,172][INFO ][o.e.n.Node               ] [5tOgySS] starting ...[2018-12-04T10:48:15,356][INFO ][o.e.t.TransportService   ] [5tOgySS] publish_address &#123;127.0.0.1:9300&#125;, bound_addresses &#123;127.0.0.1:9300&#125;[2018-12-04T10:48:15,365][WARN ][o.e.b.BootstrapChecks    ] [5tOgySS] max file descriptors [65535] for elasticsearch process is too low, increase to at least [65536][2018-12-04T10:48:15,365][WARN ][o.e.b.BootstrapChecks    ] [5tOgySS] max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144][2018-12-04T10:48:18,413][INFO ][o.e.c.s.MasterService    ] [5tOgySS] zen-disco-elected-as-master ([0] nodes joined), reason: new_master &#123;5tOgySS&#125;&#123;5tOgySSsTVyh-aqzPrZrZQ&#125;&#123;2do4g-5VQhqH_uTYtm9Paw&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;[2018-12-04T10:48:18,417][INFO ][o.e.c.s.ClusterApplierService] [5tOgySS] new_master &#123;5tOgySS&#125;&#123;5tOgySSsTVyh-aqzPrZrZQ&#125;&#123;2do4g-5VQhqH_uTYtm9Paw&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;, reason: apply cluster state (from master [master &#123;5tOgySS&#125;&#123;5tOgySSsTVyh-aqzPrZrZQ&#125;&#123;2do4g-5VQhqH_uTYtm9Paw&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125; committed version [1] source [zen-disco-elected-as-master ([0] nodes joined)]])[2018-12-04T10:48:18,526][INFO ][o.e.h.n.Netty4HttpServerTransport] [5tOgySS] publish_address &#123;127.0.0.1:9200&#125;, bound_addresses &#123;127.0.0.1:9200&#125;[2018-12-04T10:48:18,526][INFO ][o.e.n.Node               ] [5tOgySS] started[2018-12-04T10:48:18,534][INFO ][o.e.g.GatewayService     ] [5tOgySS] recovered [0] indices into cluster_state\n\nElasticSearch后台启动命令./elasticsearch -d\n\n常见异常max file descriptors [65535] for elasticsearchprocess is too low, increase to at least [65536]修改 /etc/security/limits.conf 添加如下内容(建议新增到最下面)\n* - nofile 65536* - memlock unlimited\n\nmax virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]修改 /etc/sysctl.conf 添加如下内容(建议新增到最下面)\nvm.max_map_count = 262144\n\n修改完内核参数立即生效\nsudo sysctl -p\n","categories":["linux","elasticsearch"],"tags":["linux","wget","elasticsearch"]},{"title":"阿里云服务器部署Logstash","url":"/2018/12/06/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Logstash/","content":"阿里云服务器部署Logstash下载安装包wget https://artifacts.elastic.co/downloads/logstash/logstash-6.5.3.tar.gz\n\n解压tar -zxvf logstash-6.5.3.tar.gz\n\n快速启动(需要java8 jre,目前不支持java9)\n\n./bin/logstash -e &#x27;input &#123;stdin &#123;&#125;&#125; output &#123;stdout &#123;&#125;&#125;&#x27;\n\n目录文件说明配置讲解logstash.yml  修改 pipeline.workers，根据CPU核数增加1到2即可jvm.options   修改 xms和xmx为相同，一般是系统内存三份之二\n","categories":["linux","Logstash"],"tags":["linux","wget","阿里云","Logstash"]},{"title":"零基础学习Mahout","url":"/2019/05/13/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0Mahout/","content":"Mahout\nMahout 是 Apache Software Foundation（ASF） 旗下的一个开源项目，提供一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便快捷地创建智能应用程序。Mahout包含许多实现，包括聚类、分类、推荐过滤、频繁子项挖掘。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。\n\n\n安装MavenMaven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。Maven这个单词来自于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项目中用来简化构建过程。当时有一些项目（有各自Ant build文件），仅有细微的差别，而JAR文件都由CVS来维护。于是希望有一种标准化的方式构建项目，一个清晰的方式定义项目的组成，一个容易的方式发布项目的信息，以及一种简单的方式在多个项目中共享JARs。\n使用Maven构建Mahout项目运行 IntelliJ IDEA，通过菜单 File &gt; New &gt; Project 新建项目，选择 Maven 勾上 Create from archetype 选择 maven-archetype-quickstart 再选择 Next  输入 GroupId 和 ArtifactId，可以根据自己喜好随便命名\n\n\n剩下的全部按键盘 Enter\n工程创建完毕后，点击右下角的 Enable Auto-Import 开启自动导入\n\n下载完毕后，打开 pom.xml 替换 &lt;properties&gt; 和 &lt;dependencies&gt; 内容\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.aliatry.mahout&lt;/groupId&gt;    &lt;artifactId&gt;practice&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;name&gt;practice&lt;/name&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;mahout.version&gt;0.9&lt;/mahout.version&gt;        &lt;slf4j-log4j12.version&gt;1.7.25&lt;/slf4j-log4j12.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.mahout&lt;/groupId&gt;            &lt;artifactId&gt;mahout-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;mahout.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.mahout&lt;/groupId&gt;            &lt;artifactId&gt;mahout-integration&lt;/artifactId&gt;            &lt;version&gt;$&#123;mahout.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.mahout&lt;/groupId&gt;            &lt;artifactId&gt;mahout-math&lt;/artifactId&gt;            &lt;version&gt;$&#123;mahout.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.mahout&lt;/groupId&gt;            &lt;artifactId&gt;mahout-examples&lt;/artifactId&gt;            &lt;version&gt;$&#123;mahout.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j-log4j12.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j-log4j12.version&#125;&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n修改 App.javapackage com.aliatry.mahout;import org.apache.mahout.cf.taste.common.TasteException;import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;import org.apache.mahout.cf.taste.impl.model.file.FileDataModel;import org.apache.mahout.cf.taste.impl.neighborhood.NearestNUserNeighborhood;import org.apache.mahout.cf.taste.impl.recommender.GenericItemBasedRecommender;import org.apache.mahout.cf.taste.impl.recommender.GenericUserBasedRecommender;import org.apache.mahout.cf.taste.impl.similarity.EuclideanDistanceSimilarity;import org.apache.mahout.cf.taste.impl.similarity.PearsonCorrelationSimilarity;import org.apache.mahout.cf.taste.model.DataModel;import org.apache.mahout.cf.taste.neighborhood.UserNeighborhood;import org.apache.mahout.cf.taste.recommender.RecommendedItem;import org.apache.mahout.cf.taste.recommender.Recommender;import org.apache.mahout.cf.taste.similarity.ItemSimilarity;import org.apache.mahout.cf.taste.similarity.UserSimilarity;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.List;/** * Hello world! */public class App &#123;    public static void main(String[] args) throws Exception &#123;        // 初始化//        initial();        baseUser(); // 基于用户的协同过滤算法        baseItem(); // 基于物品的协同过滤算法        // TODO 基于用户的协同过滤算法        // 从文件加载数据        DataModel model = new FileDataModel(new File(&quot;D:\\\\data.csv&quot;));        // 指定用户相似度计算方法，这里采用皮尔森相关度        UserSimilarity similarity = new PearsonCorrelationSimilarity(model);        // 指定用户邻居数量，这里为2        UserNeighborhood neighborhood = new NearestNUserNeighborhood(2, similarity, model);        // 构建基于用户的推荐系统        Recommender recommender = new GenericUserBasedRecommender(model, neighborhood, similarity);        // 得到指定用户的推荐结果，这里是得到用户1的两个推荐        List&lt;RecommendedItem&gt; recommendations = recommender.recommend(1, 2);        // 打印推荐结果        for (RecommendedItem recommendation : recommendations) &#123;            System.out.println(recommendation);        &#125;    &#125;    public static void initial() &#123;        FileOutputStream out = null;        try &#123;            int[][] arg = &#123;                    &#123;3, 1, 4, 4, 1, 0, 0&#125;,                    &#123;0, 5, 1, 0, 0, 4, 0&#125;,                    &#123;1, 0, 5, 4, 3, 5, 2&#125;,                    &#123;3, 1, 4, 3, 5, 0, 0&#125;,                    &#123;5, 2, 0, 1, 0, 5, 5&#125;            &#125;;            out = new FileOutputStream(new File(&quot;D:\\\\data.csv&quot;));            for (int i = 0; i &lt; 5; i++) &#123;                for (int j = 0; j &lt; 7; j++) &#123;                    if (arg[i][j] &gt; 0) &#123;                        String a = i + &quot;,&quot; + j + &quot;,&quot; + arg[i][j] + &quot;\\n&quot;;                        out.write(a.getBytes());                    &#125;                &#125;            &#125;            out.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                out.close();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /**     * 基于用户的协同过滤算法     *     * @throws IOException     * @throws TasteException     */    public static void baseUser() throws IOException, TasteException &#123;        final int NEIGHBORHOOD_NUM = 2;   //用户邻居数量        final int RECOMMENDER_NUM = 3;    //推荐结果个数        /*        准备数据 这里是电影评分数据        数据集，其中第一列表示用户id；第二列表示商品id；第三列表示评分，评分是5分制        */        /*        将数据加载到内存中        基于文件的model，通过文件形式来读入,且此类型所需要读入的数据的格式要求很低，只需要满足每一行是用户id，物品id，用户偏好，且之间用tab或者是逗号隔开即可        */        DataModel dataModel = new FileDataModel(new File(&quot;D:\\\\data.csv&quot;));        /*        计算相似度，相似度算法有很多种，欧几里得、皮尔逊等等。        基于用户的协同过滤算法，基于物品的协同过滤算法，这里使用了EuclideanDistanceSimilarity        计算欧式距离，欧式距离来定义相似性，用s=1/(1+d)来表示，范围在[0,1]之间，值越大，表明d越小，距离越近，则表示相似性越大        */        UserSimilarity similarity = new EuclideanDistanceSimilarity(dataModel);        /*        计算最近邻域，邻居有两种算法，基于固定数量的邻居和基于相似度的邻居，这里使用基于固定数量的邻居。        NEIGHBORHOOD_NUM指定用户邻居数量        */        NearestNUserNeighborhood neighbor = new NearestNUserNeighborhood(NEIGHBORHOOD_NUM, similarity, dataModel);        /*        构建推荐器，协同过滤推荐有两种，分别是基于用户的和基于物品的，这里使用基于用户的协同过滤推荐        构建基于用户的推荐系统        */        Recommender r = new GenericUserBasedRecommender(dataModel, neighbor, similarity);        //得到所有用户的id集合        LongPrimitiveIterator iter = dataModel.getUserIDs();        while (iter.hasNext()) &#123;            long uid = iter.nextLong();            //获取推荐结果，获取指定用户指定数量的推荐结果            List&lt;RecommendedItem&gt; list = r.recommend(uid, RECOMMENDER_NUM);            System.out.printf(&quot;user : %s&quot;, uid);            //遍历推荐结果            for (RecommendedItem item : list) &#123;                //获取推荐结果和推荐度                System.out.print(item.getItemID() + &quot;[&quot; + item.getValue() + &quot;] &quot;);            &#125;            System.out.println();        &#125;    &#125;    /**     * 基于物品的协同过滤算法     *     * @throws IOException     * @throws TasteException     */    public static void baseItem() throws IOException, TasteException &#123;        DataModel dataModel = new FileDataModel(new File(&quot;D:\\\\data.csv&quot;));        /*        计算相似度，相似度算法有很多种，欧几里得、皮尔逊等等。        这里使用的是皮尔逊PearsonCorrelationSimilarity        */        ItemSimilarity itemSimilarity = new PearsonCorrelationSimilarity(dataModel);        //构建推荐器，协同过滤推荐有两种，分别是基于用户的和基于物品的，这里使用基于物品的协同过滤推荐        GenericItemBasedRecommender recommender = new GenericItemBasedRecommender(dataModel, itemSimilarity);        //给指定用户推荐若干个与指定商品相似的商品        List&lt;RecommendedItem&gt; recommendedItemList = recommender.recommendedBecause(1, 5, 2);        //打印推荐的结果        System.out.println(&quot;根据用户1当前浏览的商品5，推荐2个相似的商品&quot;);        for (RecommendedItem recommendedItem : recommendedItemList) &#123;            System.out.println(recommendedItem);        &#125;    &#125;&#125;\n\n控制台输出&quot;C:\\Program Files\\Java\\jdk1.8.0_144\\bin\\java.exe&quot; &quot;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.1\\lib\\idea_rt.jar=61415:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.1\\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\rt.jar;D:\\IdeaProjects\\practice\\target\\classes;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\mahout\\mahout-core\\0.9\\mahout-core-0.9.jar;C:\\Users\\Simon\\.m2\\repository\\org\\codehaus\\jackson\\jackson-core-asl\\1.9.12\\jackson-core-asl-1.9.12.jar;C:\\Users\\Simon\\.m2\\repository\\org\\codehaus\\jackson\\jackson-mapper-asl\\1.9.12\\jackson-mapper-asl-1.9.12.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\commons\\commons-lang3\\3.1\\commons-lang3-3.1.jar;C:\\Users\\Simon\\.m2\\repository\\com\\thoughtworks\\xstream\\xstream\\1.4.4\\xstream-1.4.4.jar;C:\\Users\\Simon\\.m2\\repository\\xmlpull\\xmlpull\\1.1.3.1\\xmlpull-1.1.3.1.jar;C:\\Users\\Simon\\.m2\\repository\\xpp3\\xpp3_min\\1.1.4c\\xpp3_min-1.1.4c.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-core\\4.6.1\\lucene-core-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-analyzers-common\\4.6.1\\lucene-analyzers-common-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\mahout\\commons\\commons-cli\\2.0-mahout\\commons-cli-2.0-mahout.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\commons\\commons-math3\\3.2\\commons-math3-3.2.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\solr\\solr-commons-csv\\3.5.0\\solr-commons-csv-3.5.0.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\hadoop\\hadoop-core\\1.2.1\\hadoop-core-1.2.1.jar;C:\\Users\\Simon\\.m2\\repository\\commons-cli\\commons-cli\\1.2\\commons-cli-1.2.jar;C:\\Users\\Simon\\.m2\\repository\\com\\sun\\jersey\\jersey-core\\1.8\\jersey-core-1.8.jar;C:\\Users\\Simon\\.m2\\repository\\com\\sun\\jersey\\jersey-json\\1.8\\jersey-json-1.8.jar;C:\\Users\\Simon\\.m2\\repository\\org\\codehaus\\jettison\\jettison\\1.1\\jettison-1.1.jar;C:\\Users\\Simon\\.m2\\repository\\stax\\stax-api\\1.0.1\\stax-api-1.0.1.jar;C:\\Users\\Simon\\.m2\\repository\\com\\sun\\xml\\bind\\jaxb-impl\\2.2.3-1\\jaxb-impl-2.2.3-1.jar;C:\\Users\\Simon\\.m2\\repository\\javax\\xml\\bind\\jaxb-api\\2.2.2\\jaxb-api-2.2.2.jar;C:\\Users\\Simon\\.m2\\repository\\javax\\xml\\stream\\stax-api\\1.0-2\\stax-api-1.0-2.jar;C:\\Users\\Simon\\.m2\\repository\\javax\\activation\\activation\\1.1\\activation-1.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\codehaus\\jackson\\jackson-jaxrs\\1.7.1\\jackson-jaxrs-1.7.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\codehaus\\jackson\\jackson-xc\\1.7.1\\jackson-xc-1.7.1.jar;C:\\Users\\Simon\\.m2\\repository\\com\\sun\\jersey\\jersey-server\\1.8\\jersey-server-1.8.jar;C:\\Users\\Simon\\.m2\\repository\\asm\\asm\\3.1\\asm-3.1.jar;C:\\Users\\Simon\\.m2\\repository\\commons-httpclient\\commons-httpclient\\3.0.1\\commons-httpclient-3.0.1.jar;C:\\Users\\Simon\\.m2\\repository\\commons-logging\\commons-logging\\1.0.3\\commons-logging-1.0.3.jar;C:\\Users\\Simon\\.m2\\repository\\commons-codec\\commons-codec\\1.4\\commons-codec-1.4.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\commons\\commons-math\\2.1\\commons-math-2.1.jar;C:\\Users\\Simon\\.m2\\repository\\commons-configuration\\commons-configuration\\1.6\\commons-configuration-1.6.jar;C:\\Users\\Simon\\.m2\\repository\\commons-collections\\commons-collections\\3.2.1\\commons-collections-3.2.1.jar;C:\\Users\\Simon\\.m2\\repository\\commons-lang\\commons-lang\\2.4\\commons-lang-2.4.jar;C:\\Users\\Simon\\.m2\\repository\\commons-digester\\commons-digester\\1.8\\commons-digester-1.8.jar;C:\\Users\\Simon\\.m2\\repository\\commons-beanutils\\commons-beanutils\\1.7.0\\commons-beanutils-1.7.0.jar;C:\\Users\\Simon\\.m2\\repository\\commons-beanutils\\commons-beanutils-core\\1.8.0\\commons-beanutils-core-1.8.0.jar;C:\\Users\\Simon\\.m2\\repository\\commons-net\\commons-net\\1.4.1\\commons-net-1.4.1.jar;C:\\Users\\Simon\\.m2\\repository\\commons-el\\commons-el\\1.0\\commons-el-1.0.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\mahout\\mahout-integration\\0.9\\mahout-integration-0.9.jar;C:\\Users\\Simon\\.m2\\repository\\commons-io\\commons-io\\2.4\\commons-io-2.4.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\mahout\\mahout-math\\0.9\\mahout-math-0.9.jar;C:\\Users\\Simon\\.m2\\repository\\com\\google\\guava\\guava\\16.0\\guava-16.0.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\mahout\\mahout-examples\\0.9\\mahout-examples-0.9.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-benchmark\\4.6.1\\lucene-benchmark-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-highlighter\\4.6.1\\lucene-highlighter-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-queries\\4.6.1\\lucene-queries-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-memory\\4.6.1\\lucene-memory-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-queryparser\\4.6.1\\lucene-queryparser-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-sandbox\\4.6.1\\lucene-sandbox-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\jakarta-regexp\\jakarta-regexp\\1.4\\jakarta-regexp-1.4.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-facet\\4.6.1\\lucene-facet-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\lucene\\lucene-spatial\\4.6.1\\lucene-spatial-4.6.1.jar;C:\\Users\\Simon\\.m2\\repository\\com\\spatial4j\\spatial4j\\0.3\\spatial4j-0.3.jar;C:\\Users\\Simon\\.m2\\repository\\com\\ibm\\icu\\icu4j\\49.1\\icu4j-49.1.jar;C:\\Users\\Simon\\.m2\\repository\\net\\sourceforge\\nekohtml\\nekohtml\\1.9.17\\nekohtml-1.9.17.jar;C:\\Users\\Simon\\.m2\\repository\\org\\apache\\commons\\commons-compress\\1.4.1\\commons-compress-1.4.1.jar;C:\\Users\\Simon\\.m2\\repository\\xerces\\xercesImpl\\2.9.1\\xercesImpl-2.9.1.jar;C:\\Users\\Simon\\.m2\\repository\\org\\slf4j\\slf4j-log4j12\\1.7.25\\slf4j-log4j12-1.7.25.jar;C:\\Users\\Simon\\.m2\\repository\\log4j\\log4j\\1.2.17\\log4j-1.2.17.jar;C:\\Users\\Simon\\.m2\\repository\\org\\slf4j\\slf4j-api\\1.7.25\\slf4j-api-1.7.25.jar&quot; com.aliatry.mahout.App19/05/13 17:36:19 INFO file.FileDataModel: Creating FileDataModel for file D:\\data.csv19/05/13 17:36:19 INFO file.FileDataModel: Reading file info...19/05/13 17:36:19 INFO file.FileDataModel: Read lines: 2419/05/13 17:36:19 INFO model.GenericDataModel: Processed 5 usersuser : 0user : 16[3.6425023] 0[3.1900032] 3[2.3574977]user : 21[1.0]user : 35[5.0] 6[3.457395]user : 42[4.0] 4[3.145341]19/05/13 17:36:19 INFO file.FileDataModel: Creating FileDataModel for file D:\\data.csv19/05/13 17:36:19 INFO file.FileDataModel: Reading file info...19/05/13 17:36:19 INFO file.FileDataModel: Read lines: 2419/05/13 17:36:19 INFO model.GenericDataModel: Processed 5 users根据用户1当前浏览的商品5，推荐2个相似的商品RecommendedItem[item:2, value:2.0]RecommendedItem[item:1, value:0.0]19/05/13 17:36:19 INFO file.FileDataModel: Creating FileDataModel for file D:\\data.csv19/05/13 17:36:19 INFO file.FileDataModel: Reading file info...19/05/13 17:36:19 INFO file.FileDataModel: Read lines: 2419/05/13 17:36:19 INFO model.GenericDataModel: Processed 5 usersRecommendedItem[item:3, value:3.5]RecommendedItem[item:4, value:3.0]Process finished with exit code 0\n\n项目gitee地址","categories":["Mahout"],"tags":["机器学习","Mahout","Hadoop"]}]